// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using QuickType;
//
//    var models = Models.FromJson(jsonString);

using System;
using System.Collections.Generic;
using System.Globalization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;

namespace CowLibCore.Schemas.Manifest
{
    /// <summary>
    /// The manifest for a Minecraft Bedrock Edition Add-On.
    /// </summary>
    public partial class ManifestFile
    {
        /// <summary>
        /// These are the different features that the Pack makes use of that aren't necessarily
        /// enabled by default.
        /// </summary>
        [JsonProperty("capabilities", NullValueHandling = NullValueHandling.Ignore)]
        public List<Capability> Capabilities { get; set; } = new List<Capability>();

        /// <summary>
        /// This section describes the packs that this Pack depends on in order to work. Any packs
        /// defined here will be automatically added to the world when this one is added if they are
        /// present, or an error will be shown if they aren't.
        /// </summary>
        [JsonProperty("dependencies", NullValueHandling = NullValueHandling.Ignore)]
        public List<Dependency> Dependencies { get; set; } = new List<Dependency>();

        /// <summary>
        /// This defines the current version of the manifest. Don't change this unless you have a
        /// good reason to
        /// </summary>
        [JsonProperty("format_version")]
        public long FormatVersion { get; set; } = 2;

        /// <summary>
        /// This is the heading of the manifest and is required for the manifest to be valid.
        /// </summary>
        [JsonProperty("header")]
        public Header Header { get; set; } = new Header();

        /// <summary>
        /// This section contains additional data about your Pack and is otherwise optional.
        /// </summary>
        [JsonProperty("metadata", NullValueHandling = NullValueHandling.Ignore)]
        public Metadata Metadata { get; set; } = new Metadata();

        /// <summary>
        /// This section describes the modules that comprise the Pack. Each entry here defines one of
        /// the kinds of contents of the Pack.
        /// </summary>
        [JsonProperty("modules", NullValueHandling = NullValueHandling.Ignore)]
        public List<Module> Modules { get; set; } = new List<Module>();
    }

    public class Dependency
    {
        [JsonProperty("uuid", NullValueHandling = NullValueHandling.Ignore)]
        public Guid? Uuid { get; set; }

        /// <summary>
        /// This is the specific version of the Pack that your Pack depends on. Should match the
        /// version the other Pack has in its manifest file
        /// </summary>
        [JsonProperty("version", NullValueHandling = NullValueHandling.Ignore)]
        public double[] Version { get; set; }
    }

    /// <summary>
    /// This is the heading of the manifest and is required for the manifest to be valid.
    /// </summary>
    public class Header
    {
        /// <summary>
        /// This is the version of the base game your world template requires, specified as
        /// [majorVersion, minorVersion, revision].
        /// We use this to determine what version of the base game resource and behavior packs to
        /// apply when your content is used.
        /// </summary>
        [JsonProperty("base_game_version", NullValueHandling = NullValueHandling.Ignore)]
        public int[] BaseGameVersion { get; set; } = {1, 16, 0};

        /// <summary>
        /// This is a short description of the Pack. It will appear in the game below the Name of the
        /// Pack. We recommend keeping it to 1-2 lines.
        /// </summary>
        [JsonProperty("description", NullValueHandling = NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// This option is required for any world templates. This will lock the player from modifying
        /// the options of the world.
        /// </summary>
        [JsonProperty("lock_template_options", NullValueHandling = NullValueHandling.Ignore)]
        public bool? LockTemplateOptions { get; set; } = true;

        /// <summary>
        /// This is the minimum version of the game that this Pack was written for. This helps the
        /// game identify whether any backwards compatibility is needed for your Pack. You should
        /// always use the highest version currently available when creating packs
        /// </summary>
        [JsonProperty("min_engine_version", NullValueHandling = NullValueHandling.Ignore)]
        public int[] MinEngineVersion { get; set; } = { 1, 16, 0 };

        /// <summary>
        /// This is the Name of the Pack as it appears within Minecraft. This is a required field
        /// </summary>
        [JsonRequired]
        [JsonProperty("Name")]
        public string Name { get; set; }

        /// <summary>
        /// This is a special type of identifier that uniquely identifies this Pack from any other
        /// Pack. UUIDs are written in the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx where each x
        /// is a hexadecimal value (0-9 or a-f). We recommend using an online service to generate
        /// this and guarantee their uniqueness (just bing UUID Generator to find some)
        /// </summary>
        [JsonProperty("uuid", NullValueHandling = NullValueHandling.Ignore)]
        public Guid? Uuid { get; set; }

        /// <summary>
        /// This is the version of your Pack in the format [majorVersion, minorVersion, revision].
        /// The version number is used when importing a Pack that has been imported before. The new
        /// Pack will replace the old one if the version is higher, and ignored if it's the same or
        /// lower
        /// </summary>
        [JsonRequired]
        [JsonProperty("version", NullValueHandling = NullValueHandling.Ignore)]
        public int[] Version { get; set; }
    }

    /// <summary>
    /// This section contains additional data about your Pack and is otherwise optional.
    /// </summary>
    public class Metadata
    {
        /// <summary>
        /// Name of the author(s) of the Pack
        /// </summary>
        [JsonProperty("authors", NullValueHandling = NullValueHandling.Ignore)]
        public List<string> Authors { get; set; } = new List<string>();

        /// <summary>
        /// The license of the Pack
        /// </summary>
        [JsonProperty("license", NullValueHandling = NullValueHandling.Ignore)]
        public string License { get; set; }

        /// <summary>
        /// The home website of your Pack
        /// </summary>
        [JsonProperty("url", NullValueHandling = NullValueHandling.Ignore)]
        public Uri Url { get; set; }
    }

    public class Module
    {
        /// <summary>
        /// This is a short description of the module. This is not user-facing at the moment but is a
        /// good place to remind yourself why the module is defined
        /// </summary>
        [JsonProperty("description", NullValueHandling = NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// This is the type of the module. Can be any of the following: resources, data,
        /// client_data, interface, world_template
        /// </summary>
        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public TypeEnum? Type { get; set; }

        /// <summary>
        /// This is a unique identifier for the module in the same format as the Pack's UUID in the
        /// header. This should be different from the Pack's UUID, and different for every module
        /// </summary>
        [JsonProperty("uuid", NullValueHandling = NullValueHandling.Ignore)]
        public Guid? Uuid { get; set; }

        /// <summary>
        /// This is the version of the module in the same format as the Pack's version in the header.
        /// This can be used to further identify changes in your Pack
        /// </summary>
        [JsonProperty("version", NullValueHandling = NullValueHandling.Ignore)]
        public double[] Version { get; set; }
    }

    public enum Capability { Chemistry, ExperimentalCustomUi };

    /// <summary>
    /// This is the type of the module. Can be any of the following: resources, data,
    /// client_data, interface, world_template
    /// </summary>
    public enum TypeEnum { ClientData, Data, Interface, Resources, WorldTemplate };

    public partial class ManifestFile
    {
        public static ManifestFile FromJson(string json) => JsonConvert.DeserializeObject<ManifestFile>(json, Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this ManifestFile self) => JsonConvert.SerializeObject(self, Formatting.Indented, Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                CapabilityConverter.Singleton,
                TypeEnumConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class CapabilityConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Capability) || t == typeof(Capability?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "chemistry":
                    return Capability.Chemistry;
                case "experimental_custom_ui":
                    return Capability.ExperimentalCustomUi;
            }
            throw new Exception("Cannot unmarshal type Capability");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Capability)untypedValue;
            switch (value)
            {
                case Capability.Chemistry:
                    serializer.Serialize(writer, "chemistry");
                    return;
                case Capability.ExperimentalCustomUi:
                    serializer.Serialize(writer, "experimental_custom_ui");
                    return;
            }
            throw new Exception("Cannot marshal type Capability");
        }

        public static readonly CapabilityConverter Singleton = new CapabilityConverter();
    }

    internal class TypeEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TypeEnum) || t == typeof(TypeEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "client_data":
                    return TypeEnum.ClientData;
                case "data":
                    return TypeEnum.Data;
                case "interface":
                    return TypeEnum.Interface;
                case "resources":
                    return TypeEnum.Resources;
                case "world_template":
                    return TypeEnum.WorldTemplate;
            }
            throw new Exception("Cannot unmarshal type TypeEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TypeEnum)untypedValue;
            switch (value)
            {
                case TypeEnum.ClientData:
                    serializer.Serialize(writer, "client_data");
                    return;
                case TypeEnum.Data:
                    serializer.Serialize(writer, "data");
                    return;
                case TypeEnum.Interface:
                    serializer.Serialize(writer, "interface");
                    return;
                case TypeEnum.Resources:
                    serializer.Serialize(writer, "resources");
                    return;
                case TypeEnum.WorldTemplate:
                    serializer.Serialize(writer, "world_template");
                    return;
            }
            throw new Exception("Cannot marshal type TypeEnum");
        }

        public static readonly TypeEnumConverter Singleton = new TypeEnumConverter();
    }
}
