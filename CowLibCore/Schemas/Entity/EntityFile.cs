// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using CowLibCore.Schemas.Entity;
//
//    var entityFile = EntityFile.FromJson(jsonString);

namespace CowLibCore.Schemas.Entity
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    /// <summary>
    /// TODO description
    /// </summary>
    public partial class EntityFile
    {
        /// <summary>
        /// A version that tells minecraft what type of data format can be expected when reading this
        /// file.
        /// </summary>
        [JsonProperty("format_version")]
        public string FormatVersion { get; set; } = "1.16.0";

        [JsonProperty("minecraft:entity")]
        public Entity MinecraftEntity { get; set; } = new Entity();
    }

    public partial class Entity
    {
        /// <summary>
        /// Each group when add / remove the default components
        /// </summary>
        [JsonProperty("component_groups", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, ComponentGroup> ComponentGroups { get; set; } = new Dictionary<string, ComponentGroup>();

        /// <summary>
        /// The components that are added as the foundation of the entity
        /// </summary>
        [JsonProperty("components", NullValueHandling = NullValueHandling.Ignore)]
        public ComponentGroup Components { get; set; } = new ComponentGroup();

        /// <summary>
        /// The description of the this entity
        /// </summary>
        [JsonProperty("description")]
        public Description Description { get; set; } = new Description();

        /// <summary>
        /// The events that the entity can run, these add or remove components_groups
        /// </summary>
        [JsonProperty("events", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, EventBase> Events { get; set; } = new Dictionary<string, EventBase>();
    }

    /// <summary>
    /// The components that are added as the foundation of the entity
    ///
    /// Minecraft:entity for 1.16.100
    /// </summary>
    public partial class ComponentGroup
    {
        [JsonProperty("minecraft:addrider", NullValueHandling = NullValueHandling.Ignore)]
        public Addrider180 MinecraftAddrider { get; set; }

        [JsonProperty("minecraft:admire_item", NullValueHandling = NullValueHandling.Ignore)]
        public AdmireItem1160 MinecraftAdmireItem { get; set; }

        [JsonProperty("minecraft:ageable", NullValueHandling = NullValueHandling.Ignore)]
        public Ageable1160 MinecraftAgeable { get; set; }

        [JsonProperty("minecraft:ambient_sound_interval", NullValueHandling = NullValueHandling.Ignore)]
        public AmbientSoundInterval1160 MinecraftAmbientSoundInterval { get; set; }

        [JsonProperty("minecraft:angry", NullValueHandling = NullValueHandling.Ignore)]
        public Angry1160 MinecraftAngry { get; set; }

        [JsonProperty("minecraft:annotation.break_door", NullValueHandling = NullValueHandling.Ignore)]
        public AnnotationBreakDoor180 MinecraftAnnotationBreakDoor { get; set; }

        [JsonProperty("minecraft:annotation.open_door", NullValueHandling = NullValueHandling.Ignore)]
        public AnnotationOpenDoor180 MinecraftAnnotationOpenDoor { get; set; }

        [JsonProperty("minecraft:area_attack", NullValueHandling = NullValueHandling.Ignore)]
        public AreaAttack1160 MinecraftAreaAttack { get; set; }

        [JsonProperty("minecraft:attack", NullValueHandling = NullValueHandling.Ignore)]
        public Attack180 MinecraftAttack { get; set; }

        [JsonProperty("minecraft:attack_cooldown", NullValueHandling = NullValueHandling.Ignore)]
        public AttackCooldown1160 MinecraftAttackCooldown { get; set; }

        [JsonProperty("minecraft:attack_damage", NullValueHandling = NullValueHandling.Ignore)]
        public AttackDamage180 MinecraftAttackDamage { get; set; }

        [JsonProperty("minecraft:balloonable", NullValueHandling = NullValueHandling.Ignore)]
        public Balloonable180 MinecraftBalloonable { get; set; }

        [JsonProperty("minecraft:barter", NullValueHandling = NullValueHandling.Ignore)]
        public Barter1160 MinecraftBarter { get; set; }

        [JsonProperty("minecraft:behavior.admire_item", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviourAdmireItem1160 MinecraftBehaviorAdmireItem { get; set; }

        [JsonProperty("minecraft:behavior.avoid_block", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviourAvoidBlock1160 MinecraftBehaviorAvoidBlock { get; set; }

        [JsonProperty("minecraft:behavior.avoid_mob_type", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorAvoidMobType180 MinecraftBehaviorAvoidMobType { get; set; }

        [JsonProperty("minecraft:behavior.barter", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviourBarter1160 MinecraftBehaviorBarter { get; set; }

        [JsonProperty("minecraft:behavior.beg", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorBeg180 MinecraftBehaviorBeg { get; set; }

        [JsonProperty("minecraft:behavior.break_door", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorBreakDoor180 MinecraftBehaviorBreakDoor { get; set; }

        [JsonProperty("minecraft:behavior.breed", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorBreed180 MinecraftBehaviorBreed { get; set; }

        [JsonProperty("minecraft:behavior.celebrate", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviourCelebrate1160 MinecraftBehaviorCelebrate { get; set; }

        [JsonProperty("minecraft:behavior.charge_attack", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorChargeAttack180 MinecraftBehaviorChargeAttack { get; set; }

        [JsonProperty("minecraft:behavior.charge_held_item", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorChargeHeldItem180 MinecraftBehaviorChargeHeldItem { get; set; }

        [JsonProperty("minecraft:behavior.circle_around_anchor", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorCircleAroundAnchor180 MinecraftBehaviorCircleAroundAnchor { get; set; }

        [JsonProperty("minecraft:behavior.controlled_by_player", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorControlledByPlayer180 MinecraftBehaviorControlledByPlayer { get; set; }

        [JsonProperty("minecraft:behavior.defend_trusted_target", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviourDefendTrustedTarget1160 MinecraftBehaviorDefendTrustedTarget { get; set; }

        [JsonProperty("minecraft:behavior.defend_village_target", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorDefendVillageTarget180 MinecraftBehaviorDefendVillageTarget { get; set; }

        [JsonProperty("minecraft:behavior.delayed_attack", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorDelayedAttack180 MinecraftBehaviorDelayedAttack { get; set; }

        [JsonProperty("minecraft:behavior.door_interact", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorDoorInteract180 MinecraftBehaviorDoorInteract { get; set; }

        [JsonProperty("minecraft:behavior.dragonchargeplayer", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorDragonchargeplayer180 MinecraftBehaviorDragonchargeplayer { get; set; }

        [JsonProperty("minecraft:behavior.dragondeath", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorDragondeath180 MinecraftBehaviorDragondeath { get; set; }

        [JsonProperty("minecraft:behavior.dragonflaming", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorDragonflaming180 MinecraftBehaviorDragonflaming { get; set; }

        [JsonProperty("minecraft:behavior.dragonholdingpattern", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorDragonholdingpattern180 MinecraftBehaviorDragonholdingpattern { get; set; }

        [JsonProperty("minecraft:behavior.dragonlanding", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorDragonlanding180 MinecraftBehaviorDragonlanding { get; set; }

        [JsonProperty("minecraft:behavior.dragonscanning", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorDragonscanning180 MinecraftBehaviorDragonscanning { get; set; }

        [JsonProperty("minecraft:behavior.dragonstrafeplayer", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorDragonstrafeplayer180 MinecraftBehaviorDragonstrafeplayer { get; set; }

        [JsonProperty("minecraft:behavior.dragontakeoff", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorDragontakeoff180 MinecraftBehaviorDragontakeoff { get; set; }

        [JsonProperty("minecraft:behavior.drink_potion", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorBeg1160 MinecraftBehaviorDrinkPotion { get; set; }

        [JsonProperty("minecraft:behavior.drop_item_for", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorDropItemFor1160 MinecraftBehaviorDropItemFor { get; set; }

        [JsonProperty("minecraft:behavior.eat_block", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorEatBlock180 MinecraftBehaviorEatBlock { get; set; }

        [JsonProperty("minecraft:behavior.eat_carried_item", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviourEatCarriedItem1160 MinecraftBehaviorEatCarriedItem { get; set; }

        [JsonProperty("minecraft:behavior.enderman_leave_block", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorEndermanLeaveBlock180 MinecraftBehaviorEndermanLeaveBlock { get; set; }

        [JsonProperty("minecraft:behavior.enderman_take_block", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorEndermanTakeBlock180 MinecraftBehaviorEndermanTakeBlock { get; set; }

        [JsonProperty("minecraft:behavior.equip_item", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviourEquipItem1160 MinecraftBehaviorEquipItem { get; set; }

        [JsonProperty("minecraft:behavior.explore_outskirts", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorExploreOutskirts180 MinecraftBehaviorExploreOutskirts { get; set; }

        [JsonProperty("minecraft:behavior.find_cover", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviourFindCover1160 MinecraftBehaviorFindCover { get; set; }

        [JsonProperty("minecraft:behavior.find_mount", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorFindMount1160 MinecraftBehaviorFindMount { get; set; }

        [JsonProperty("minecraft:behavior.find_underwater_treasure", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorFindUnderwaterTreasure180 MinecraftBehaviorFindUnderwaterTreasure { get; set; }

        [JsonProperty("minecraft:behavior.flee_sun", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorFleeSun180 MinecraftBehaviorFleeSun { get; set; }

        [JsonProperty("minecraft:behavior.float", NullValueHandling = NullValueHandling.Ignore)]
        public MinecraftBehaviorFloatClass MinecraftBehaviorFloat { get; set; }

        [JsonProperty("minecraft:behavior.float_wander", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorFloatWander180 MinecraftBehaviorFloatWander { get; set; }

        [JsonProperty("minecraft:behavior.follow_caravan", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorFollowCaravan180 MinecraftBehaviorFollowCaravan { get; set; }

        [JsonProperty("minecraft:behavior.follow_mob", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorFollowMob180 MinecraftBehaviorFollowMob { get; set; }

        [JsonProperty("minecraft:behavior.follow_owner", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorFollowOwner180 MinecraftBehaviorFollowOwner { get; set; }

        [JsonProperty("minecraft:behavior.follow_parent", NullValueHandling = NullValueHandling.Ignore)]
        public MinecraftBehaviorFollowParentClass MinecraftBehaviorFollowParent { get; set; }

        [JsonProperty("minecraft:behavior.follow_target_captain", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorFollowTargetCaptain180 MinecraftBehaviorFollowTargetCaptain { get; set; }

        [JsonProperty("minecraft:behavior.go_home", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorGoHome MinecraftBehaviorGoHome { get; set; }

        [JsonProperty("minecraft:behavior.guardian_attack", NullValueHandling = NullValueHandling.Ignore)]
        public MinecraftBehaviorGuardianAttackClass MinecraftBehaviorGuardianAttack { get; set; }

        [JsonProperty("minecraft:behavior.harvest_farm_block", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorHarvestFarmBlock180 MinecraftBehaviorHarvestFarmBlock { get; set; }

        [JsonProperty("minecraft:behavior.hide", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorHide180 MinecraftBehaviorHide { get; set; }

        [JsonProperty("minecraft:behavior.hold_ground", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviourHoldGround1160 MinecraftBehaviorHoldGround { get; set; }

        [JsonProperty("minecraft:behavior.hurt_by_target", NullValueHandling = NullValueHandling.Ignore)]
        public MinecraftBehaviorHurtByTargetClass MinecraftBehaviorHurtByTarget { get; set; }

        [JsonProperty("minecraft:behavior.inspect_bookshelf", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorInspectBookshelf180 MinecraftBehaviorInspectBookshelf { get; set; }

        [JsonProperty("minecraft:behavior.knockback_roar", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorKnockbackRoar1160 MinecraftBehaviorKnockbackRoar { get; set; }

        [JsonProperty("minecraft:behavior.lay_down", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorLayDown180 MinecraftBehaviorLayDown { get; set; }

        [JsonProperty("minecraft:behavior.lay_egg", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorLayEgg180 MinecraftBehaviorLayEgg { get; set; }

        [JsonProperty("minecraft:behavior.leap_at_target", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorLeapAtTarget1160 MinecraftBehaviorLeapAtTarget { get; set; }

        [JsonProperty("minecraft:behavior.look_at_entity", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorLookAtEntity180 MinecraftBehaviorLookAtEntity { get; set; }

        [JsonProperty("minecraft:behavior.look_at_player", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorLookAtPlayer1160 MinecraftBehaviorLookAtPlayer { get; set; }

        [JsonProperty("minecraft:behavior.look_at_target", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorLookAtTarget180 MinecraftBehaviorLookAtTarget { get; set; }

        [JsonProperty("minecraft:behavior.look_at_trading_player", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorLookAtTradingPlayer180 MinecraftBehaviorLookAtTradingPlayer { get; set; }

        [JsonProperty("minecraft:behavior.make_love", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorMakeLove180 MinecraftBehaviorMakeLove { get; set; }

        [JsonProperty("minecraft:behavior.melee_attack", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorMeleeAttack180 MinecraftBehaviorMeleeAttack { get; set; }

        [JsonProperty("minecraft:behavior.mingle", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorMingle180 MinecraftBehaviorMingle { get; set; }

        [JsonProperty("minecraft:behavior.mount_pathing", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorMountPathing180 MinecraftBehaviorMountPathing { get; set; }

        [JsonProperty("minecraft:behavior.move_indoors", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorMoveIndoors180 MinecraftBehaviorMoveIndoors { get; set; }

        [JsonProperty("minecraft:behavior.move_through_village", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorMoveThroughVillage180 MinecraftBehaviorMoveThroughVillage { get; set; }

        [JsonProperty("minecraft:behavior.move_to_block", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorMoveToBlock180 MinecraftBehaviorMoveToBlock { get; set; }

        [JsonProperty("minecraft:behavior.move_to_land", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorMoveToLand180 MinecraftBehaviorMoveToLand { get; set; }

        [JsonProperty("minecraft:behavior.move_to_lava", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviourMoveToLava1160 MinecraftBehaviorMoveToLava { get; set; }

        [JsonProperty("minecraft:behavior.move_to_liquid", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviourMoveToLiquid180 MinecraftBehaviorMoveToLiquid { get; set; }

        [JsonProperty("minecraft:behavior.move_to_poi", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorMoveToPoi180 MinecraftBehaviorMoveToPoi { get; set; }

        [JsonProperty("minecraft:behavior.move_to_random_block", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorMoveToRandomBlock180 MinecraftBehaviorMoveToRandomBlock { get; set; }

        [JsonProperty("minecraft:behavior.move_to_village", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorMoveToVillage180 MinecraftBehaviorMoveToVillage { get; set; }

        [JsonProperty("minecraft:behavior.move_to_water", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorMoveToWater180 MinecraftBehaviorMoveToWater { get; set; }

        [JsonProperty("minecraft:behavior.move_towards_dwelling_restriction", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorMoveTowardsDwellingRestriction180 MinecraftBehaviorMoveTowardsDwellingRestriction { get; set; }

        [JsonProperty("minecraft:behavior.move_towards_home_restriction", NullValueHandling = NullValueHandling.Ignore)]
        public MoveTowardsHomeRestriction1160 MinecraftBehaviorMoveTowardsHomeRestriction { get; set; }

        [JsonProperty("minecraft:behavior.move_towards_restriction", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorMoveTowardsRestriction180 MinecraftBehaviorMoveTowardsRestriction { get; set; }

        [JsonProperty("minecraft:behavior.move_towards_target", NullValueHandling = NullValueHandling.Ignore)]
        public MinecraftBehaviorMoveTowardsTargetClass MinecraftBehaviorMoveTowardsTarget { get; set; }

        [JsonProperty("minecraft:behavior.nap", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviourNap1160 MinecraftBehaviorNap { get; set; }

        [JsonProperty("minecraft:behavior.nearest_attackable_target", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorNearestAttackableTarget1160 MinecraftBehaviorNearestAttackableTarget { get; set; }

        [JsonProperty("minecraft:behavior.nearest_prioritized_attackable_target", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorNearestPrioritizedAttackableTarget1160 MinecraftBehaviorNearestPrioritizedAttackableTarget { get; set; }

        [JsonProperty("minecraft:behavior.ocelot_sit_on_block", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorOcelotSitOnBlock180 MinecraftBehaviorOcelotSitOnBlock { get; set; }

        [JsonProperty("minecraft:behavior.ocelotattack", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorOcelotattack180 MinecraftBehaviorOcelotattack { get; set; }

        [JsonProperty("minecraft:behavior.offer_flower", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorOfferFlower180 MinecraftBehaviorOfferFlower { get; set; }

        [JsonProperty("minecraft:behavior.open_door", NullValueHandling = NullValueHandling.Ignore)]
        public MinecraftBehaviorOpenDoorClass MinecraftBehaviorOpenDoor { get; set; }

        [JsonProperty("minecraft:behavior.owner_hurt_by_target", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorOwnerHurtByTarget180 MinecraftBehaviorOwnerHurtByTarget { get; set; }

        [JsonProperty("minecraft:behavior.owner_hurt_target", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorOwnerHurtTarget180 MinecraftBehaviorOwnerHurtTarget { get; set; }

        [JsonProperty("minecraft:behavior.panic", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorPanic180 MinecraftBehaviorPanic { get; set; }

        [JsonProperty("minecraft:behavior.peek", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorPeek180 MinecraftBehaviorPeek { get; set; }

        [JsonProperty("minecraft:behavior.pet_sleep_with_owner", NullValueHandling = NullValueHandling.Ignore)]
        public MinecraftBehaviorPetSleepWithOwnerClass MinecraftBehaviorPetSleepWithOwner { get; set; }

        [JsonProperty("minecraft:behavior.pickup_items", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorPickupItems1160 MinecraftBehaviorPickupItems { get; set; }

        [JsonProperty("minecraft:behavior.play", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorPlay180 MinecraftBehaviorPlay { get; set; }

        [JsonProperty("minecraft:behavior.player_ride_tamed", NullValueHandling = NullValueHandling.Ignore)]
        public MinecraftBehaviorPlayerRideTamedClass MinecraftBehaviorPlayerRideTamed { get; set; }

        [JsonProperty("minecraft:behavior.raid_garden", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorRaidGarden180 MinecraftBehaviorRaidGarden { get; set; }

        [JsonProperty("minecraft:behavior.random_breach", NullValueHandling = NullValueHandling.Ignore)]
        public MinecraftBehaviorRandomBreachClass MinecraftBehaviorRandomBreach { get; set; }

        [JsonProperty("minecraft:behavior.random_fly", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorRandomFly1160 MinecraftBehaviorRandomFly { get; set; }

        [JsonProperty("minecraft:behavior.random_hover", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorRandomHover1160 MinecraftBehaviorRandomHover { get; set; }

        [JsonProperty("minecraft:behavior.random_look_around", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorRandomLookAround180 MinecraftBehaviorRandomLookAround { get; set; }

        [JsonProperty("minecraft:behavior.random_look_around_and_sit", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorRandomLookAroundAndSit1160 MinecraftBehaviorRandomLookAroundAndSit { get; set; }

        [JsonProperty("minecraft:behavior.random_sitting", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorRandomSitting180 MinecraftBehaviorRandomSitting { get; set; }

        [JsonProperty("minecraft:behavior.random_stroll", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorRandomStroll180 MinecraftBehaviorRandomStroll { get; set; }

        [JsonProperty("minecraft:behavior.random_swim", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorRandomSwim180 MinecraftBehaviorRandomSwim { get; set; }

        [JsonProperty("minecraft:behavior.ranged_attack", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorRangedAttack180 MinecraftBehaviorRangedAttack { get; set; }

        [JsonProperty("minecraft:behavior.receive_love", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorReceiveLove180 MinecraftBehaviorReceiveLove { get; set; }

        [JsonProperty("minecraft:behavior.restrict_open_door", NullValueHandling = NullValueHandling.Ignore)]
        public MinecraftBehaviorRestrictOpenDoorClass MinecraftBehaviorRestrictOpenDoor { get; set; }

        [JsonProperty("minecraft:behavior.restrict_sun", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorRestrictSun180 MinecraftBehaviorRestrictSun { get; set; }

        [JsonProperty("minecraft:behavior.rise_to_liquid_level", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorRiseToLiquidLevel1160 MinecraftBehaviorRiseToLiquidLevel { get; set; }

        [JsonProperty("minecraft:behavior.roll", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorRoll180 MinecraftBehaviorRoll { get; set; }

        [JsonProperty("minecraft:behavior.run_around_like_crazy", NullValueHandling = NullValueHandling.Ignore)]
        public MinecraftBehaviorRunAroundLikeCrazyClass MinecraftBehaviorRunAroundLikeCrazy { get; set; }

        [JsonProperty("minecraft:behavior.scared", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorScared180 MinecraftBehaviorScared { get; set; }

        [JsonProperty("minecraft:behavior.send_event", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorSendEvent1160 MinecraftBehaviorSendEvent { get; set; }

        [JsonProperty("minecraft:behavior.share_items", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorShareItems180 MinecraftBehaviorShareItems { get; set; }

        [JsonProperty("minecraft:behavior.silverfish_merge_with_stone", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorSilverfishMergeWithStone180 MinecraftBehaviorSilverfishMergeWithStone { get; set; }

        [JsonProperty("minecraft:behavior.silverfish_wake_up_friends", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorSilverfishWakeUpFriends180 MinecraftBehaviorSilverfishWakeUpFriends { get; set; }

        [JsonProperty("minecraft:behavior.skeleton_horse_trap", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorSkeletonHorseTrap180 MinecraftBehaviorSkeletonHorseTrap { get; set; }

        [JsonProperty("minecraft:behavior.sleep", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorSleep180 MinecraftBehaviorSleep { get; set; }

        [JsonProperty("minecraft:behavior.slime_attack", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorSlimeAttack180 MinecraftBehaviorSlimeAttack { get; set; }

        [JsonProperty("minecraft:behavior.slime_float", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorSlimeFloat180 MinecraftBehaviorSlimeFloat { get; set; }

        [JsonProperty("minecraft:behavior.slime_keep_on_jumping", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorSlimeKeepOnJumping180 MinecraftBehaviorSlimeKeepOnJumping { get; set; }

        [JsonProperty("minecraft:behavior.slime_random_direction", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorSlimeRandomDirection180 MinecraftBehaviorSlimeRandomDirection { get; set; }

        [JsonProperty("minecraft:behavior.snacking", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorSnacking180 MinecraftBehaviorSnacking { get; set; }

        [JsonProperty("minecraft:behavior.sneeze", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorSneeze180 MinecraftBehaviorSneeze { get; set; }

        [JsonProperty("minecraft:behavior.squid_dive", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorSquidDive180 MinecraftBehaviorSquidDive { get; set; }

        [JsonProperty("minecraft:behavior.squid_flee", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorSquidFlee180 MinecraftBehaviorSquidFlee { get; set; }

        [JsonProperty("minecraft:behavior.squid_idle", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorSquidIdle180 MinecraftBehaviorSquidIdle { get; set; }

        [JsonProperty("minecraft:behavior.squid_move_away_from_ground", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorSquidMoveAwayFromGround180 MinecraftBehaviorSquidMoveAwayFromGround { get; set; }

        [JsonProperty("minecraft:behavior.squid_out_of_water", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorSquidOutOfWater180 MinecraftBehaviorSquidOutOfWater { get; set; }

        [JsonProperty("minecraft:behavior.stalk_and_pounce_on_target", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorStalkAndPounceOnTarget1160 MinecraftBehaviorStalkAndPounceOnTarget { get; set; }

        [JsonProperty("minecraft:behavior.stay_while_sitting", NullValueHandling = NullValueHandling.Ignore)]
        public MinecraftBehaviorStayWhileSittingClass MinecraftBehaviorStayWhileSitting { get; set; }

        [JsonProperty("minecraft:behavior.stomp_attack", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorStompAttack180 MinecraftBehaviorStompAttack { get; set; }

        [JsonProperty("minecraft:behavior.stomp_turtle_egg", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorStompTurtleEgg180 MinecraftBehaviorStompTurtleEgg { get; set; }

        [JsonProperty("minecraft:behavior.stroll_towards_village", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorStrollTowardsVillage1160 MinecraftBehaviorStrollTowardsVillage { get; set; }

        [JsonProperty("minecraft:behavior.summon_entity", NullValueHandling = NullValueHandling.Ignore)]
        public MinecraftBehaviorSummonEntityClass MinecraftBehaviorSummonEntity { get; set; }

        [JsonProperty("minecraft:behavior.swell", NullValueHandling = NullValueHandling.Ignore)]
        public MinecraftBehaviorSwellClass MinecraftBehaviorSwell { get; set; }

        [JsonProperty("minecraft:behavior.swim_idle", NullValueHandling = NullValueHandling.Ignore)]
        public MinecraftBehaviorSwimIdleClass MinecraftBehaviorSwimIdle { get; set; }

        [JsonProperty("minecraft:behavior.swim_wander", NullValueHandling = NullValueHandling.Ignore)]
        public MinecraftBehaviorSwimWanderClass MinecraftBehaviorSwimWander { get; set; }

        [JsonProperty("minecraft:behavior.swim_with_entity", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorSwimWithEntity180 MinecraftBehaviorSwimWithEntity { get; set; }

        [JsonProperty("minecraft:behavior.swoop_attack", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorSwoopAttack180 MinecraftBehaviorSwoopAttack { get; set; }

        [JsonProperty("minecraft:behavior.take_flower", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorTakeFlower180 MinecraftBehaviorTakeFlower { get; set; }

        [JsonProperty("minecraft:behavior.target_when_pushed", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorTargetWhenPushed180 MinecraftBehaviorTargetWhenPushed { get; set; }

        [JsonProperty("minecraft:behavior.tempt", NullValueHandling = NullValueHandling.Ignore)]
        public MinecraftBehaviorTemptClass MinecraftBehaviorTempt { get; set; }

        [JsonProperty("minecraft:behavior.trade_interest", NullValueHandling = NullValueHandling.Ignore)]
        public MinecraftBehaviorTradeInterestClass MinecraftBehaviorTradeInterest { get; set; }

        [JsonProperty("minecraft:behavior.trade_with_player", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorTradeWithPlayer180 MinecraftBehaviorTradeWithPlayer { get; set; }

        [JsonProperty("minecraft:behavior.vex_copy_owner_target", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorVexCopyOwnerTarget180 MinecraftBehaviorVexCopyOwnerTarget { get; set; }

        [JsonProperty("minecraft:behavior.vex_random_move", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorVexRandomMove180 MinecraftBehaviorVexRandomMove { get; set; }

        [JsonProperty("minecraft:behavior.wither_random_attack_pos_goal", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorWitherRandomAttackPosGoal180 MinecraftBehaviorWitherRandomAttackPosGoal { get; set; }

        [JsonProperty("minecraft:behavior.wither_target_highest_damage", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorWitherTargetHighestDamage180 MinecraftBehaviorWitherTargetHighestDamage { get; set; }

        [JsonProperty("minecraft:behavior.work", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorWork180 MinecraftBehaviorWork { get; set; }

        [JsonProperty("minecraft:block_sensor", NullValueHandling = NullValueHandling.Ignore)]
        public BlockSensor1160 MinecraftBlockSensor { get; set; }

        [JsonProperty("minecraft:boostable", NullValueHandling = NullValueHandling.Ignore)]
        public Boostable1160 MinecraftBoostable { get; set; }

        [JsonProperty("minecraft:boss", NullValueHandling = NullValueHandling.Ignore)]
        public Boss180 MinecraftBoss { get; set; }

        [JsonProperty("minecraft:break_blocks", NullValueHandling = NullValueHandling.Ignore)]
        public BehaviorBreakBlocks180 MinecraftBreakBlocks { get; set; }

        [JsonProperty("minecraft:breathable", NullValueHandling = NullValueHandling.Ignore)]
        public Breathable180 MinecraftBreathable { get; set; }

        [JsonProperty("minecraft:breedable", NullValueHandling = NullValueHandling.Ignore)]
        public Breedable1160 MinecraftBreedable { get; set; }

        [JsonProperty("minecraft:bribeable", NullValueHandling = NullValueHandling.Ignore)]
        public Bribeable180 MinecraftBribeable { get; set; }

        [JsonProperty("minecraft:buoyant", NullValueHandling = NullValueHandling.Ignore)]
        public Buoyant1160 MinecraftBuoyant { get; set; }

        [JsonProperty("minecraft:burns_in_daylight", NullValueHandling = NullValueHandling.Ignore)]
        public BurnsInDaylight180? MinecraftBurnsInDaylight { get; set; }

        [JsonProperty("minecraft:can_climb", NullValueHandling = NullValueHandling.Ignore)]
        public CanClimb180 MinecraftCanClimb { get; set; }

        [JsonProperty("minecraft:can_fly", NullValueHandling = NullValueHandling.Ignore)]
        public CanFly180 MinecraftCanFly { get; set; }

        [JsonProperty("minecraft:can_power_jump", NullValueHandling = NullValueHandling.Ignore)]
        public CanPowerJump180 MinecraftCanPowerJump { get; set; }

        [JsonProperty("minecraft:celebrate_hunt", NullValueHandling = NullValueHandling.Ignore)]
        public CelebrateHunt1160 MinecraftCelebrateHunt { get; set; }

        [JsonProperty("minecraft:collision_box", NullValueHandling = NullValueHandling.Ignore)]
        public CollisionBox180 MinecraftCollisionBox { get; set; }

        [JsonProperty("minecraft:color", NullValueHandling = NullValueHandling.Ignore)]
        public Color180 MinecraftColor { get; set; }

        [JsonProperty("minecraft:color2", NullValueHandling = NullValueHandling.Ignore)]
        public Color2180 MinecraftColor2 { get; set; }

        [JsonProperty("minecraft:conditional_bandwidth_optimization", NullValueHandling = NullValueHandling.Ignore)]
        public ConditionalBandwidthOptimization180 MinecraftConditionalBandwidthOptimization { get; set; }

        [JsonProperty("minecraft:custom_hit_test", NullValueHandling = NullValueHandling.Ignore)]
        public CustomHitTest1160 MinecraftCustomHitTest { get; set; }

        [JsonProperty("minecraft:damage_over_time", NullValueHandling = NullValueHandling.Ignore)]
        public DamageOverTime180 MinecraftDamageOverTime { get; set; }

        [JsonProperty("minecraft:damage_sensor", NullValueHandling = NullValueHandling.Ignore)]
        public DamageSensor MinecraftDamageSensor { get; set; }

        [JsonProperty("minecraft:default_look_angle", NullValueHandling = NullValueHandling.Ignore)]
        public DefaultLookAngle180 MinecraftDefaultLookAngle { get; set; }

        [JsonProperty("minecraft:despawn", NullValueHandling = NullValueHandling.Ignore)]
        public Despawn1160 MinecraftDespawn { get; set; }

        [JsonProperty("minecraft:dweller", NullValueHandling = NullValueHandling.Ignore)]
        public Dweller180 MinecraftDweller { get; set; }

        [JsonProperty("minecraft:economy_trade_table", NullValueHandling = NullValueHandling.Ignore)]
        public EconomyTradeTable180 MinecraftEconomyTradeTable { get; set; }

        [JsonProperty("minecraft:entity_sensor", NullValueHandling = NullValueHandling.Ignore)]
        public EntitySensor1160 MinecraftEntitySensor { get; set; }

        [JsonProperty("minecraft:environment_sensor", NullValueHandling = NullValueHandling.Ignore)]
        public EnvironmentSensor MinecraftEnvironmentSensor { get; set; }

        [JsonProperty("minecraft:equip_item", NullValueHandling = NullValueHandling.Ignore)]
        public EquipItem1160 MinecraftEquipItem { get; set; }

        [JsonProperty("minecraft:equipment", NullValueHandling = NullValueHandling.Ignore)]
        public Equipment1160 MinecraftEquipment { get; set; }

        [JsonProperty("minecraft:equippable", NullValueHandling = NullValueHandling.Ignore)]
        public Equippable1160 MinecraftEquippable { get; set; }

        [JsonProperty("minecraft:experience_reward", NullValueHandling = NullValueHandling.Ignore)]
        public ExperienceReward1160 MinecraftExperienceReward { get; set; }

        [JsonProperty("minecraft:explode", NullValueHandling = NullValueHandling.Ignore)]
        public Explode1160 MinecraftExplode { get; set; }

        [JsonProperty("minecraft:fall_damage", NullValueHandling = NullValueHandling.Ignore)]
        public FallDamage180 MinecraftFallDamage { get; set; }

        [JsonProperty("minecraft:fire_immune", NullValueHandling = NullValueHandling.Ignore)]
        public FireImmune180 MinecraftFireImmune { get; set; }

        [JsonProperty("minecraft:floats_in_liquid", NullValueHandling = NullValueHandling.Ignore)]
        public FloatsInLiquid180 MinecraftFloatsInLiquid { get; set; }

        [JsonProperty("minecraft:flocking", NullValueHandling = NullValueHandling.Ignore)]
        public Flocking1160 MinecraftFlocking { get; set; }

        [JsonProperty("minecraft:flying_speed", NullValueHandling = NullValueHandling.Ignore)]
        public FlyingSpeed180 MinecraftFlyingSpeed { get; set; }

        [JsonProperty("minecraft:follow_range", NullValueHandling = NullValueHandling.Ignore)]
        public FollowRange180 MinecraftFollowRange { get; set; }

        [JsonProperty("minecraft:foot_size", NullValueHandling = NullValueHandling.Ignore)]
        public FootSize180 MinecraftFootSize { get; set; }

        [JsonProperty("minecraft:friction_modifier", NullValueHandling = NullValueHandling.Ignore)]
        public FrictionModifier180 MinecraftFrictionModifier { get; set; }

        [JsonProperty("minecraft:genetics", NullValueHandling = NullValueHandling.Ignore)]
        public Genetics180 MinecraftGenetics { get; set; }

        [JsonProperty("minecraft:giveable", NullValueHandling = NullValueHandling.Ignore)]
        public Giveable1160 MinecraftGiveable { get; set; }

        [JsonProperty("minecraft:ground_offset", NullValueHandling = NullValueHandling.Ignore)]
        public GroundOffset180 MinecraftGroundOffset { get; set; }

        [JsonProperty("minecraft:group_size", NullValueHandling = NullValueHandling.Ignore)]
        public GroupSize1160 MinecraftGroupSize { get; set; }

        [JsonProperty("minecraft:grows_crop", NullValueHandling = NullValueHandling.Ignore)]
        public GrowsCrop1160 MinecraftGrowsCrop { get; set; }

        [JsonProperty("minecraft:healable", NullValueHandling = NullValueHandling.Ignore)]
        public Healable180 MinecraftHealable { get; set; }

        [JsonProperty("minecraft:health", NullValueHandling = NullValueHandling.Ignore)]
        public Health180 MinecraftHealth { get; set; }

        [JsonProperty("minecraft:hide", NullValueHandling = NullValueHandling.Ignore)]
        public Hide1160 MinecraftHide { get; set; }

        [JsonProperty("minecraft:home", NullValueHandling = NullValueHandling.Ignore)]
        public Home1160 MinecraftHome { get; set; }

        [JsonProperty("minecraft:horse.jump_strength", NullValueHandling = NullValueHandling.Ignore)]
        public HorseJumpStrength1160 MinecraftHorseJumpStrength { get; set; }

        [JsonProperty("minecraft:hurt_on_condition", NullValueHandling = NullValueHandling.Ignore)]
        public HurtOnCondition1160 MinecraftHurtOnCondition { get; set; }

        [JsonProperty("minecraft:hurt_when_wet", NullValueHandling = NullValueHandling.Ignore)]
        public HurtWhenWet180 MinecraftHurtWhenWet { get; set; }

        [JsonProperty("minecraft:input_ground_controlled", NullValueHandling = NullValueHandling.Ignore)]
        public InputGroundControlled180 MinecraftInputGroundControlled { get; set; }

        [JsonProperty("minecraft:inside_block_notifier", NullValueHandling = NullValueHandling.Ignore)]
        public InsideBlockNotifier180 MinecraftInsideBlockNotifier { get; set; }

        [JsonProperty("minecraft:insomnia", NullValueHandling = NullValueHandling.Ignore)]
        public Insomnia180 MinecraftInsomnia { get; set; }

        [JsonProperty("minecraft:instant_despawn", NullValueHandling = NullValueHandling.Ignore)]
        public InstantDespawn1160 MinecraftInstantDespawn { get; set; }

        [JsonProperty("minecraft:interact", NullValueHandling = NullValueHandling.Ignore)]
        public MinecraftInteractClass MinecraftInteract { get; set; }

        [JsonProperty("minecraft:inventory", NullValueHandling = NullValueHandling.Ignore)]
        public Inventory1160 MinecraftInventory { get; set; }

        [JsonProperty("minecraft:is_baby", NullValueHandling = NullValueHandling.Ignore)]
        public IsBaby180 MinecraftIsBaby { get; set; }

        [JsonProperty("minecraft:is_charged", NullValueHandling = NullValueHandling.Ignore)]
        public IsCharged180 MinecraftIsCharged { get; set; }

        [JsonProperty("minecraft:is_chested", NullValueHandling = NullValueHandling.Ignore)]
        public IsChested180 MinecraftIsChested { get; set; }

        [JsonProperty("minecraft:is_dyeable", NullValueHandling = NullValueHandling.Ignore)]
        public IsDyeable180 MinecraftIsDyeable { get; set; }

        [JsonProperty("minecraft:is_hidden_when_invisible", NullValueHandling = NullValueHandling.Ignore)]
        public IsHiddenWhenInvisible180 MinecraftIsHiddenWhenInvisible { get; set; }

        [JsonProperty("minecraft:is_ignited", NullValueHandling = NullValueHandling.Ignore)]
        public IsIgnited180 MinecraftIsIgnited { get; set; }

        [JsonProperty("minecraft:is_illager_captain", NullValueHandling = NullValueHandling.Ignore)]
        public IsIllagerCaptain180 MinecraftIsIllagerCaptain { get; set; }

        [JsonProperty("minecraft:is_saddled", NullValueHandling = NullValueHandling.Ignore)]
        public IsSaddled180 MinecraftIsSaddled { get; set; }

        [JsonProperty("minecraft:is_shaking", NullValueHandling = NullValueHandling.Ignore)]
        public IsShaking180 MinecraftIsShaking { get; set; }

        [JsonProperty("minecraft:is_sheared", NullValueHandling = NullValueHandling.Ignore)]
        public IsSheared180 MinecraftIsSheared { get; set; }

        [JsonProperty("minecraft:is_stackable", NullValueHandling = NullValueHandling.Ignore)]
        public IsStackable180 MinecraftIsStackable { get; set; }

        [JsonProperty("minecraft:is_stunned", NullValueHandling = NullValueHandling.Ignore)]
        public IsStunned180 MinecraftIsStunned { get; set; }

        [JsonProperty("minecraft:is_tamed", NullValueHandling = NullValueHandling.Ignore)]
        public IsTamed180 MinecraftIsTamed { get; set; }

        [JsonProperty("minecraft:item_controllable", NullValueHandling = NullValueHandling.Ignore)]
        public ItemControllable180 MinecraftItemControllable { get; set; }

        [JsonProperty("minecraft:item_hopper", NullValueHandling = NullValueHandling.Ignore)]
        public ItemHopper180 MinecraftItemHopper { get; set; }

        [JsonProperty("minecraft:jump.dynamic", NullValueHandling = NullValueHandling.Ignore)]
        public JumpDynamic180 MinecraftJumpDynamic { get; set; }

        [JsonProperty("minecraft:jump.static", NullValueHandling = NullValueHandling.Ignore)]
        public JumpStatic180 MinecraftJumpStatic { get; set; }

        [JsonProperty("minecraft:knockback_resistance", NullValueHandling = NullValueHandling.Ignore)]
        public KnockbackResistance180 MinecraftKnockbackResistance { get; set; }

        [JsonProperty("minecraft:lava_movement", NullValueHandling = NullValueHandling.Ignore)]
        public LavaMovement180 MinecraftLavaMovement { get; set; }

        [JsonProperty("minecraft:leashable", NullValueHandling = NullValueHandling.Ignore)]
        public Leashable1160 MinecraftLeashable { get; set; }

        [JsonProperty("minecraft:lookat", NullValueHandling = NullValueHandling.Ignore)]
        public Lookat1160 MinecraftLookat { get; set; }

        [JsonProperty("minecraft:loot", NullValueHandling = NullValueHandling.Ignore)]
        public Loot180 MinecraftLoot { get; set; }

        [JsonProperty("minecraft:managed_wandering_trader", NullValueHandling = NullValueHandling.Ignore)]
        public ManagedWanderingTrader180 MinecraftManagedWanderingTrader { get; set; }

        [JsonProperty("minecraft:mark_variant", NullValueHandling = NullValueHandling.Ignore)]
        public MarkVariant180 MinecraftMarkVariant { get; set; }

        [JsonProperty("minecraft:mob_effect", NullValueHandling = NullValueHandling.Ignore)]
        public MobEffect1160 MinecraftMobEffect { get; set; }

        [JsonProperty("minecraft:movement", NullValueHandling = NullValueHandling.Ignore)]
        public Movement180 MinecraftMovement { get; set; }

        [JsonProperty("minecraft:movement.amphibious", NullValueHandling = NullValueHandling.Ignore)]
        public MovementAmphibious180 MinecraftMovementAmphibious { get; set; }

        [JsonProperty("minecraft:movement.basic", NullValueHandling = NullValueHandling.Ignore)]
        public MovementBasic180 MinecraftMovementBasic { get; set; }

        [JsonProperty("minecraft:movement.fly", NullValueHandling = NullValueHandling.Ignore)]
        public MovementFly180 MinecraftMovementFly { get; set; }

        [JsonProperty("minecraft:movement.generic", NullValueHandling = NullValueHandling.Ignore)]
        public MovementGeneric180 MinecraftMovementGeneric { get; set; }

        [JsonProperty("minecraft:movement.glide", NullValueHandling = NullValueHandling.Ignore)]
        public MovementGlide180 MinecraftMovementGlide { get; set; }

        [JsonProperty("minecraft:movement.hover", NullValueHandling = NullValueHandling.Ignore)]
        public MovementHover1160 MinecraftMovementHover { get; set; }

        [JsonProperty("minecraft:movement.jump", NullValueHandling = NullValueHandling.Ignore)]
        public MovementJump1160 MinecraftMovementJump { get; set; }

        [JsonProperty("minecraft:movement.skip", NullValueHandling = NullValueHandling.Ignore)]
        public MovementSkip180 MinecraftMovementSkip { get; set; }

        [JsonProperty("minecraft:movement.sway", NullValueHandling = NullValueHandling.Ignore)]
        public MovementSway1160 MinecraftMovementSway { get; set; }

        [JsonProperty("minecraft:nameable", NullValueHandling = NullValueHandling.Ignore)]
        public Nameable1160 MinecraftNameable { get; set; }

        [JsonProperty("minecraft:navigation.climb", NullValueHandling = NullValueHandling.Ignore)]
        public NavigationClimb1160 MinecraftNavigationClimb { get; set; }

        [JsonProperty("minecraft:navigation.float", NullValueHandling = NullValueHandling.Ignore)]
        public NavigationFloat1160 MinecraftNavigationFloat { get; set; }

        [JsonProperty("minecraft:navigation.fly", NullValueHandling = NullValueHandling.Ignore)]
        public NavigationFly1160 MinecraftNavigationFly { get; set; }

        [JsonProperty("minecraft:navigation.generic", NullValueHandling = NullValueHandling.Ignore)]
        public NavigationGeneric1160 MinecraftNavigationGeneric { get; set; }

        [JsonProperty("minecraft:navigation.hover", NullValueHandling = NullValueHandling.Ignore)]
        public NavigationHover1160 MinecraftNavigationHover { get; set; }

        [JsonProperty("minecraft:navigation.swim", NullValueHandling = NullValueHandling.Ignore)]
        public NavigationSwim1160 MinecraftNavigationSwim { get; set; }

        [JsonProperty("minecraft:navigation.walk", NullValueHandling = NullValueHandling.Ignore)]
        public NavigationWalk MinecraftNavigationWalk { get; set; }

        [JsonProperty("minecraft:npc", NullValueHandling = NullValueHandling.Ignore)]
        public Npc1160 MinecraftNpc { get; set; }

        [JsonProperty("minecraft:on_death", NullValueHandling = NullValueHandling.Ignore)]
        public OnDeath180 MinecraftOnDeath { get; set; }

        [JsonProperty("minecraft:on_friendly_anger", NullValueHandling = NullValueHandling.Ignore)]
        public OnFriendlyAnger180 MinecraftOnFriendlyAnger { get; set; }

        [JsonProperty("minecraft:on_hurt", NullValueHandling = NullValueHandling.Ignore)]
        public OnHurt180 MinecraftOnHurt { get; set; }

        [JsonProperty("minecraft:on_hurt_by_player", NullValueHandling = NullValueHandling.Ignore)]
        public OnHurtByPlayer180 MinecraftOnHurtByPlayer { get; set; }

        [JsonProperty("minecraft:on_ignite", NullValueHandling = NullValueHandling.Ignore)]
        public OnIgnite180 MinecraftOnIgnite { get; set; }

        [JsonProperty("minecraft:on_start_landing", NullValueHandling = NullValueHandling.Ignore)]
        public OnStartLanding180 MinecraftOnStartLanding { get; set; }

        [JsonProperty("minecraft:on_start_takeoff", NullValueHandling = NullValueHandling.Ignore)]
        public OnStartTakeoff180 MinecraftOnStartTakeoff { get; set; }

        [JsonProperty("minecraft:on_target_acquired", NullValueHandling = NullValueHandling.Ignore)]
        public OnTargetAcquired180 MinecraftOnTargetAcquired { get; set; }

        [JsonProperty("minecraft:on_target_escape", NullValueHandling = NullValueHandling.Ignore)]
        public OnTargetEscape180 MinecraftOnTargetEscape { get; set; }

        [JsonProperty("minecraft:on_wake_with_owner", NullValueHandling = NullValueHandling.Ignore)]
        public OnWakeWithOwner180 MinecraftOnWakeWithOwner { get; set; }

        [JsonProperty("minecraft:out_of_control", NullValueHandling = NullValueHandling.Ignore)]
        public OutOfControl MinecraftOutOfControl { get; set; }

        [JsonProperty("minecraft:peek", NullValueHandling = NullValueHandling.Ignore)]
        public Peek180 MinecraftPeek { get; set; }

        [JsonProperty("minecraft:persistent", NullValueHandling = NullValueHandling.Ignore)]
        public Persistent180 MinecraftPersistent { get; set; }

        [JsonProperty("minecraft:physics", NullValueHandling = NullValueHandling.Ignore)]
        public Physics180 MinecraftPhysics { get; set; }

        [JsonProperty("minecraft:player.exhaustion", NullValueHandling = NullValueHandling.Ignore)]
        public PlayerExhaustion180 MinecraftPlayerExhaustion { get; set; }

        [JsonProperty("minecraft:player.experience", NullValueHandling = NullValueHandling.Ignore)]
        public PlayerExperience180 MinecraftPlayerExperience { get; set; }

        [JsonProperty("minecraft:player.level", NullValueHandling = NullValueHandling.Ignore)]
        public PlayerLevel180 MinecraftPlayerLevel { get; set; }

        [JsonProperty("minecraft:player.saturation", NullValueHandling = NullValueHandling.Ignore)]
        public PlayerSaturation180 MinecraftPlayerSaturation { get; set; }

        [JsonProperty("minecraft:preferred_path", NullValueHandling = NullValueHandling.Ignore)]
        public PreferredPath180 MinecraftPreferredPath { get; set; }

        [JsonProperty("minecraft:projectile", NullValueHandling = NullValueHandling.Ignore)]
        public MinecraftProjectileClass MinecraftProjectile { get; set; }

        [JsonProperty("minecraft:push_through", NullValueHandling = NullValueHandling.Ignore)]
        public PushThrough180 MinecraftPushThrough { get; set; }

        [JsonProperty("minecraft:pushable", NullValueHandling = NullValueHandling.Ignore)]
        public Pushable180 MinecraftPushable { get; set; }

        [JsonProperty("minecraft:raid_trigger", NullValueHandling = NullValueHandling.Ignore)]
        public RaidTrigger180 MinecraftRaidTrigger { get; set; }

        [JsonProperty("minecraft:rail_movement", NullValueHandling = NullValueHandling.Ignore)]
        public RailMovement180 MinecraftRailMovement { get; set; }

        [JsonProperty("minecraft:rail_sensor", NullValueHandling = NullValueHandling.Ignore)]
        public RailSensor180 MinecraftRailSensor { get; set; }

        [JsonProperty("minecraft:ravager_blocked", NullValueHandling = NullValueHandling.Ignore)]
        public RavagerBlocked180 MinecraftRavagerBlocked { get; set; }

        [JsonProperty("minecraft:rideable", NullValueHandling = NullValueHandling.Ignore)]
        public Rideable1160 MinecraftRideable { get; set; }

        [JsonProperty("minecraft:scaffolding_climber", NullValueHandling = NullValueHandling.Ignore)]
        public ScaffoldingClimber180 MinecraftScaffoldingClimber { get; set; }

        [JsonProperty("minecraft:scale", NullValueHandling = NullValueHandling.Ignore)]
        public Scale180 MinecraftScale { get; set; }

        [JsonProperty("minecraft:scale_by_age", NullValueHandling = NullValueHandling.Ignore)]
        public ScaleByAge180 MinecraftScaleByAge { get; set; }

        [JsonProperty("minecraft:scheduler", NullValueHandling = NullValueHandling.Ignore)]
        public Scheduler1160 MinecraftScheduler { get; set; }

        [JsonProperty("minecraft:shareables", NullValueHandling = NullValueHandling.Ignore)]
        public Shareables1160 MinecraftShareables { get; set; }

        [JsonProperty("minecraft:shooter", NullValueHandling = NullValueHandling.Ignore)]
        public Shooter1160 MinecraftShooter { get; set; }

        [JsonProperty("minecraft:sittable", NullValueHandling = NullValueHandling.Ignore)]
        public Sittable180 MinecraftSittable { get; set; }

        [JsonProperty("minecraft:skin_id", NullValueHandling = NullValueHandling.Ignore)]
        public SkinId180 MinecraftSkinId { get; set; }

        [JsonProperty("minecraft:sound_volume", NullValueHandling = NullValueHandling.Ignore)]
        public SoundVolume180 MinecraftSoundVolume { get; set; }

        [JsonProperty("minecraft:spawn_entity", NullValueHandling = NullValueHandling.Ignore)]
        public SpawnEntity1160 MinecraftSpawnEntity { get; set; }

        [JsonProperty("minecraft:spell_effects", NullValueHandling = NullValueHandling.Ignore)]
        public SpellEffects180 MinecraftSpellEffects { get; set; }

        [JsonProperty("minecraft:strength", NullValueHandling = NullValueHandling.Ignore)]
        public Strength1160 MinecraftStrength { get; set; }

        [JsonProperty("minecraft:tameable", NullValueHandling = NullValueHandling.Ignore)]
        public Tameable180 MinecraftTameable { get; set; }

        [JsonProperty("minecraft:tamemount", NullValueHandling = NullValueHandling.Ignore)]
        public Tamemount1160 MinecraftTamemount { get; set; }

        [JsonProperty("minecraft:target_nearby_sensor", NullValueHandling = NullValueHandling.Ignore)]
        public TargetNearbySensor180 MinecraftTargetNearbySensor { get; set; }

        [JsonProperty("minecraft:teleport", NullValueHandling = NullValueHandling.Ignore)]
        public Teleport180 MinecraftTeleport { get; set; }

        [JsonProperty("minecraft:tick_world", NullValueHandling = NullValueHandling.Ignore)]
        public TickWorld180 MinecraftTickWorld { get; set; }

        [JsonProperty("minecraft:timer", NullValueHandling = NullValueHandling.Ignore)]
        public Timer180 MinecraftTimer { get; set; }

        [JsonProperty("minecraft:trade_resupply", NullValueHandling = NullValueHandling.Ignore)]
        public TradeResupply1160 MinecraftTradeResupply { get; set; }

        [JsonProperty("minecraft:trade_table", NullValueHandling = NullValueHandling.Ignore)]
        public TradeTable180 MinecraftTradeTable { get; set; }

        [JsonProperty("minecraft:trail", NullValueHandling = NullValueHandling.Ignore)]
        public Trail1160 MinecraftTrail { get; set; }

        [JsonProperty("minecraft:transformation", NullValueHandling = NullValueHandling.Ignore)]
        public Transformation1160 MinecraftTransformation { get; set; }

        [JsonProperty("minecraft:trust", NullValueHandling = NullValueHandling.Ignore)]
        public Trust180 MinecraftTrust { get; set; }

        [JsonProperty("minecraft:trusting", NullValueHandling = NullValueHandling.Ignore)]
        public Trusting180 MinecraftTrusting { get; set; }

        [JsonProperty("minecraft:type_family", NullValueHandling = NullValueHandling.Ignore)]
        public TypeFamily180 MinecraftTypeFamily { get; set; }

        [JsonProperty("minecraft:underwater_movement", NullValueHandling = NullValueHandling.Ignore)]
        public UnderwaterMovement180 MinecraftUnderwaterMovement { get; set; }

        [JsonProperty("minecraft:variant", NullValueHandling = NullValueHandling.Ignore)]
        public Variant180 MinecraftVariant { get; set; }

        [JsonProperty("minecraft:walk_animation_speed", NullValueHandling = NullValueHandling.Ignore)]
        public WalkAnimationSpeed180 MinecraftWalkAnimationSpeed { get; set; }

        [JsonProperty("minecraft:wants_jockey", NullValueHandling = NullValueHandling.Ignore)]
        public WantsJockey1160 MinecraftWantsJockey { get; set; }

        [JsonProperty("minecraft:water_movement", NullValueHandling = NullValueHandling.Ignore)]
        public WaterMovement180 MinecraftWaterMovement { get; set; }
    }

    /// <summary>
    /// Adds a rider to the entity. Requires minecraft:rideable.
    /// </summary>
    public partial class Addrider180
    {
        /// <summary>
        /// The entity type that will be riding this entity
        /// </summary>
        [JsonProperty("entity_type")]
        public string EntityType { get; set; }

        /// <summary>
        /// The spawn event that will be used when the riding entity is created
        /// </summary>
        [JsonProperty("spawn_event", NullValueHandling = NullValueHandling.Ignore)]
        public string SpawnEvent { get; set; }
    }

    /// <summary>
    /// Causes the mob to ignore attackable targets for a given duration.
    /// </summary>
    public partial class AdmireItem1160
    {
        /// <summary>
        /// Duration, in seconds, for which mob won't admire items if it was hurt
        /// </summary>
        [JsonProperty("cooldown_after_being_attacked", NullValueHandling = NullValueHandling.Ignore)]
        public long? CooldownAfterBeingAttacked { get; set; } = 0;

        /// <summary>
        /// Duration, in seconds, that the mob is pacified.
        /// </summary>
        [JsonProperty("duration", NullValueHandling = NullValueHandling.Ignore)]
        public long? Duration { get; set; } = 10;
    }

    /// <summary>
    /// Adds a timer for the entity to grow up. It can be accelerated by giving the entity the
    /// items it likes as defined by feedItems.
    /// </summary>
    public partial class Ageable1160
    {
        /// <summary>
        /// List of items that the entity drops when it grows up.
        /// </summary>
        [JsonProperty("drop_items", NullValueHandling = NullValueHandling.Ignore)]
        public Items? DropItems { get; set; }

        /// <summary>
        /// Amount of time before the entity grows up, -1 for always a baby.
        /// </summary>
        [JsonProperty("duration", NullValueHandling = NullValueHandling.Ignore)]
        public double? Duration { get; set; } = 1200;

        /// <summary>
        /// List of items that can be fed to the entity. Includes 'item' for the item name and
        /// 'growth' to define how much time it grows up by
        /// </summary>
        [JsonProperty("feed_items", NullValueHandling = NullValueHandling.Ignore)]
        public FeedableItems? FeedItems { get; set; }

        /// <summary>
        /// Event to run when this entity grows up.
        /// </summary>
        [JsonProperty("grow_up", NullValueHandling = NullValueHandling.Ignore)]
        public Event? GrowUp { get; set; }
    }

    public partial class FeedableItemClass
    {
        [JsonProperty("growth", NullValueHandling = NullValueHandling.Ignore)]
        public double? Growth { get; set; }

        [JsonProperty("item", NullValueHandling = NullValueHandling.Ignore)]
        public string Item { get; set; }
    }

    public partial class BuiltInEvent
    {
        /// <summary>
        /// The event to fire
        /// </summary>
        [JsonProperty("event", NullValueHandling = NullValueHandling.Ignore)]
        public string Event { get; set; }

        /// <summary>
        /// The target of the event
        /// </summary>
        [JsonProperty("target", NullValueHandling = NullValueHandling.Ignore)]
        public Target? Target { get; set; }
    }

    /// <summary>
    /// Sets the entity's delay between playing its ambient sound.
    /// </summary>
    public partial class AmbientSoundInterval1160
    {
        /// <summary>
        /// Level sound event to be played as the ambient sound.
        /// </summary>
        [JsonProperty("event_name", NullValueHandling = NullValueHandling.Ignore)]
        public string EventName { get; set; } = "ambient";

        /// <summary>
        /// Maximum time in seconds to randomly add to the ambient sound delay time.
        /// </summary>
        [JsonProperty("range", NullValueHandling = NullValueHandling.Ignore)]
        public double? Range { get; set; } = 16;

        /// <summary>
        /// Minimum time in seconds before the entity plays its ambient sound again
        /// </summary>
        [JsonProperty("value", NullValueHandling = NullValueHandling.Ignore)]
        public double? Value { get; set; } = 8;
    }

    /// <summary>
    /// Adds a timer for the entity to grow up. It can be accelerated by giving the entity the
    /// items it likes as defined by feedItems.
    /// </summary>
    public partial class Angry1160
    {
        /// <summary>
        /// The sound event to play when the mob is angry
        /// </summary>
        [JsonProperty("angry_sound", NullValueHandling = NullValueHandling.Ignore)]
        public string AngrySound { get; set; } = "";

        /// <summary>
        /// If true, other entities of the same entity definition within the broadcastRange will also
        /// become angry
        /// </summary>
        [JsonProperty("broadcast_anger", NullValueHandling = NullValueHandling.Ignore)]
        public bool? BroadcastAnger { get; set; } = new bool?();

        /// <summary>
        /// If true, other entities of the same entity definition within the broadcastRange will also
        /// become angry whenever this mob attacks
        /// </summary>
        [JsonProperty("broadcast_anger_on_attack", NullValueHandling = NullValueHandling.Ignore)]
        public bool? BroadcastAngerOnAttack { get; set; } = new bool?();

        /// <summary>
        /// If true, other entities of the same entity definition within the broadcastRange will also
        /// become angry whenever this mob is attacked
        /// </summary>
        [JsonProperty("broadcast_anger_on_being_attacked", NullValueHandling = NullValueHandling.Ignore)]
        public bool? BroadcastAngerOnBeingAttacked { get; set; } = new bool?();

        /// <summary>
        /// Conditions that make this entry in the list valid
        /// </summary>
        [JsonProperty("broadcast_filters", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject BroadcastFilters { get; set; }

        /// <summary>
        /// Distance in blocks within which other entities of the same entity definition will become
        /// angry
        /// </summary>
        [JsonProperty("broadcast_range", NullValueHandling = NullValueHandling.Ignore)]
        public long? BroadcastRange { get; set; } = 20;

        /// <summary>
        /// A list of entity families to broadcast anger to
        /// </summary>
        [JsonProperty("broadcast_targets", NullValueHandling = NullValueHandling.Ignore)]
        public List<string> BroadcastTargets { get; set; }

        /// <summary>
        /// Event to run after the number of seconds specified in duration expires (when the entity
        /// stops being 'angry')
        /// </summary>
        [JsonProperty("calm_event", NullValueHandling = NullValueHandling.Ignore)]
        public Event? CalmEvent { get; set; }

        /// <summary>
        /// The amount of time in seconds that the entity will be angry
        /// </summary>
        [JsonProperty("duration", NullValueHandling = NullValueHandling.Ignore)]
        public long? Duration { get; set; } = 25;

        /// <summary>
        /// Variance in seconds added to the duration [-delta, delta]
        /// </summary>
        [JsonProperty("duration_delta", NullValueHandling = NullValueHandling.Ignore)]
        public long? DurationDelta { get; set; } = 0;

        /// <summary>
        /// Filter out mob types that it should not attack while angry (other Piglins)
        /// </summary>
        [JsonProperty("filters", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject Filters { get; set; }

        /// <summary>
        /// The range of time in seconds to randomly wait before playing the sound again
        /// </summary>
        [JsonProperty("sound_interval", NullValueHandling = NullValueHandling.Ignore)]
        public SoundInterval? SoundInterval { get; set; }
    }

    /// <summary>
    /// Conditions that make this entry in the list valid
    ///
    /// Filter out mob types that it should not attack while angry (other Piglins)
    ///
    /// Entity_filter
    ///
    /// The filters to check to determine if the event should be fired
    ///
    /// The filters to use when determining if this potion can be selected.
    ///
    /// UNDOCUMENTATED
    ///
    /// Filter to determine the conditions for this mob to look at the entity
    ///
    /// Conditions that make this target a valid type.
    ///
    /// The filters to run when attempting to fall in love.
    ///
    /// The list of conditions that target of hunt must satisfy to initiate celebration.
    ///
    /// The list of conditions that must be satisfied before the Actor is despawned. If a filter
    /// is defined then standard despawn rules are ignored.
    ///
    /// The list of conditions that must be satisfied for other entities to be counted towards
    /// group size.
    ///
    /// The filter group that defines the conditions for this trigger
    ///
    /// The filter group that defines the conditions for using this item to heal the entity
    ///
    /// Defines the entities that can trigger this component
    ///
    /// TODO
    ///
    /// The list of conditions for this trigger
    ///
    /// If present, the specified entity will only spawn if the filter evaluates to true
    ///
    /// One or more conditions that must be met in order to cause the chosen block type to spawn.
    /// </summary>
    public partial class CustomFilterObject
    {
        [JsonProperty("default_cowlib_filter")]
        public object DefaultCowlibFilter { get; set; }
    }

    public partial class Range
    {
        [JsonProperty("range_max", NullValueHandling = NullValueHandling.Ignore)]
        public double? RangeMax { get; set; }

        [JsonProperty("range_min", NullValueHandling = NullValueHandling.Ignore)]
        public double? RangeMin { get; set; }
    }

    /// <summary>
    /// Allows the actor to break doors assuming that that flags set up for the component to use
    /// in navigation
    /// </summary>
    public partial class AnnotationBreakDoor180
    {
        /// <summary>
        /// The time in seconds required to break through doors.
        /// </summary>
        [JsonProperty("break_time", NullValueHandling = NullValueHandling.Ignore)]
        public double? BreakTime { get; set; } = 12;

        /// <summary>
        /// The minimum difficulty that the world must be on for this entity to break doors.
        /// </summary>
        [JsonProperty("min_difficulty", NullValueHandling = NullValueHandling.Ignore)]
        public string MinDifficulty { get; set; } = "hard";
    }

    /// <summary>
    /// Allows the actor to open doors assuming that that flags set up for the component to use
    /// in navigation
    /// </summary>
    public partial class AnnotationOpenDoor180
    {
    }

    /// <summary>
    /// A component that does damage to entities that get within range.
    /// </summary>
    public partial class AreaAttack1160
    {
        /// <summary>
        /// TODO
        /// </summary>
        [JsonProperty("cause", NullValueHandling = NullValueHandling.Ignore)]
        public MinecraftAreaAttackCause? Cause { get; set; }

        /// <summary>
        /// How much damage per tick is applied to entities that enter the damage range.
        /// </summary>
        [JsonProperty("damage_per_tick", NullValueHandling = NullValueHandling.Ignore)]
        public long? DamagePerTick { get; set; } = 2;

        /// <summary>
        /// How close a hostile entity must be to have the damage applied.
        /// </summary>
        [JsonProperty("damage_range", NullValueHandling = NullValueHandling.Ignore)]
        public double? DamageRange { get; set; } = 0.2;

        /// <summary>
        /// Entity_filter
        /// </summary>
        [JsonProperty("entity_filter", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject EntityFilter { get; set; }
    }

    /// <summary>
    /// Defines an entity's melee attack and any additional effects on it.
    /// </summary>
    public partial class Attack180
    {
        /// <summary>
        /// Range of the random amount of damage the melee attack deals. A negative value can heal
        /// the entity instead of hurting it
        /// </summary>
        [JsonProperty("damage")]
        public List<double> Damage { get; set; }

        /// <summary>
        /// Duration in seconds of the status ailment applied to the damaged entity
        /// </summary>
        [JsonProperty("effect_duration", NullValueHandling = NullValueHandling.Ignore)]
        public double? EffectDuration { get; set; }

        /// <summary>
        /// Identifier of the status ailment to apply to an entity attacked by this entity's melee
        /// attack
        /// </summary>
        [JsonProperty("effect_name", NullValueHandling = NullValueHandling.Ignore)]
        public string EffectName { get; set; }
    }

    /// <summary>
    /// Adds a cooldown to a mob. The intention of this cooldown is to be used to prevent the mob
    /// from attempting to aquire new attack targets.
    /// </summary>
    public partial class AttackCooldown1160
    {
        /// <summary>
        /// Event to be runned when the cooldown is complete.
        /// </summary>
        [JsonProperty("attack_cooldown_complete_event", NullValueHandling = NullValueHandling.Ignore)]
        public Trigger AttackCooldownCompleteEvent { get; set; }

        /// <summary>
        /// Amount of time in seconds for the cooldown. Can be specified as a number or a pair of
        /// numbers (min and max).
        /// </summary>
        [JsonProperty("attack_cooldown_time", NullValueHandling = NullValueHandling.Ignore)]
        public AttackCooldownTime? AttackCooldownTime { get; set; } = new List<double> {0.0,1.0};
    }

    /// <summary>
    /// Event to be runned when the cooldown is complete.
    ///
    /// Trigger to fire for 1.16.0
    ///
    /// The event to trigger when the goal's duration expires.
    ///
    /// On_roar_end
    ///
    /// Event to fire when the interaction occurs.
    ///
    /// Trigger to run when the entity gets named
    /// </summary>
    public partial class Trigger
    {
        /// <summary>
        /// Event
        /// </summary>
        [JsonProperty("event", NullValueHandling = NullValueHandling.Ignore)]
        public string Event { get; set; }

        /// <summary>
        /// The filters to check to determine if the event should be fired
        /// </summary>
        [JsonProperty("filters", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject Filters { get; set; }

        /// <summary>
        /// The entity to target
        /// </summary>
        [JsonProperty("target", NullValueHandling = NullValueHandling.Ignore)]
        public Subject1160? Target { get; set; }
    }

    /// <summary>
    /// TODO description:
    /// </summary>
    public partial class AttackDamage180
    {
        /// <summary>
        /// TODO description: value
        /// </summary>
        [JsonProperty("value")]
        public double Value { get; set; }
    }

    /// <summary>
    /// TODO description:
    /// </summary>
    public partial class Balloonable180
    {
        /// <summary>
        /// TODO description: mass
        /// </summary>
        [JsonProperty("mass", NullValueHandling = NullValueHandling.Ignore)]
        public double? Mass { get; set; }
    }

    /// <summary>
    /// Enables the component to drop an item as a barter exchange.
    /// </summary>
    public partial class Barter1160
    {
        /// <summary>
        /// Loot table that's used to drop a random item.
        /// </summary>
        [JsonProperty("barter_table", NullValueHandling = NullValueHandling.Ignore)]
        public string BarterTable { get; set; }

        /// <summary>
        /// Duration, in seconds, for which mob won't barter items if it was hurt
        /// </summary>
        [JsonProperty("cooldown_after_being_attacked", NullValueHandling = NullValueHandling.Ignore)]
        public long? CooldownAfterBeingAttacked { get; set; } = 0;
    }

    /// <summary>
    /// Enables the mob to admire items that have been configured as admirable. Must be used in
    /// combination with the admire_item component.
    /// </summary>
    public partial class BehaviourAdmireItem1160
    {
        /// <summary>
        /// The sound event to play when admiring the item
        /// </summary>
        [JsonProperty("admire_item_sound", NullValueHandling = NullValueHandling.Ignore)]
        public string AdmireItemSound { get; set; } = "";

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("on_admire_item_start", NullValueHandling = NullValueHandling.Ignore)]
        public Event? OnAdmireItemStart { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("on_admire_item_stop", NullValueHandling = NullValueHandling.Ignore)]
        public Event? OnAdmireItemStop { get; set; }

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// The range of time in seconds to randomly wait before playing the sound again.
        /// </summary>
        [JsonProperty("sound_interval", NullValueHandling = NullValueHandling.Ignore)]
        public SoundIntervalUnion? SoundInterval { get; set; } = 0;
    }

    /// <summary>
    /// UNDOCUMENTATED
    /// </summary>
    public partial class BehaviourAvoidBlock1160
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("avoid_block_sound", NullValueHandling = NullValueHandling.Ignore)]
        public string AvoidBlockSound { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("on_escape", NullValueHandling = NullValueHandling.Ignore)]
        public List<Event> OnEscape { get; set; }

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("search_height", NullValueHandling = NullValueHandling.Ignore)]
        public long? SearchHeight { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("search_range", NullValueHandling = NullValueHandling.Ignore)]
        public long? SearchRange { get; set; }

        /// <summary>
        /// The range of time in seconds to randomly wait before playing the sound again.
        /// </summary>
        [JsonProperty("sound_interval", NullValueHandling = NullValueHandling.Ignore)]
        public SoundIntervalUnion? SoundInterval { get; set; } = 0;

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("sprint_speed_modifier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SprintSpeedModifier { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("target_blocks", NullValueHandling = NullValueHandling.Ignore)]
        public List<string> TargetBlocks { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("target_selection_method", NullValueHandling = NullValueHandling.Ignore)]
        public string TargetSelectionMethod { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("tick_interval", NullValueHandling = NullValueHandling.Ignore)]
        public long? TickInterval { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("walk_speed_modifier", NullValueHandling = NullValueHandling.Ignore)]
        public double? WalkSpeedModifier { get; set; }
    }

    /// <summary>
    /// Allows this entity to avoid certain mob types.
    /// </summary>
    public partial class BehaviorAvoidMobType180
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("avoid_mob_sound", NullValueHandling = NullValueHandling.Ignore)]
        public string AvoidMobSound { get; set; }

        /// <summary>
        /// TODO description: entity types
        /// </summary>
        [JsonProperty("entity_types", NullValueHandling = NullValueHandling.Ignore)]
        public EntityTypes180? EntityTypes { get; set; }

        /// <summary>
        /// If true, visbility between this entity and the mob type will not be checked.
        /// </summary>
        [JsonProperty("ignore_visibility", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IgnoreVisibility { get; set; } = new bool?();

        /// <summary>
        /// Maximum distance to look for an entity
        /// </summary>
        [JsonProperty("max_dist", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaxDist { get; set; } = 0;

        /// <summary>
        /// Distance in blocks within the mob considers it should stop fleeing.
        /// </summary>
        [JsonProperty("max_flee", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaxFlee { get; set; } = 0.5;

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("on_escape_event", NullValueHandling = NullValueHandling.Ignore)]
        public Event? OnEscapeEvent { get; set; }

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// Determines how likely it is that this entity will stop avoiding another entity based on
        /// that entity's strength
        /// </summary>
        [JsonProperty("probability_per_strength", NullValueHandling = NullValueHandling.Ignore)]
        public double? ProbabilityPerStrength { get; set; } = 1;

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("remove_target", NullValueHandling = NullValueHandling.Ignore)]
        public bool? RemoveTarget { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("sound_interval", NullValueHandling = NullValueHandling.Ignore)]
        public SoundIntervalUnion? SoundInterval { get; set; } = 0;

        /// <summary>
        /// Multiplier for running speed. 1.0 means keep the regular speed, while higher numbers make
        /// the running speed faster
        /// </summary>
        [JsonProperty("sprint_speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SprintSpeedMultiplier { get; set; } = 1;

        /// <summary>
        /// Multiplier for walking speed. 1.0 means keep the regular speed, while higher numbers make
        /// the walking speed faster
        /// </summary>
        [JsonProperty("walk_speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? WalkSpeedMultiplier { get; set; } = 1;
    }

    /// <summary>
    /// The entity type
    /// </summary>
    public partial class TheEntityType
    {
        [JsonProperty("filters", NullValueHandling = NullValueHandling.Ignore)]
        public TheEntityTypeFilters Filters { get; set; }

        /// <summary>
        /// Maximum distance this mob can be away to be a valid choice
        /// </summary>
        [JsonProperty("max_dist", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaxDist { get; set; } = 16;

        /// <summary>
        /// If true, the mob has to be visible to be a valid choice
        /// </summary>
        [JsonProperty("must_see", NullValueHandling = NullValueHandling.Ignore)]
        public bool? MustSee { get; set; } = new bool?();

        /// <summary>
        /// Determines the amount of time in seconds that this mob will look for a target before
        /// forgetting about it and looking for a new one when the target isn't visible any more
        /// </summary>
        [JsonProperty("must_see_forget_duration", NullValueHandling = NullValueHandling.Ignore)]
        public double? MustSeeForgetDuration { get; set; }

        /// <summary>
        /// Multiplier for the running speed. A value of 1.0 means the speed is unchanged
        /// </summary>
        [JsonProperty("sprint_speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SprintSpeedMultiplier { get; set; } = 16;

        /// <summary>
        /// Multiplier for the walking speed. A value of 1.0 means the speed is unchanged
        /// </summary>
        [JsonProperty("walk_speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? WalkSpeedMultiplier { get; set; } = 16;
    }

    /// <summary>
    /// Conditions that make this entry in the list valid
    ///
    /// Filter out mob types that it should not attack while angry (other Piglins)
    ///
    /// Entity_filter
    ///
    /// The filters to check to determine if the event should be fired
    ///
    /// The filters to use when determining if this potion can be selected.
    ///
    /// UNDOCUMENTATED
    ///
    /// Filter to determine the conditions for this mob to look at the entity
    ///
    /// Conditions that make this target a valid type.
    ///
    /// The filters to run when attempting to fall in love.
    ///
    /// The list of conditions that target of hunt must satisfy to initiate celebration.
    ///
    /// The list of conditions that must be satisfied before the Actor is despawned. If a filter
    /// is defined then standard despawn rules are ignored.
    ///
    /// The list of conditions that must be satisfied for other entities to be counted towards
    /// group size.
    ///
    /// The filter group that defines the conditions for this trigger
    ///
    /// The filter group that defines the conditions for using this item to heal the entity
    ///
    /// Defines the entities that can trigger this component
    ///
    /// TODO
    ///
    /// The list of conditions for this trigger
    ///
    /// If present, the specified entity will only spawn if the filter evaluates to true
    ///
    /// One or more conditions that must be met in order to cause the chosen block type to spawn.
    /// </summary>
    public partial class TheEntityTypeFilters
    {
        [JsonProperty("default_cowlib_filter")]
        public object DefaultCowlibFilter { get; set; }
    }

    /// <summary>
    /// Enables the mob to barter for items that have been configured as barter currency. Must be
    /// used in combination with the barter component
    /// </summary>
    public partial class BehaviourBarter1160
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Allows this mob to look at and follow the player that holds food they like.
    /// </summary>
    public partial class BehaviorBeg180
    {
        /// <summary>
        /// List of items that this mob likes
        /// </summary>
        [JsonProperty("items", NullValueHandling = NullValueHandling.Ignore)]
        public List<string> Items { get; set; }

        /// <summary>
        /// Distance in blocks the mob will beg from
        /// </summary>
        [JsonProperty("look_distance", NullValueHandling = NullValueHandling.Ignore)]
        public double? LookDistance { get; set; } = 8;

        /// <summary>
        /// The range of time in seconds this mob will stare at the player holding a food they like,
        /// begging for it
        /// </summary>
        [JsonProperty("look_time", NullValueHandling = NullValueHandling.Ignore)]
        public List<double> LookTime { get; set; } = new List<double> {2.0,4.0};

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Allows this mob to break doors.
    /// </summary>
    public partial class BehaviorBreakDoor180
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }
    }

    /// <summary>
    /// Allows this mob to breed with other mobs.
    /// </summary>
    public partial class BehaviorBreed180
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }
    }

    /// <summary>
    /// This allows the mob celebrate by jumping up and playing a sound periodically.
    /// </summary>
    public partial class BehaviourCelebrate1160
    {
        /// <summary>
        /// The sound to occasionally play.
        /// </summary>
        [JsonProperty("celebration_sound", NullValueHandling = NullValueHandling.Ignore)]
        public string CelebrationSound { get; set; } = "";

        /// <summary>
        /// The duration of the celebration (in seconds).
        /// </summary>
        [JsonProperty("duration", NullValueHandling = NullValueHandling.Ignore)]
        public double? Duration { get; set; } = 1;

        /// <summary>
        /// The range of time in seconds to randomly wait before jumping again.
        /// </summary>
        [JsonProperty("jump_interval", NullValueHandling = NullValueHandling.Ignore)]
        public SoundIntervalUnion? JumpInterval { get; set; } = 0;

        /// <summary>
        /// The event to trigger when the goal's duration expires.
        /// </summary>
        [JsonProperty("on_celebration_end_event", NullValueHandling = NullValueHandling.Ignore)]
        public Trigger OnCelebrationEndEvent { get; set; }

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// The range of time in seconds to randomly wait before playing the sound again.
        /// </summary>
        [JsonProperty("sound_interval", NullValueHandling = NullValueHandling.Ignore)]
        public SoundIntervalUnion? SoundInterval { get; set; } = 0;
    }

    /// <summary>
    /// Allows the mob to attack its target by running at it.
    /// </summary>
    public partial class BehaviorChargeAttack180
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }
    }

    /// <summary>
    /// Allows this mob to charge and use their held item.
    /// </summary>
    public partial class BehaviorChargeHeldItem180
    {
        /// <summary>
        /// The list of items that can be used to charge the held item.
        /// </summary>
        [JsonProperty("items", NullValueHandling = NullValueHandling.Ignore)]
        public List<string> Items { get; set; }

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Allows the mob to move in a circle around a point or a target.
    /// </summary>
    public partial class BehaviorCircleAroundAnchor180
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("angle_change", NullValueHandling = NullValueHandling.Ignore)]
        public double? AngleChange { get; set; }

        /// <summary>
        /// Distance in blocks within the mob considers it has reached the goal. This is the "wiggle
        /// room" to stop the AI from bouncing back and forth trying to reach a specific spot
        /// </summary>
        [JsonProperty("goal_radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? GoalRadius { get; set; } = 0.5;

        /// <summary>
        /// When the mob finds a target, the range of height in blocks above the target to start the
        /// anchor point.
        /// </summary>
        [JsonProperty("height_above_target_range", NullValueHandling = NullValueHandling.Ignore)]
        public List<double> HeightAboveTargetRange { get; set; } = new List<double> {0.0,0.0};

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("height_adjustment_chance", NullValueHandling = NullValueHandling.Ignore)]
        public double? HeightAdjustmentChance { get; set; }

        /// <summary>
        /// A random value to determine when to change the height of the mob from the anchor point.
        /// This has a 1/value chance every tick to do so.
        /// </summary>
        [JsonProperty("height_change_chance", NullValueHandling = NullValueHandling.Ignore)]
        public long? HeightChangeChance { get; set; } = 350;

        /// <summary>
        /// The range of height in blocks offset the mob can have from it's anchor point.
        /// </summary>
        [JsonProperty("height_offset_range", NullValueHandling = NullValueHandling.Ignore)]
        public List<double> HeightOffsetRange { get; set; } = new List<double> {0.0,0.0};

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("radius_adjustment_chance", NullValueHandling = NullValueHandling.Ignore)]
        public double? RadiusAdjustmentChance { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("radius_change", NullValueHandling = NullValueHandling.Ignore)]
        public double? RadiusChange { get; set; }

        /// <summary>
        /// A random value to determine when to increase the size of the radius up to the maximum.
        /// This has a 1/value chance every tick to do so.
        /// </summary>
        [JsonProperty("radius_change_chance", NullValueHandling = NullValueHandling.Ignore)]
        public long? RadiusChangeChance { get; set; } = 250;

        /// <summary>
        /// Range of radius in blocks of the circle to move around.
        /// </summary>
        [JsonProperty("radius_range", NullValueHandling = NullValueHandling.Ignore)]
        public List<double> RadiusRange { get; set; } = new List<double> {5.0,15.0};

        /// <summary>
        /// Movement speed multiplier of the mob when using this AI Goal
        /// </summary>
        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; } = 1;
    }

    /// <summary>
    /// Allows the mob to be controlled by the player.
    /// </summary>
    public partial class BehaviorControlledByPlayer180
    {
        /// <summary>
        /// Speed multiplier of mount when controlled by player, defaults to 1.0f
        /// </summary>
        [JsonProperty("mount_speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? MountSpeedMultiplier { get; set; } = 1;

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Allows the mob to target another mob that hurts an entity it trusts.
    /// </summary>
    public partial class BehaviourDefendTrustedTarget1160
    {
        /// <summary>
        /// Sound to occasionally play while defending.
        /// </summary>
        [JsonProperty("aggro_sound", NullValueHandling = NullValueHandling.Ignore)]
        public string AggroSound { get; set; } = "";

        /// <summary>
        /// Time in seconds between attacks
        /// </summary>
        [JsonProperty("attack_interval", NullValueHandling = NullValueHandling.Ignore)]
        public long? AttackInterval { get; set; } = 0;

        /// <summary>
        /// List of entity types that this mob considers valid targets
        /// </summary>
        [JsonProperty("entity_types", NullValueHandling = NullValueHandling.Ignore)]
        public EntityTypesClass EntityTypes { get; set; }

        /// <summary>
        /// If true, only entities in this mob's viewing range can be selected as targets
        /// </summary>
        [JsonProperty("must_see", NullValueHandling = NullValueHandling.Ignore)]
        public bool? MustSee { get; set; } = new bool?();

        /// <summary>
        /// Determines the amount of time in seconds that this mob will look for a target before
        /// forgetting about it and looking for a new one when the target isn't visible any more
        /// </summary>
        [JsonProperty("must_see_forget_duration", NullValueHandling = NullValueHandling.Ignore)]
        public double? MustSeeForgetDuration { get; set; } = 3;

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("on_defend_start", NullValueHandling = NullValueHandling.Ignore)]
        public Event? OnDefendStart { get; set; }

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("sound_chance", NullValueHandling = NullValueHandling.Ignore)]
        public double? SoundChance { get; set; }

        /// <summary>
        /// Distance in blocks that the target can be within to launch an attack
        /// </summary>
        [JsonProperty("within_radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? WithinRadius { get; set; } = 0;
    }

    /// <summary>
    /// List of entity types that this mob considers valid targets
    /// </summary>
    public partial class EntityTypesClass
    {
    }

    /// <summary>
    /// Allows the mob to stay in the village and fight mobs hostile to the villagers.
    /// </summary>
    public partial class BehaviorDefendVillageTarget180
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("attack_chance", NullValueHandling = NullValueHandling.Ignore)]
        public double? AttackChance { get; set; }

        /// <summary>
        /// List of entity types this mob considers a threat to the village
        /// </summary>
        [JsonProperty("entity_types", NullValueHandling = NullValueHandling.Ignore)]
        public EntityTypes180? EntityTypes { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("must_reach", NullValueHandling = NullValueHandling.Ignore)]
        public bool? MustReach { get; set; }

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Allows the mob to drink potions based on specified environment conditions.
    /// </summary>
    public partial class BehaviorDelayedAttack180
    {
        /// <summary>
        /// The duration of the attack animation in seconds
        /// </summary>
        [JsonProperty("attack_duration", NullValueHandling = NullValueHandling.Ignore)]
        public double? AttackDuration { get; set; } = 1;

        /// <summary>
        /// If true, this mob will attack only one time.
        /// </summary>
        [JsonProperty("attack_once", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AttackOnce { get; set; } = new bool?();

        /// <summary>
        /// Defines the entity types this mob will attack
        /// </summary>
        [JsonProperty("attack_types", NullValueHandling = NullValueHandling.Ignore)]
        public string AttackTypes { get; set; } = "";

        /// <summary>
        /// The percentage of the attack_duration that must pass before the hit is made
        /// </summary>
        [JsonProperty("hit_delay_pct", NullValueHandling = NullValueHandling.Ignore)]
        public double? HitDelayPct { get; set; } = 1;

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// Defines the probability the mob will stop fighting. A value of 0 disables randomly
        /// stopping, while a value of 1 defines a 50% chance
        /// </summary>
        [JsonProperty("random_stop_interval", NullValueHandling = NullValueHandling.Ignore)]
        public long? RandomStopInterval { get; set; } = 0;

        /// <summary>
        /// Multiplier for how far outside its box the mob can reach its target (this can be used to
        /// simulate a mob with longer arms by making this bigger)
        /// </summary>
        [JsonProperty("reach_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? ReachMultiplier { get; set; } = 2;

        /// <summary>
        /// UNDOCUMENATED
        /// </summary>
        [JsonProperty("require_complete_path", NullValueHandling = NullValueHandling.Ignore)]
        public bool? RequireCompletePath { get; set; }

        /// <summary>
        /// The sound event to play when the attack starts
        /// </summary>
        [JsonProperty("sound_event", NullValueHandling = NullValueHandling.Ignore)]
        public string SoundEvent { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }

        /// <summary>
        /// If true, this mob will chase after the target as long as it's a valid target
        /// </summary>
        [JsonProperty("track_target", NullValueHandling = NullValueHandling.Ignore)]
        public bool? TrackTarget { get; set; } = new bool?();
    }

    /// <summary>
    /// Allows the mob to drink potions based on specified environment conditions.
    /// </summary>
    public partial class BehaviorDoorInteract180
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Allows the dragon to attack a player by flying fast at them. The player is chosen by the
    /// dragonscanning goal. Can only be used by the Ender Dragon.
    /// </summary>
    public partial class BehaviorDragonchargeplayer180
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Allows the dragon to go out with glory. This controls the Ender Dragon's death animation
    /// and can't be used by other mobs.
    /// </summary>
    public partial class BehaviorDragondeath180
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Allows the dragon to use its flame breath attack. Can only be used by the Ender Dragon.
    /// </summary>
    public partial class BehaviorDragonflaming180
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Allows the Dragon to fly around in a circle around the center podium. Can only be used by
    /// the Ender Dragon.
    /// </summary>
    public partial class BehaviorDragonholdingpattern180
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Allows the Dragon to stop flying and transition into perching mode. Can only be used by
    /// the Ender Dragon.
    /// </summary>
    public partial class BehaviorDragonlanding180
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Allows the dragon to look around for a player to attack while in perch mode. Can only be
    /// used by the Ender Dragon.
    /// </summary>
    public partial class BehaviorDragonscanning180
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Allows the dragon to fly around looking for a player and shoot fireballs at them. Can
    /// only be used by the Ender Dragon.
    /// </summary>
    public partial class BehaviorDragonstrafeplayer180
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Allows the dragon to leave perch mode and go back to flying around. Can only be used by
    /// the Ender Dragon.
    /// </summary>
    public partial class BehaviorDragontakeoff180
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Allows the mob to drink potions based on specified environment conditions.
    /// </summary>
    public partial class BehaviorBeg1160
    {
        /// <summary>
        /// A list of potions that this entity can drink.
        /// </summary>
        [JsonProperty("potions", NullValueHandling = NullValueHandling.Ignore)]
        public List<Potion> Potions { get; set; }

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// TODO description: speed modifier
        /// </summary>
        [JsonProperty("speed_modifier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedModifier { get; set; } = 0;

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }
    }

    /// <summary>
    /// TODO description: potions
    /// </summary>
    public partial class Potion
    {
        /// <summary>
        /// The percent chance (from 0.0 to 1.0) of this potion being selected when searching for a
        /// potion to use.
        /// </summary>
        [JsonProperty("chance")]
        [JsonConverter(typeof(PurpleMinMaxValueCheckConverter))]
        public double Chance { get; set; } = 1;

        /// <summary>
        /// The filters to use when determining if this potion can be selected.
        /// </summary>
        [JsonProperty("filters")]
        public CustomFilterObject Filters { get; set; }

        /// <summary>
        /// The registry ID of the potion to use
        /// </summary>
        [JsonProperty("id")]
        public long Id { get; set; } = -1;
    }

    /// <summary>
    /// Allows the mob to move near a target and drop an item.
    /// </summary>
    public partial class BehaviorDropItemFor1160
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("cooldown", NullValueHandling = NullValueHandling.Ignore)]
        public double? Cooldown { get; set; }

        /// <summary>
        /// The probability that the mob will drop an item.
        /// </summary>
        [JsonProperty("drop_item_chance", NullValueHandling = NullValueHandling.Ignore)]
        public double? DropItemChance { get; set; } = 1;

        /// <summary>
        /// List of entity types this mob will drop items for.
        /// </summary>
        [JsonProperty("entity_types", NullValueHandling = NullValueHandling.Ignore)]
        public List<EntityTypeElement> EntityTypes { get; set; }

        /// <summary>
        /// Distance in blocks within the mob considers it has reached the goal. This is the "wiggle
        /// room" to stop the AI from bouncing back and forth trying to reach a specific spot
        /// </summary>
        [JsonProperty("goal_radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? GoalRadius { get; set; } = 0.5;

        /// <summary>
        /// Loot table to select items from.
        /// </summary>
        [JsonProperty("loot_table", NullValueHandling = NullValueHandling.Ignore)]
        public string LootTable { get; set; }

        /// <summary>
        /// Maximum distance in blocks this mob will look for entities to drop an item for.
        /// </summary>
        [JsonProperty("max_dist", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaxDist { get; set; } = 0;

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("max_head_look_at_height", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaxHeadLookAtHeight { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("minimum_teleport_distance", NullValueHandling = NullValueHandling.Ignore)]
        public double? MinimumTeleportDistance { get; set; }

        /// <summary>
        /// The distance in blocks the mob will try to be away from the entity when it drops the item.
        /// </summary>
        [JsonProperty("offering_distance", NullValueHandling = NullValueHandling.Ignore)]
        public double? OfferingDistance { get; set; } = 1;

        /// <summary>
        /// Event to run when this mob attempts to drop an item.
        /// </summary>
        [JsonProperty("on_drop_attempt", NullValueHandling = NullValueHandling.Ignore)]
        public Event? OnDropAttempt { get; set; }

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("search_count", NullValueHandling = NullValueHandling.Ignore)]
        public long? SearchCount { get; set; } = 1;

        /// <summary>
        /// Height in blocks from the target the mob can be.
        /// </summary>
        [JsonProperty("search_height", NullValueHandling = NullValueHandling.Ignore)]
        public long? SearchHeight { get; set; } = 1;

        /// <summary>
        /// The distance in blocks from the target the mob can be.
        /// </summary>
        [JsonProperty("search_range", NullValueHandling = NullValueHandling.Ignore)]
        public long? SearchRange { get; set; } = 0;

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("seconds_before_pickup", NullValueHandling = NullValueHandling.Ignore)]
        public double? SecondsBeforePickup { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("target_range", NullValueHandling = NullValueHandling.Ignore)]
        public List<double> TargetRange { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("teleport_offset", NullValueHandling = NullValueHandling.Ignore)]
        public List<double> TeleportOffset { get; set; }

        /// <summary>
        /// The valid times of day that this goal can be used. For reference: noon is 0.0, sunset is
        /// 0.25, midnight is 0.5, and sunrise is 0.75, and back to noon for 1.0.
        /// </summary>
        [JsonProperty("time_of_day_range", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(DecodeArrayConverter))]
        public List<double> TimeOfDayRange { get; set; } = new List<double> {0.0,1.0};
    }

    /// <summary>
    /// List of entity types this mob will drop items for.
    ///
    /// The entity type
    /// </summary>
    public partial class EntityTypeElement
    {
        [JsonProperty("filters", NullValueHandling = NullValueHandling.Ignore)]
        public EntityTypeFilters Filters { get; set; }

        /// <summary>
        /// Maximum distance this mob can be away to be a valid choice
        /// </summary>
        [JsonProperty("max_dist", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaxDist { get; set; } = 16;

        /// <summary>
        /// If true, the mob has to be visible to be a valid choice
        /// </summary>
        [JsonProperty("must_see", NullValueHandling = NullValueHandling.Ignore)]
        public bool? MustSee { get; set; } = new bool?();

        /// <summary>
        /// Determines the amount of time in seconds that this mob will look for a target before
        /// forgetting about it and looking for a new one when the target isn't visible any more
        /// </summary>
        [JsonProperty("must_see_forget_duration", NullValueHandling = NullValueHandling.Ignore)]
        public double? MustSeeForgetDuration { get; set; }

        /// <summary>
        /// Multiplier for the running speed. A value of 1.0 means the speed is unchanged
        /// </summary>
        [JsonProperty("sprint_speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SprintSpeedMultiplier { get; set; } = 16;

        /// <summary>
        /// Multiplier for the walking speed. A value of 1.0 means the speed is unchanged
        /// </summary>
        [JsonProperty("walk_speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? WalkSpeedMultiplier { get; set; } = 16;
    }

    /// <summary>
    /// Conditions that make this entry in the list valid
    ///
    /// Filter out mob types that it should not attack while angry (other Piglins)
    ///
    /// Entity_filter
    ///
    /// The filters to check to determine if the event should be fired
    ///
    /// The filters to use when determining if this potion can be selected.
    ///
    /// UNDOCUMENTATED
    ///
    /// Filter to determine the conditions for this mob to look at the entity
    ///
    /// Conditions that make this target a valid type.
    ///
    /// The filters to run when attempting to fall in love.
    ///
    /// The list of conditions that target of hunt must satisfy to initiate celebration.
    ///
    /// The list of conditions that must be satisfied before the Actor is despawned. If a filter
    /// is defined then standard despawn rules are ignored.
    ///
    /// The list of conditions that must be satisfied for other entities to be counted towards
    /// group size.
    ///
    /// The filter group that defines the conditions for this trigger
    ///
    /// The filter group that defines the conditions for using this item to heal the entity
    ///
    /// Defines the entities that can trigger this component
    ///
    /// TODO
    ///
    /// The list of conditions for this trigger
    ///
    /// If present, the specified entity will only spawn if the filter evaluates to true
    ///
    /// One or more conditions that must be met in order to cause the chosen block type to spawn.
    /// </summary>
    public partial class EntityTypeFilters
    {
        [JsonProperty("default_cowlib_filter")]
        public object DefaultCowlibFilter { get; set; }
    }

    /// <summary>
    /// UNDOCUMENTATED
    /// </summary>
    public partial class BehaviorEatBlock180
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("eat_and_replace_block_pairs", NullValueHandling = NullValueHandling.Ignore)]
        public List<EatAndReplaceBlockPairElement> EatAndReplaceBlockPairs { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("on_eat", NullValueHandling = NullValueHandling.Ignore)]
        public Trigger180 OnEat { get; set; }

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("success_chance", NullValueHandling = NullValueHandling.Ignore)]
        public SuccesChance? SuccessChance { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("time_until_eat", NullValueHandling = NullValueHandling.Ignore)]
        public double? TimeUntilEat { get; set; }
    }

    /// <summary>
    /// UNDOCUMENTATED
    /// </summary>
    public partial class EatAndReplaceBlockPairElement
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("eat_block", NullValueHandling = NullValueHandling.Ignore)]
        public string EatBlock { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("replace_block", NullValueHandling = NullValueHandling.Ignore)]
        public string ReplaceBlock { get; set; }
    }

    /// <summary>
    /// UNDOCUMENTATED
    ///
    /// Trigger to fire
    /// </summary>
    public partial class Trigger180
    {
        /// <summary>
        /// Event
        /// </summary>
        [JsonProperty("event", NullValueHandling = NullValueHandling.Ignore)]
        public string Event { get; set; }

        /// <summary>
        /// The filters to check to determine if the event should be fired
        /// </summary>
        [JsonProperty("filters", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject Filters { get; set; }

        /// <summary>
        /// The entity to target
        /// </summary>
        [JsonProperty("target", NullValueHandling = NullValueHandling.Ignore)]
        public Subject1160? Target { get; set; }
    }

    /// <summary>
    /// If the mob is carrying a food item, the mob will eat it and the effects will be applied
    /// to the mob.
    /// </summary>
    public partial class BehaviourEatCarriedItem1160
    {
        /// <summary>
        /// Time in seconds the mob should wait before eating the item.
        /// </summary>
        [JsonProperty("delay_before_eating", NullValueHandling = NullValueHandling.Ignore)]
        public double? DelayBeforeEating { get; set; }

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Allows the enderman to drop a block they are carrying. Can only be used by Endermen.
    /// </summary>
    public partial class BehaviorEndermanLeaveBlock180
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Allows the enderman to take a block and carry it around. Can only be used by Endermen.
    /// </summary>
    public partial class BehaviorEndermanTakeBlock180
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// UNDOCUMENTATED
    /// </summary>
    public partial class BehaviourEquipItem1160
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Behaviour explore outskirts
    /// </summary>
    public partial class BehaviorExploreOutskirts180
    {
        /// <summary>
        /// The distance in which the mob will proceed past the village bounds
        /// </summary>
        [JsonProperty("explore_dist", NullValueHandling = NullValueHandling.Ignore)]
        public double? ExploreDist { get; set; } = 5;

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }

        /// <summary>
        /// The time the mob will stand around 'searching' for POIs
        /// </summary>
        [JsonProperty("wait_time", NullValueHandling = NullValueHandling.Ignore)]
        public long? WaitTime { get; set; } = 0;
    }

    /// <summary>
    /// Allows the mob to seek shade.
    /// </summary>
    public partial class BehaviourFindCover1160
    {
        /// <summary>
        /// Time in seconds the mob has to wait before using the goal again
        /// </summary>
        [JsonProperty("cooldown_time", NullValueHandling = NullValueHandling.Ignore)]
        public double? CooldownTime { get; set; } = 0;

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }
    }

    /// <summary>
    /// Allows the mob to look around for another mob to ride atop it.
    /// </summary>
    public partial class BehaviorFindMount1160
    {
        /// <summary>
        /// If true, the mob will not go into water blocks when going towards a mount
        /// </summary>
        [JsonProperty("avoid_water", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AvoidWater { get; set; } = new bool?();

        /// <summary>
        /// TODO description
        /// </summary>
        [JsonProperty("max_failed_attempts", NullValueHandling = NullValueHandling.Ignore)]
        public long? MaxFailedAttempts { get; set; }

        /// <summary>
        /// This is the distance the mob needs to be, in blocks, from the desired mount to mount it.
        /// If the value is below 0, the mob will use its default attack distance
        /// </summary>
        [JsonProperty("mount_distance", NullValueHandling = NullValueHandling.Ignore)]
        public double? MountDistance { get; set; } = -1;

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// Time the mob will wait before starting to move towards the mount
        /// </summary>
        [JsonProperty("start_delay", NullValueHandling = NullValueHandling.Ignore)]
        public long? StartDelay { get; set; } = 0;

        /// <summary>
        /// If true, the mob will only look for a mount if it has a target
        /// </summary>
        [JsonProperty("target_needed", NullValueHandling = NullValueHandling.Ignore)]
        public bool? TargetNeeded { get; set; } = new bool?();

        /// <summary>
        /// Distance in blocks within which the mob will look for a mount
        /// </summary>
        [JsonProperty("within_radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? WithinRadius { get; set; } = 0;
    }

    /// <summary>
    /// Allows the mob to move towards the nearest underwater ruin or shipwreck.
    /// </summary>
    public partial class BehaviorFindUnderwaterTreasure180
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// The range that the mob will search for a treasure chest within a ruin or shipwreck to
        /// move towards.
        /// </summary>
        [JsonProperty("search_range", NullValueHandling = NullValueHandling.Ignore)]
        public long? SearchRange { get; set; } = 0;

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }

        /// <summary>
        /// The distance the mob will move before stopping.
        /// </summary>
        [JsonProperty("stop_distance", NullValueHandling = NullValueHandling.Ignore)]
        public double? StopDistance { get; set; } = 2;
    }

    /// <summary>
    /// Allows the mob to run away from direct sunlight and seek shade.
    /// </summary>
    public partial class BehaviorFleeSun180
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }
    }

    /// <summary>
    /// Allows the mob to stay afloat while swimming.
    /// </summary>
    public partial class MinecraftBehaviorFloatClass
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Allows the mob to float around like the Ghast.
    /// </summary>
    public partial class BehaviorFloatWander180
    {
        /// <summary>
        /// Range of time in seconds the mob will float around before landing and choosing to do
        /// something else
        /// </summary>
        [JsonProperty("float_duration", NullValueHandling = NullValueHandling.Ignore)]
        public List<double> FloatDuration { get; set; } = new List<double> {0.0,0.0};

        /// <summary>
        /// If true, the point has to be reachable to be a valid target
        /// </summary>
        [JsonProperty("must_reach", NullValueHandling = NullValueHandling.Ignore)]
        public bool? MustReach { get; set; } = new bool?();

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// If true, the mob will randomly pick a new point while moving to the previously selected
        /// one
        /// </summary>
        [JsonProperty("random_reselect", NullValueHandling = NullValueHandling.Ignore)]
        public bool? RandomReselect { get; set; } = new bool?();

        /// <summary>
        /// Distance in blocks on ground that the mob will look for a new spot to move to. Must be at
        /// least 1
        /// </summary>
        [JsonProperty("xz_dist", NullValueHandling = NullValueHandling.Ignore)]
        public long? XzDist { get; set; } = 10;

        /// <summary>
        /// Distance in blocks that the mob will look up or down for a new spot to move to. Must be
        /// at least 1
        /// </summary>
        [JsonProperty("y_dist", NullValueHandling = NullValueHandling.Ignore)]
        public long? YDist { get; set; } = 7;

        /// <summary>
        /// Height in blocks to add to the selected target position
        /// </summary>
        [JsonProperty("y_offset", NullValueHandling = NullValueHandling.Ignore)]
        public double? YOffset { get; set; } = 0;
    }

    /// <summary>
    /// Allows the mob to follow mobs that are in a caravan.
    /// </summary>
    public partial class BehaviorFollowCaravan180
    {
        /// <summary>
        /// Number of entities that can be in the caravan
        /// </summary>
        [JsonProperty("entity_count", NullValueHandling = NullValueHandling.Ignore)]
        public long? EntityCount { get; set; } = 1;

        /// <summary>
        /// List of entity types that this mob can follow in a caravan
        /// </summary>
        [JsonProperty("entity_types", NullValueHandling = NullValueHandling.Ignore)]
        public EntityTypes180? EntityTypes { get; set; }

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }
    }

    /// <summary>
    /// Allows the mob to follow other mobs.
    /// </summary>
    public partial class BehaviorFollowMob180
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// The distance in blocks it will look for a mob to follow
        /// </summary>
        [JsonProperty("search_range", NullValueHandling = NullValueHandling.Ignore)]
        public long? SearchRange { get; set; } = 0;

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }

        /// <summary>
        /// The distance in blocks this mob stops from the mob it is following
        /// </summary>
        [JsonProperty("stop_distance", NullValueHandling = NullValueHandling.Ignore)]
        public double? StopDistance { get; set; } = 2;
    }

    /// <summary>
    /// Allows the mob to follow their parent around.
    /// </summary>
    public partial class BehaviorFollowOwner180
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }

        /// <summary>
        /// The distance in blocks that the owner can be away from this mob before it starts
        /// following it
        /// </summary>
        [JsonProperty("start_distance", NullValueHandling = NullValueHandling.Ignore)]
        public double? StartDistance { get; set; } = 10;

        /// <summary>
        /// The distance in blocks this mob will stop from its owner while following it
        /// </summary>
        [JsonProperty("stop_distance", NullValueHandling = NullValueHandling.Ignore)]
        public double? StopDistance { get; set; } = 2;
    }

    /// <summary>
    /// Allows the mob to follow their parent around.
    /// </summary>
    public partial class MinecraftBehaviorFollowParentClass
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }
    }

    /// <summary>
    /// Allows mob to move towards its current target captain.
    /// </summary>
    public partial class BehaviorFollowTargetCaptain180
    {
        /// <summary>
        /// Defines the distance in blocks the mob will stay from its target while following.
        /// </summary>
        [JsonProperty("follow_distance", NullValueHandling = NullValueHandling.Ignore)]
        public double? FollowDistance { get; set; } = 0;

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }

        /// <summary>
        /// Defines the maximum distance in blocks a mob can get from its target captain before
        /// giving up trying to follow it.
        /// </summary>
        [JsonProperty("within_radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? WithinRadius { get; set; } = 0;
    }

    /// <summary>
    /// Allows the mob to move back to the position they were spawned.
    /// </summary>
    public partial class BehaviorGoHome
    {
        /// <summary>
        /// Distance in blocks within the mob considers it has reached the goal. This is the "wiggle
        /// room" to stop the AI from bouncing back and forth trying to reach a specific spot
        /// </summary>
        [JsonProperty("goal_radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? GoalRadius { get; set; } = 0.5;

        /// <summary>
        /// A random value to determine when to randomly move somewhere. This has a 1/interval chance
        /// to choose this goal
        /// </summary>
        [JsonProperty("interval", NullValueHandling = NullValueHandling.Ignore)]
        public long? Interval { get; set; } = 120;

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("on_failed", NullValueHandling = NullValueHandling.Ignore)]
        public Event? OnFailed { get; set; }

        /// <summary>
        /// Event to run when this mob gets home.
        /// </summary>
        [JsonProperty("on_home", NullValueHandling = NullValueHandling.Ignore)]
        public OnHome? OnHome { get; set; }

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }
    }

    /// <summary>
    /// UNDOCUMENTATED
    /// </summary>
    public partial class OnHomeEvent
    {
        /// <summary>
        /// The event to fire
        /// </summary>
        [JsonProperty("event", NullValueHandling = NullValueHandling.Ignore)]
        public string Event { get; set; }

        [JsonProperty("filters", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject Filters { get; set; }

        /// <summary>
        /// The target of the event
        /// </summary>
        [JsonProperty("target", NullValueHandling = NullValueHandling.Ignore)]
        public Target? Target { get; set; }
    }

    /// <summary>
    /// UNDOCUMENTATED
    /// </summary>
    public partial class OnHomeClass
    {
        /// <summary>
        /// The event to fire
        /// </summary>
        [JsonProperty("event", NullValueHandling = NullValueHandling.Ignore)]
        public string Event { get; set; }

        [JsonProperty("filters", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject Filters { get; set; }

        /// <summary>
        /// The target of the event
        /// </summary>
        [JsonProperty("target", NullValueHandling = NullValueHandling.Ignore)]
        public Target? Target { get; set; }
    }

    /// <summary>
    /// Allows the guardian to use its laser beam attack. Can only be used by Guardians and Elder
    /// Guardians.
    /// </summary>
    public partial class MinecraftBehaviorGuardianAttackClass
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Allows the villager to harvest nearby farms. Can only be used by Villagers.
    /// </summary>
    public partial class BehaviorHarvestFarmBlock180
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }
    }

    /// <summary>
    /// Allows a mob with the hide component to attempt to move to - and hide at - an owned or
    /// nearby POI.
    /// </summary>
    public partial class BehaviorHide180
    {
        /// <summary>
        /// Amount of time in seconds that the mob reacts.
        /// </summary>
        [JsonProperty("duration", NullValueHandling = NullValueHandling.Ignore)]
        public double? Duration { get; set; } = 1;

        /// <summary>
        /// Defines what POI type to hide at.
        /// </summary>
        [JsonProperty("poi_type", NullValueHandling = NullValueHandling.Ignore)]
        public string PoiType { get; set; } = "";

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }

        /// <summary>
        /// The cooldown time in seconds before the goal can be reused after a internal failure or
        /// timeout condition.
        /// </summary>
        [JsonProperty("timeout_cooldown", NullValueHandling = NullValueHandling.Ignore)]
        public double? TimeoutCooldown { get; set; } = 8;
    }

    /// <summary>
    /// The mob freezes and looks at the mob they are targeting.
    /// </summary>
    public partial class BehaviourHoldGround1160
    {
        /// <summary>
        /// Whether to broadcast out the mob's target to other mobs of the same type.
        /// </summary>
        [JsonProperty("broadcast", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Broadcast { get; set; } = new bool?();

        /// <summary>
        /// Range in blocks for how far to broadcast.
        /// </summary>
        [JsonProperty("broadcast_range", NullValueHandling = NullValueHandling.Ignore)]
        public double? BroadcastRange { get; set; } = 0;

        /// <summary>
        /// Minimum distance the target must be for the mob to run this goal.
        /// </summary>
        [JsonProperty("min_radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? MinRadius { get; set; } = 10;

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// Event to run when target is within the radius. This event is broadcasted if broadcast is
        /// true.
        /// </summary>
        [JsonProperty("within_radius_event", NullValueHandling = NullValueHandling.Ignore)]
        public Event? WithinRadiusEvent { get; set; }
    }

    /// <summary>
    /// Allows the mob to target another mob that hurts them.
    /// </summary>
    public partial class MinecraftBehaviorHurtByTargetClass
    {
        /// <summary>
        /// If true, nearby mobs of the same type will be alerted about the damage
        /// </summary>
        [JsonProperty("alert_same_type", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AlertSameType { get; set; } = new bool?();

        /// <summary>
        /// TODO description: entity types
        /// </summary>
        [JsonProperty("entity_types", NullValueHandling = NullValueHandling.Ignore)]
        public EntityTypes180? EntityTypes { get; set; }

        /// <summary>
        /// If true, the mob will hurt its owner and other mobs with the same owner as itself
        /// </summary>
        [JsonProperty("hurt_owner", NullValueHandling = NullValueHandling.Ignore)]
        public bool? HurtOwner { get; set; } = new bool?();

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Allows the mob to inspect bookshelves.
    /// </summary>
    public partial class BehaviorInspectBookshelf180
    {
        /// <summary>
        /// Distance in blocks within the mob considers it has reached the goal. This is the "wiggle
        /// room" to stop the AI from bouncing back and forth trying to reach a specific spot
        /// </summary>
        [JsonProperty("goal_radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? GoalRadius { get; set; } = 0.5;

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// The number of blocks each tick that the mob will check within it's search range and
        /// height for a valid block to move to. A value of 0 will have the mob check every block
        /// within range in one tick
        /// </summary>
        [JsonProperty("search_count", NullValueHandling = NullValueHandling.Ignore)]
        public long? SearchCount { get; set; } = 10;

        /// <summary>
        /// The height that the mob will search for bookshelves
        /// </summary>
        [JsonProperty("search_height", NullValueHandling = NullValueHandling.Ignore)]
        public long? SearchHeight { get; set; } = 1;

        /// <summary>
        /// Distance in blocks the mob will look for books to inspect
        /// </summary>
        [JsonProperty("search_range", NullValueHandling = NullValueHandling.Ignore)]
        public long? SearchRange { get; set; } = 0;

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }
    }

    /// <summary>
    /// Allows the mob to perform a damaging knockback that affects all nearby entities.
    /// </summary>
    public partial class BehaviorKnockbackRoar1160
    {
        /// <summary>
        /// The delay after which the knockback occurs (in seconds).
        /// </summary>
        [JsonProperty("attack_time", NullValueHandling = NullValueHandling.Ignore)]
        public double? AttackTime { get; set; } = 0.5;

        /// <summary>
        /// Time in seconds the mob has to wait before using the goal again
        /// </summary>
        [JsonProperty("cooldown_time", NullValueHandling = NullValueHandling.Ignore)]
        public double? CooldownTime { get; set; } = 0;

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("damage_filters", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject DamageFilters { get; set; }

        /// <summary>
        /// The duration of the roar (in seconds).
        /// </summary>
        [JsonProperty("duration", NullValueHandling = NullValueHandling.Ignore)]
        public double? Duration { get; set; } = 1;

        /// <summary>
        /// The damage dealt by the knockback roar.
        /// </summary>
        [JsonProperty("knockback_damage", NullValueHandling = NullValueHandling.Ignore)]
        public long? KnockbackDamage { get; set; } = 6;

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("knockback_filters", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject KnockbackFilters { get; set; }

        /// <summary>
        /// The radius (in blocks) of the knockback effect.
        /// </summary>
        [JsonProperty("knockback_range", NullValueHandling = NullValueHandling.Ignore)]
        public long? KnockbackRange { get; set; } = 4;

        /// <summary>
        /// The strength of the knockback.
        /// </summary>
        [JsonProperty("knockback_strength", NullValueHandling = NullValueHandling.Ignore)]
        public long? KnockbackStrength { get; set; } = 4;

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("on_roar_end", NullValueHandling = NullValueHandling.Ignore)]
        public Event? OnRoarEnd { get; set; }

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// On_roar_end
        /// </summary>
        [JsonProperty("Trigger", NullValueHandling = NullValueHandling.Ignore)]
        public Trigger Trigger { get; set; }
    }

    /// <summary>
    /// Allows mobs to lay down at times.
    /// </summary>
    public partial class BehaviorLayDown180
    {
        /// <summary>
        /// A random value to determine at what intervals something can occur. This has a 1/interval
        /// chance to choose this goal
        /// </summary>
        [JsonProperty("interval", NullValueHandling = NullValueHandling.Ignore)]
        public long? Interval { get; set; } = 120;

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// A random value in which the goal can use to pull out of the behavior. This is a
        /// 1/interval chance to play the sound
        /// </summary>
        [JsonProperty("random_stop_interval", NullValueHandling = NullValueHandling.Ignore)]
        public long? RandomStopInterval { get; set; } = 120;
    }

    /// <summary>
    /// Allows the mob to lay an egg block on a sand block if the mob is pregnant.
    /// </summary>
    public partial class BehaviorLayEgg180
    {
        /// <summary>
        /// Distance in blocks within the mob considers it has reached the goal. This is the "wiggle
        /// room" to stop the AI from bouncing back and forth trying to reach a specific spot
        /// </summary>
        [JsonProperty("goal_radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? GoalRadius { get; set; } = 0.5;

        /// <summary>
        /// Event to run when this mob lays the egg.
        /// </summary>
        [JsonProperty("on_lay", NullValueHandling = NullValueHandling.Ignore)]
        public Event? OnLay { get; set; }

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// Height in blocks the mob will look for sand block to move towards
        /// </summary>
        [JsonProperty("search_height", NullValueHandling = NullValueHandling.Ignore)]
        public long? SearchHeight { get; set; } = 1;

        /// <summary>
        /// The distance in blocks it will look for a sand block to move towards
        /// </summary>
        [JsonProperty("search_range", NullValueHandling = NullValueHandling.Ignore)]
        public long? SearchRange { get; set; } = 0;

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }
    }

    /// <summary>
    /// Allows monsters to jump at and attack their target. Can only be used by hostile mobs.
    /// </summary>
    public partial class BehaviorLeapAtTarget1160
    {
        /// <summary>
        /// If true, the mob will only jump at its target if its on the ground. Setting it to false
        /// will allow it to jump even if its already in the air
        /// </summary>
        [JsonProperty("must_be_on_ground", NullValueHandling = NullValueHandling.Ignore)]
        public bool? MustBeOnGround { get; set; } = new bool?();

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// Allows the actor to be set to persist upon targeting a player
        /// </summary>
        [JsonProperty("set_persistent", NullValueHandling = NullValueHandling.Ignore)]
        public bool? SetPersistent { get; set; } = new bool?();

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("target_dist", NullValueHandling = NullValueHandling.Ignore)]
        public double? TargetDist { get; set; } = 0;

        /// <summary>
        /// The height in blocks the mob jumps when leaping at its target
        /// </summary>
        [JsonProperty("yd", NullValueHandling = NullValueHandling.Ignore)]
        public double? Yd { get; set; } = 0;
    }

    /// <summary>
    /// Allows the mob to look at nearby entities.
    /// </summary>
    public partial class BehaviorLookAtEntity180
    {
        /// <summary>
        /// The angle in degrees that the mob can see in the Y-axis (up-down)
        /// </summary>
        [JsonProperty("angle_of_view_horizontal", NullValueHandling = NullValueHandling.Ignore)]
        public long? AngleOfViewHorizontal { get; set; } = 360;

        /// <summary>
        /// The angle in degrees that the mob can see in the X-axis (left-right)
        /// </summary>
        [JsonProperty("angle_of_view_vertical", NullValueHandling = NullValueHandling.Ignore)]
        public long? AngleOfViewVertical { get; set; } = 360;

        /// <summary>
        /// Filter to determine the conditions for this mob to look at the entity
        /// </summary>
        [JsonProperty("filters", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject Filters { get; set; }

        /// <summary>
        /// The distance in blocks from which the entity will look at
        /// </summary>
        [JsonProperty("look_distance", NullValueHandling = NullValueHandling.Ignore)]
        public double? LookDistance { get; set; } = 8;

        /// <summary>
        /// Time range to look at the entity
        /// </summary>
        [JsonProperty("look_time", NullValueHandling = NullValueHandling.Ignore)]
        public List<double> LookTime { get; set; } = new List<double> {2.0,4.0};

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// The probability of looking at the target. A value of 1.00 is 100%
        /// </summary>
        [JsonProperty("probability", NullValueHandling = NullValueHandling.Ignore)]
        public double? Probability { get; set; } = 0.02;
    }

    /// <summary>
    /// Allows the mob to look at the player when the player is nearby.
    /// </summary>
    public partial class BehaviorLookAtPlayer1160
    {
        /// <summary>
        /// The angle in degrees that the mob can see in the Y-axis (up-down)
        /// </summary>
        [JsonProperty("angle_of_view_horizontal", NullValueHandling = NullValueHandling.Ignore)]
        public long? AngleOfViewHorizontal { get; set; } = 360;

        /// <summary>
        /// The angle in degrees that the mob can see in the X-axis (left-right)
        /// </summary>
        [JsonProperty("angle_of_view_vertical", NullValueHandling = NullValueHandling.Ignore)]
        public long? AngleOfViewVertical { get; set; } = 360;

        /// <summary>
        /// The distance in blocks from which the entity will look at
        /// </summary>
        [JsonProperty("look_distance", NullValueHandling = NullValueHandling.Ignore)]
        public double? LookDistance { get; set; } = 8;

        /// <summary>
        /// Time range to look at the entity
        /// </summary>
        [JsonProperty("look_time", NullValueHandling = NullValueHandling.Ignore)]
        public List<double> LookTime { get; set; } = new List<double> {2.0,4.0};

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// The probability of looking at the target. A value of 1.00 is 100%
        /// </summary>
        [JsonProperty("probability", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(FluffyMinMaxValueCheckConverter))]
        public double? Probability { get; set; } = 0.02;

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("target_distance", NullValueHandling = NullValueHandling.Ignore)]
        public double? TargetDistance { get; set; }
    }

    /// <summary>
    /// Allows the mob to look at the entity they are targetting.
    /// </summary>
    public partial class BehaviorLookAtTarget180
    {
        /// <summary>
        /// The angle in degrees that the mob can see in the Y-axis (up-down)
        /// </summary>
        [JsonProperty("angle_of_view_horizontal", NullValueHandling = NullValueHandling.Ignore)]
        public long? AngleOfViewHorizontal { get; set; } = 360;

        /// <summary>
        /// The angle in degrees that the mob can see in the X-axis (left-right)
        /// </summary>
        [JsonProperty("angle_of_view_vertical", NullValueHandling = NullValueHandling.Ignore)]
        public long? AngleOfViewVertical { get; set; } = 360;

        /// <summary>
        /// The distance in blocks from which the entity will look at
        /// </summary>
        [JsonProperty("look_distance", NullValueHandling = NullValueHandling.Ignore)]
        public double? LookDistance { get; set; } = 8;

        /// <summary>
        /// Time range to look at the entity
        /// </summary>
        [JsonProperty("look_time", NullValueHandling = NullValueHandling.Ignore)]
        public List<double> LookTime { get; set; } = new List<double> {2.0,4.0};

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// The probability of looking at the target. A value of 1.00 is 100%
        /// </summary>
        [JsonProperty("probability", NullValueHandling = NullValueHandling.Ignore)]
        public double? Probability { get; set; } = 0.02;
    }

    /// <summary>
    /// Allows the mob to look at the player they are trading with.
    /// </summary>
    public partial class BehaviorLookAtTradingPlayer180
    {
        /// <summary>
        /// The angle in degrees that the mob can see in the Y-axis (up-down)
        /// </summary>
        [JsonProperty("angle_of_view_horizontal", NullValueHandling = NullValueHandling.Ignore)]
        public long? AngleOfViewHorizontal { get; set; } = 360;

        /// <summary>
        /// The angle in degrees that the mob can see in the X-axis (left-right)
        /// </summary>
        [JsonProperty("angle_of_view_vertical", NullValueHandling = NullValueHandling.Ignore)]
        public long? AngleOfViewVertical { get; set; } = 360;

        /// <summary>
        /// The distance in blocks from which the entity will look at
        /// </summary>
        [JsonProperty("look_distance", NullValueHandling = NullValueHandling.Ignore)]
        public double? LookDistance { get; set; } = 8;

        /// <summary>
        /// Time range to look at the entity
        /// </summary>
        [JsonProperty("look_time", NullValueHandling = NullValueHandling.Ignore)]
        public List<double> LookTime { get; set; } = new List<double> {2.0,4.0};

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// The probability of looking at the target. A value of 1.00 is 100%
        /// </summary>
        [JsonProperty("probability", NullValueHandling = NullValueHandling.Ignore)]
        public double? Probability { get; set; } = 0.02;
    }

    /// <summary>
    /// Allows the villager to look for a mate to spawn other villagers with. Can only be used by
    /// Villagers.
    /// </summary>
    public partial class BehaviorMakeLove180
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Allows the mob to use close combat melee attacks.
    /// </summary>
    public partial class BehaviorMeleeAttack180
    {
        /// <summary>
        /// If true, this mob will attack only one time.
        /// </summary>
        [JsonProperty("attack_once", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AttackOnce { get; set; } = new bool?();

        /// <summary>
        /// Defines the entity types this mob will attack
        /// </summary>
        [JsonProperty("attack_types", NullValueHandling = NullValueHandling.Ignore)]
        public string AttackTypes { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("cooldown_time", NullValueHandling = NullValueHandling.Ignore)]
        public double? CooldownTime { get; set; }

        /// <summary>
        /// The allowable FOV the actor will use to determine if it can make a valid melee attack
        /// </summary>
        [JsonProperty("melee_fov", NullValueHandling = NullValueHandling.Ignore)]
        public double? MeleeFov { get; set; } = 90;

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("on_attack", NullValueHandling = NullValueHandling.Ignore)]
        public Event? OnAttack { get; set; }

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// Defines the probability the mob will stop fighting. A value of 0 disables randomly
        /// stopping, while a value of 1 defines a 50% chance
        /// </summary>
        [JsonProperty("random_stop_interval", NullValueHandling = NullValueHandling.Ignore)]
        public long? RandomStopInterval { get; set; } = 0;

        /// <summary>
        /// Multiplier for how far outside its box the mob can reach its target (this can be used to
        /// simulate a mob with longer arms by making this bigger)
        /// </summary>
        [JsonProperty("reach_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? ReachMultiplier { get; set; } = 2;

        /// <summary>
        /// If true, this goal will only trigger if the mob can reach its target.
        /// </summary>
        [JsonProperty("require_complete_path", NullValueHandling = NullValueHandling.Ignore)]
        public bool? RequireCompletePath { get; set; } = new bool?();

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }

        /// <summary>
        /// If true, this mob will chase after the target as long as it's a valid target
        /// </summary>
        [JsonProperty("track_target", NullValueHandling = NullValueHandling.Ignore)]
        public bool? TrackTarget { get; set; } = new bool?();
    }

    /// <summary>
    /// Allows an entity to go to the village bell and mingle with other entities.
    /// </summary>
    public partial class BehaviorMingle180
    {
        /// <summary>
        /// Time in seconds the mob has to wait before using the goal again
        /// </summary>
        [JsonProperty("cooldown_time", NullValueHandling = NullValueHandling.Ignore)]
        public double? CooldownTime { get; set; } = 0;

        /// <summary>
        /// Amount of time in seconds that the entity will chat with another entity
        /// </summary>
        [JsonProperty("duration", NullValueHandling = NullValueHandling.Ignore)]
        public double? Duration { get; set; } = 1;

        /// <summary>
        /// The distance from its partner that this entity will mingle. If the entity type is not the
        /// same as the entity, this value needs to be identical on both entities.
        /// </summary>
        [JsonProperty("mingle_distance", NullValueHandling = NullValueHandling.Ignore)]
        public double? MingleDistance { get; set; } = 2;

        /// <summary>
        /// The entity type that this entity is allowed to mingle with
        /// </summary>
        [JsonProperty("mingle_partner_type", NullValueHandling = NullValueHandling.Ignore)]
        public MinglePartnerType? MinglePartnerType { get; set; }

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }
    }

    /// <summary>
    /// Allows the mob to move around on its own while mounted seeking a target to attack.
    /// </summary>
    public partial class BehaviorMountPathing180
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }

        /// <summary>
        /// The distance at which this mob wants to be away from its target
        /// </summary>
        [JsonProperty("target_dist", NullValueHandling = NullValueHandling.Ignore)]
        public double? TargetDist { get; set; } = 0;

        /// <summary>
        /// If true, this mob will chase after the target as long as it's a valid target
        /// </summary>
        [JsonProperty("track_target", NullValueHandling = NullValueHandling.Ignore)]
        public bool? TrackTarget { get; set; } = new bool?();
    }

    /// <summary>
    /// Can only be used by Villagers. Allows them to seek shelter indoors.
    /// </summary>
    public partial class BehaviorMoveIndoors180
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }

        /// <summary>
        /// The cooldown time in seconds before the goal can be reused after a internal failure or
        /// timeout condition
        /// </summary>
        [JsonProperty("timeout_cooldown", NullValueHandling = NullValueHandling.Ignore)]
        public double? TimeoutCooldown { get; set; } = 8;
    }

    /// <summary>
    /// Can only be used by Villagers. Allows the villagers to create paths around the village.
    /// </summary>
    public partial class BehaviorMoveThroughVillage180
    {
        /// <summary>
        /// If true, the mob will only move through the village during night time
        /// </summary>
        [JsonProperty("only_at_night", NullValueHandling = NullValueHandling.Ignore)]
        public bool? OnlyAtNight { get; set; } = new bool?();

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }
    }

    /// <summary>
    /// UNDOCUMENTATED
    /// </summary>
    public partial class BehaviorMoveToBlock180
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("goal_radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? GoalRadius { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("on_reach", NullValueHandling = NullValueHandling.Ignore)]
        public List<Event> OnReach { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("on_stay_completed", NullValueHandling = NullValueHandling.Ignore)]
        public List<Event> OnStayCompleted { get; set; }

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("search_height", NullValueHandling = NullValueHandling.Ignore)]
        public double? SearchHeight { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("search_range", NullValueHandling = NullValueHandling.Ignore)]
        public double? SearchRange { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("start_chance", NullValueHandling = NullValueHandling.Ignore)]
        public double? StartChance { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("stay_duration", NullValueHandling = NullValueHandling.Ignore)]
        public double? StayDuration { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("target_blocks", NullValueHandling = NullValueHandling.Ignore)]
        public List<string> TargetBlocks { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("target_offset", NullValueHandling = NullValueHandling.Ignore)]
        public List<double> TargetOffset { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("target_selection_method", NullValueHandling = NullValueHandling.Ignore)]
        public string TargetSelectionMethod { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("tick_interval", NullValueHandling = NullValueHandling.Ignore)]
        public double? TickInterval { get; set; }
    }

    /// <summary>
    /// Allows the mob to move back onto land when in water.
    /// </summary>
    public partial class BehaviorMoveToLand180
    {
        /// <summary>
        /// Distance in blocks within the mob considers it has reached the goal. This is the "wiggle
        /// room" to stop the AI from bouncing back and forth trying to reach a specific spot
        /// </summary>
        [JsonProperty("goal_radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? GoalRadius { get; set; } = 0.5;

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// The number of blocks each tick that the mob will check within it's search range and
        /// height for a valid block to move to. A value of 0 will have the mob check every block
        /// within range in one tick
        /// </summary>
        [JsonProperty("search_count", NullValueHandling = NullValueHandling.Ignore)]
        public long? SearchCount { get; set; } = 10;

        /// <summary>
        /// Height in blocks the mob will look for land to move towards
        /// </summary>
        [JsonProperty("search_height", NullValueHandling = NullValueHandling.Ignore)]
        public long? SearchHeight { get; set; } = 1;

        /// <summary>
        /// The distance in blocks it will look for land to move towards
        /// </summary>
        [JsonProperty("search_range", NullValueHandling = NullValueHandling.Ignore)]
        public long? SearchRange { get; set; } = 0;

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }
    }

    /// <summary>
    /// Allows the mob to move back into lava when on land.
    /// </summary>
    public partial class BehaviourMoveToLava1160
    {
        /// <summary>
        /// Distance in blocks within the mob considers it has reached the goal. This is the "wiggle
        /// room" to stop the AI from bouncing back and forth trying to reach a specific spot
        /// </summary>
        [JsonProperty("goal_radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? GoalRadius { get; set; } = 0.5;

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// The number of blocks each tick that the mob will check within it's search range and
        /// height for a valid block to move to. A value of 0 will have the mob check every block
        /// within range in one tick
        /// </summary>
        [JsonProperty("search_count", NullValueHandling = NullValueHandling.Ignore)]
        public long? SearchCount { get; set; } = 10;

        /// <summary>
        /// Height in blocks the mob will look for lava to move towards
        /// </summary>
        [JsonProperty("search_height", NullValueHandling = NullValueHandling.Ignore)]
        public long? SearchHeight { get; set; } = 1;

        /// <summary>
        /// The distance in blocks it will look for lava to move towards
        /// </summary>
        [JsonProperty("search_range", NullValueHandling = NullValueHandling.Ignore)]
        public long? SearchRange { get; set; } = 0;

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }
    }

    /// <summary>
    /// Allows the mob to move back into lava when on land.
    /// </summary>
    public partial class BehaviourMoveToLiquid180
    {
        /// <summary>
        /// Distance in blocks within the mob considers it has reached the goal. This is the "wiggle
        /// room" to stop the AI from bouncing back and forth trying to reach a specific spot
        /// </summary>
        [JsonProperty("goal_radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? GoalRadius { get; set; } = 0.5;

        /// <summary>
        /// UNDOCUMENTAED, examples are : Lava
        /// </summary>
        [JsonProperty("material_type", NullValueHandling = NullValueHandling.Ignore)]
        public string MaterialType { get; set; }

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// The number of blocks each tick that the mob will check within it's search range and
        /// height for a valid block to move to. A value of 0 will have the mob check every block
        /// within range in one tick
        /// </summary>
        [JsonProperty("search_count", NullValueHandling = NullValueHandling.Ignore)]
        public long? SearchCount { get; set; } = 10;

        /// <summary>
        /// Height in blocks the mob will look for lava to move towards
        /// </summary>
        [JsonProperty("search_height", NullValueHandling = NullValueHandling.Ignore)]
        public long? SearchHeight { get; set; } = 1;

        /// <summary>
        /// The distance in blocks it will look for lava to move towards
        /// </summary>
        [JsonProperty("search_range", NullValueHandling = NullValueHandling.Ignore)]
        public long? SearchRange { get; set; } = 0;

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }
    }

    /// <summary>
    /// Allows the mob to move to a POI if able to
    /// </summary>
    public partial class BehaviorMoveToPoi180
    {
        /// <summary>
        /// Tells the goal what POI type it should be looking for
        /// </summary>
        [JsonProperty("poi_type", NullValueHandling = NullValueHandling.Ignore)]
        public string PoiType { get; set; }

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }
    }

    /// <summary>
    /// Allows mob to move towards a random block.
    /// </summary>
    public partial class BehaviorMoveToRandomBlock180
    {
        /// <summary>
        /// Defines the distance from the mob, in blocks, that the block to move to will be chosen.
        /// </summary>
        [JsonProperty("block_distance", NullValueHandling = NullValueHandling.Ignore)]
        public double? BlockDistance { get; set; } = 16;

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }

        /// <summary>
        /// Defines the distance in blocks the mob has to be from the block for the movement to be
        /// finished.
        /// </summary>
        [JsonProperty("within_radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? WithinRadius { get; set; } = 0;
    }

    /// <summary>
    /// Allows the mob to move into a random location within a village.
    /// </summary>
    public partial class BehaviorMoveToVillage180
    {
        /// <summary>
        /// Time in seconds the mob has to wait before using the goal again
        /// </summary>
        [JsonProperty("cooldown_time", NullValueHandling = NullValueHandling.Ignore)]
        public double? CooldownTime { get; set; } = 0;

        /// <summary>
        /// Distance in blocks within the mob considers it has reached the goal. This is the "wiggle
        /// room" to stop the AI from bouncing back and forth trying to reach a specific spot
        /// </summary>
        [JsonProperty("goal_radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? GoalRadius { get; set; } = 0.5;

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// The distance in blocks to search for villages. If <= 0, find the closest village
        /// regardless of distance.
        /// </summary>
        [JsonProperty("search_range", NullValueHandling = NullValueHandling.Ignore)]
        public long? SearchRange { get; set; } = 0;

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }
    }

    /// <summary>
    /// Allows the mob to move back into water when on land.
    /// </summary>
    public partial class BehaviorMoveToWater180
    {
        /// <summary>
        /// Distance in blocks within the mob considers it has reached the goal. This is the "wiggle
        /// room" to stop the AI from bouncing back and forth trying to reach a specific spot
        /// </summary>
        [JsonProperty("goal_radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? GoalRadius { get; set; } = 0.5;

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// The number of blocks each tick that the mob will check within it's search range and
        /// height for a valid block to move to. A value of 0 will have the mob check every block
        /// within range in one tick
        /// </summary>
        [JsonProperty("search_count", NullValueHandling = NullValueHandling.Ignore)]
        public long? SearchCount { get; set; } = 10;

        /// <summary>
        /// Height in blocks the mob will look for water to move towards
        /// </summary>
        [JsonProperty("search_height", NullValueHandling = NullValueHandling.Ignore)]
        public long? SearchHeight { get; set; } = 1;

        /// <summary>
        /// The distance in blocks it will look for water to move towards
        /// </summary>
        [JsonProperty("search_range", NullValueHandling = NullValueHandling.Ignore)]
        public long? SearchRange { get; set; } = 0;

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }
    }

    /// <summary>
    /// UNDOCUMENTATED, comes from cat
    /// </summary>
    public partial class BehaviorMoveTowardsDwellingRestriction180
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }
    }

    /// <summary>
    /// UNDOCUMENTATED
    /// </summary>
    public partial class MoveTowardsHomeRestriction1160
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }
    }

    /// <summary>
    /// Allows Guardians, Iron Golems and Villagers to move within their pre-defined area that
    /// the mob should be restricted to. Other mobs don't have a restriction defined.
    /// </summary>
    public partial class BehaviorMoveTowardsRestriction180
    {
        /// <summary>
        /// TODO description: control flags
        /// </summary>
        [JsonProperty("control_flags", NullValueHandling = NullValueHandling.Ignore)]
        public List<ControlFlags> ControlFlags { get; set; }

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }
    }

    /// <summary>
    /// Allows mob to move towards its current target.
    /// </summary>
    public partial class MinecraftBehaviorMoveTowardsTargetClass
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }

        /// <summary>
        /// Defines the radius in blocks that the mob tries to be from the target. A value of 0 means
        /// it tries to occupy the same block as the target
        /// </summary>
        [JsonProperty("within_radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? WithinRadius { get; set; } = 0;
    }

    /// <summary>
    /// Allows the mob to move back into lava when on land.
    /// </summary>
    public partial class BehaviourNap1160
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("can_nap_filters", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject CanNapFilters { get; set; }

        /// <summary>
        /// Maximum time in seconds the mob has to wait before using the goal again
        /// </summary>
        [JsonProperty("cooldown_max", NullValueHandling = NullValueHandling.Ignore)]
        public double? CooldownMax { get; set; } = 0;

        /// <summary>
        /// Minimum time in seconds the mob has to wait before using the goal again
        /// </summary>
        [JsonProperty("cooldown_min", NullValueHandling = NullValueHandling.Ignore)]
        public double? CooldownMin { get; set; } = 0;

        /// <summary>
        /// The block distance in x and z that will be checked for mobs that this mob detects
        /// </summary>
        [JsonProperty("mob_detect_dist", NullValueHandling = NullValueHandling.Ignore)]
        public double? MobDetectDist { get; set; } = 6;

        /// <summary>
        /// The block distance in y that will be checked for mobs that this mob detects
        /// </summary>
        [JsonProperty("mob_detect_height", NullValueHandling = NullValueHandling.Ignore)]
        public double? MobDetectHeight { get; set; } = 6;

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("wake_mob_exceptions", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject WakeMobExceptions { get; set; }
    }

    /// <summary>
    /// Allows the mob to check for and pursue the nearest valid target.
    /// </summary>
    public partial class BehaviorNearestAttackableTarget1160
    {
        /// <summary>
        /// Time range (in seconds) between searching for an attack target, range is in (0,
        /// "attack_interval"]. Only used if "attack_interval" is greater than 0, otherwise
        /// "scan_interval" is used.
        /// </summary>
        [JsonProperty("attack_interval", NullValueHandling = NullValueHandling.Ignore)]
        public long? AttackInterval { get; set; } = 0;

        /// <summary>
        /// Alias for "attack_interval"; provides the same functionality as "attack_interval".
        /// </summary>
        [JsonProperty("attack_interval_min", NullValueHandling = NullValueHandling.Ignore)]
        public double? AttackIntervalMin { get; set; } = 0;

        /// <summary>
        /// If true, this entity can attack its owner.
        /// </summary>
        [JsonProperty("attack_owner", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AttackOwner { get; set; } = new bool?();

        /// <summary>
        /// Filters which types of targets are valid for this entity.
        /// </summary>
        [JsonProperty("entity_types", NullValueHandling = NullValueHandling.Ignore)]
        public EntityTypes? EntityTypes { get; set; }

        /// <summary>
        /// If true, this entity requires a path to the target.
        /// </summary>
        [JsonProperty("must_reach", NullValueHandling = NullValueHandling.Ignore)]
        public bool? MustReach { get; set; } = new bool?();

        /// <summary>
        /// Determines if target-validity requires this entity to be in range only, or both in range
        /// and in sight.
        /// </summary>
        [JsonProperty("must_see", NullValueHandling = NullValueHandling.Ignore)]
        public bool? MustSee { get; set; } = new bool?();

        /// <summary>
        /// Time (in seconds) the target must not be seen by this entity to become invalid. Used only
        /// if "must_see" is true.
        /// </summary>
        [JsonProperty("must_see_forget_duration", NullValueHandling = NullValueHandling.Ignore)]
        public double? MustSeeForgetDuration { get; set; } = 3;

        /// <summary>
        /// Time (in seconds) this entity can continue attacking the target after the target is no
        /// longer valid.
        /// </summary>
        [JsonProperty("persist_time", NullValueHandling = NullValueHandling.Ignore)]
        public double? PersistTime { get; set; } = 0;

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// Allows the attacking entity to update the nearest target, otherwise a target is only
        /// reselected after each "scan_interval" or "attack_interval".
        /// </summary>
        [JsonProperty("reselect_targets", NullValueHandling = NullValueHandling.Ignore)]
        public bool? ReselectTargets { get; set; } = new bool?();

        /// <summary>
        /// If "attack_interval" is 0 or isn't declared, then between attacks: scanning for a new
        /// target occurs every amount of ticks equal to "scan_interval", minimum value is 1. Values
        /// under 10 can affect performance.
        /// </summary>
        [JsonProperty("scan_interval", NullValueHandling = NullValueHandling.Ignore)]
        public long? ScanInterval { get; set; } = 10;

        /// <summary>
        /// Allows the actor to be set to persist upon targeting a player
        /// </summary>
        [JsonProperty("set_persistent", NullValueHandling = NullValueHandling.Ignore)]
        public bool? SetPersistent { get; set; } = new bool?();

        /// <summary>
        /// Multiplied with the target's armor coverage percentage to modify "max_dist" when
        /// detecting an invisible target.
        /// </summary>
        [JsonProperty("target_invisible_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? TargetInvisibleMultiplier { get; set; } = 0.7;

        /// <summary>
        /// Maximum vertical target-search distance, if it's greater than the target type's
        /// "max_dist". A negative value defaults to "entity_types" greatest "max_dist".
        /// </summary>
        [JsonProperty("target_search_height", NullValueHandling = NullValueHandling.Ignore)]
        public double? TargetSearchHeight { get; set; } = -1;

        /// <summary>
        /// Multiplied with the target type's "max_dist" when trying to detect a sneaking target.
        /// </summary>
        [JsonProperty("target_sneak_visibility_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? TargetSneakVisibilityMultiplier { get; set; } = 0.8;

        /// <summary>
        /// Maximum distance this entity can be from the target when following it, otherwise the
        /// target becomes invalid. This value is only used if the entity doesn't declare
        /// "minecraft:follow_range".
        /// </summary>
        [JsonProperty("within_radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? WithinRadius { get; set; } = 0;
    }

    /// <summary>
    /// A entity type
    /// </summary>
    public partial class EntityType
    {
        /// <summary>
        /// Conditions that make this target a valid type.
        /// </summary>
        [JsonProperty("filters", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject Filters { get; set; }

        /// <summary>
        /// To be a valid target choice, the target type cannot be farther away from this entity than
        /// "max_dist".
        /// </summary>
        [JsonProperty("max_dist", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaxDist { get; set; } = 16;

        /// <summary>
        /// Determines if target-validity requires this entity to be in range only, or both in range
        /// and in sight.
        /// </summary>
        [JsonProperty("must_see", NullValueHandling = NullValueHandling.Ignore)]
        public bool? MustSee { get; set; } = new bool?();

        /// <summary>
        /// Time (in seconds) the target must not be seen by this entity to become invalid. Used only
        /// if "must_see" is true.
        /// </summary>
        [JsonProperty("must_see_forget_duration", NullValueHandling = NullValueHandling.Ignore)]
        public bool? MustSeeForgetDuration { get; set; }
    }

    /// <summary>
    /// Allows the mob to check for and pursue the nearest valid target.
    /// </summary>
    public partial class BehaviorNearestPrioritizedAttackableTarget1160
    {
        /// <summary>
        /// Time in seconds before selecting a target
        /// </summary>
        [JsonProperty("attack_interval", NullValueHandling = NullValueHandling.Ignore)]
        public long? AttackInterval { get; set; } = 0;

        /// <summary>
        /// List of entity types that this mob considers valid targets
        /// </summary>
        [JsonProperty("entity_types", NullValueHandling = NullValueHandling.Ignore)]
        public List<EntityTypeElement> EntityTypes { get; set; }

        /// <summary>
        /// If true, only entities that this mob can path to can be selected as targets
        /// </summary>
        [JsonProperty("must_reach", NullValueHandling = NullValueHandling.Ignore)]
        public bool? MustReach { get; set; } = new bool?();

        /// <summary>
        /// If true, only entities in this mob's viewing range can be selected as targets
        /// </summary>
        [JsonProperty("must_see", NullValueHandling = NullValueHandling.Ignore)]
        public bool? MustSee { get; set; } = new bool?();

        /// <summary>
        /// Determines the amount of time in seconds that this mob will look for a target before
        /// forgetting about it and looking for a new one when the target isn't visible any more
        /// </summary>
        [JsonProperty("must_see_forget_duration", NullValueHandling = NullValueHandling.Ignore)]
        public double? MustSeeForgetDuration { get; set; } = 3;

        /// <summary>
        /// Time in seconds for a valid target to stay targeted when it becomes and invalid target.
        /// </summary>
        [JsonProperty("persist_time", NullValueHandling = NullValueHandling.Ignore)]
        public double? PersistTime { get; set; } = 0;

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// If true, the target will change to the current closest entity whenever a different entity
        /// is closer
        /// </summary>
        [JsonProperty("reselect_targets", NullValueHandling = NullValueHandling.Ignore)]
        public bool? ReselectTargets { get; set; } = new bool?();

        /// <summary>
        /// How many ticks to wait between scanning for a target.
        /// </summary>
        [JsonProperty("scan_interval", NullValueHandling = NullValueHandling.Ignore)]
        public long? ScanInterval { get; set; } = 10;

        /// <summary>
        /// Allows the actor to be set to persist upon targeting a player
        /// </summary>
        [JsonProperty("set_persistent", NullValueHandling = NullValueHandling.Ignore)]
        public bool? SetPersistent { get; set; } = new bool?();

        /// <summary>
        /// Height in blocks to search for a target mob. -1.0f means the height does not matter.
        /// </summary>
        [JsonProperty("target_search_height", NullValueHandling = NullValueHandling.Ignore)]
        public double? TargetSearchHeight { get; set; } = -1;

        /// <summary>
        /// Distance in blocks that the target can be within to launch an attack
        /// </summary>
        [JsonProperty("within_radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? WithinRadius { get; set; } = 0;
    }

    /// <summary>
    /// TODO description
    /// </summary>
    public partial class BehaviorOcelotSitOnBlock180
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }
    }

    /// <summary>
    /// Can only be used by the Ocelot. Allows it to perform the sneak and pounce attack.
    /// </summary>
    public partial class BehaviorOcelotattack180
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("cooldown_time", NullValueHandling = NullValueHandling.Ignore)]
        public double? CooldownTime { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("max_distance", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaxDistance { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("max_sneak_range", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaxSneakRange { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("max_sprint_range", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaxSprintRange { get; set; }

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("reach_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? ReachMultiplier { get; set; }

        /// <summary>
        /// Multiplier for the sneaking speed. 1.0 means the ocelot will move at the speed it
        /// normally sneaks
        /// </summary>
        [JsonProperty("sneak_speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SneakSpeedMultiplier { get; set; } = 1;

        /// <summary>
        /// Multiplier for the running speed of this mob while using this attack
        /// </summary>
        [JsonProperty("sprint_speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SprintSpeedMultiplier { get; set; } = 1;

        /// <summary>
        /// Multiplier for the walking speed while using this attack
        /// </summary>
        [JsonProperty("walk_speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? WalkSpeedMultiplier { get; set; } = 1;

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("x_max_rotation", NullValueHandling = NullValueHandling.Ignore)]
        public double? XMaxRotation { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("y_max_head_rotation", NullValueHandling = NullValueHandling.Ignore)]
        public double? YMaxHeadRotation { get; set; }
    }

    /// <summary>
    /// Allows the mob to offer the player a flower like the Iron Golem does.
    /// </summary>
    public partial class BehaviorOfferFlower180
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Allows the mob to open doors. Requires the mob to be able to path through doors,
    /// otherwise the mob won't even want to try opening them.
    /// </summary>
    public partial class MinecraftBehaviorOpenDoorClass
    {
        /// <summary>
        /// If true, the mob will close the door after opening it and going through it
        /// </summary>
        [JsonProperty("close_door_after", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CloseDoorAfter { get; set; } = new bool?();

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Allows the mob to target another mob that hurts their owner.
    /// </summary>
    public partial class BehaviorOwnerHurtByTarget180
    {
        /// <summary>
        /// List of entity types that this mob can target if they hurt their owner
        /// </summary>
        [JsonProperty("entity_types", NullValueHandling = NullValueHandling.Ignore)]
        public EntityTypes180? EntityTypes { get; set; }

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Allows the mob to target a mob that is hurt by their owner.
    /// </summary>
    public partial class BehaviorOwnerHurtTarget180
    {
        /// <summary>
        /// List of entity types that this entity can target if the potential target is hurt by this
        /// mob's owner
        /// </summary>
        [JsonProperty("entity_types", NullValueHandling = NullValueHandling.Ignore)]
        public EntityTypes180? EntityTypes { get; set; }

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Allows the mob to enter the panic state, which makes it run around and away from the
    /// damage source that made it enter this state.
    /// </summary>
    public partial class BehaviorPanic180
    {
        /// <summary>
        /// The list of Entity Damage Sources that will cause this mob to panic
        /// </summary>
        [JsonProperty("damage_sources", NullValueHandling = NullValueHandling.Ignore)]
        public List<EntityDamageName> DamageSources { get; set; }

        /// <summary>
        /// If true, this mob will not stop panicking until it can't move anymore or the goal is
        /// removed from it
        /// </summary>
        [JsonProperty("force", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Force { get; set; } = new bool?();

        /// <summary>
        /// If true, the mob will not panic in response to damage from other mobs. This overrides the
        /// damage types in "damage_sources"
        /// </summary>
        [JsonProperty("ignore_mob_damage", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IgnoreMobDamage { get; set; } = new bool?();

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("panic_sound", NullValueHandling = NullValueHandling.Ignore)]
        public string PanicSound { get; set; }

        /// <summary>
        /// If true, the mob will prefer water over land
        /// </summary>
        [JsonProperty("prefer_water", NullValueHandling = NullValueHandling.Ignore)]
        public bool? PreferWater { get; set; } = new bool?();

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        [JsonProperty("sound_interval", NullValueHandling = NullValueHandling.Ignore)]
        public Range SoundInterval { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }
    }

    /// <summary>
    /// Allows the mob to peek out. This is what the shulker uses to look out of its shell.
    /// </summary>
    public partial class BehaviorPeek180
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Allows the mob to be tempted by food they like.
    /// </summary>
    public partial class MinecraftBehaviorPetSleepWithOwnerClass
    {
        /// <summary>
        /// Distance in blocks within the mob considers it has reached the goal. This is the "wiggle
        /// room" to stop the AI from bouncing back and forth trying to reach a specific spot
        /// </summary>
        [JsonProperty("goal_radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? GoalRadius { get; set; } = 0.5;

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// Height in blocks from the owner the pet can be to sleep with owner.
        /// </summary>
        [JsonProperty("search_height", NullValueHandling = NullValueHandling.Ignore)]
        public long? SearchHeight { get; set; } = 1;

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("search_radius", NullValueHandling = NullValueHandling.Ignore)]
        public long? SearchRadius { get; set; } = 0;

        /// <summary>
        /// The distance in blocks from the owner the pet can be to sleep with owner.
        /// </summary>
        [JsonProperty("search_range", NullValueHandling = NullValueHandling.Ignore)]
        public long? SearchRange { get; set; } = 0;

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }
    }

    /// <summary>
    /// Allows the mob to pick up items on the ground.
    /// </summary>
    public partial class BehaviorPickupItems1160
    {
        /// <summary>
        /// If true, the mob can pickup any item
        /// </summary>
        [JsonProperty("can_pickup_any_item", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanPickupAnyItem { get; set; } = new bool?();

        /// <summary>
        /// If true, the mob can pickup items to its hand or armor slots
        /// </summary>
        [JsonProperty("can_pickup_to_hand_or_equipment", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanPickupToHandOrEquipment { get; set; } = new bool?();

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("cooldown_after_being_attacked", NullValueHandling = NullValueHandling.Ignore)]
        public double? CooldownAfterBeingAttacked { get; set; }

        /// <summary>
        /// Distance in blocks within the mob considers it has reached the goal. This is the "wiggle
        /// room" to stop the AI from bouncing back and forth trying to reach a specific spot
        /// </summary>
        [JsonProperty("goal_radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? GoalRadius { get; set; } = 0.5;

        /// <summary>
        /// Maximum distance this mob will look for items to pick up
        /// </summary>
        [JsonProperty("max_dist", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaxDist { get; set; } = 0;

        /// <summary>
        /// If true, depending on the difficulty, there is a random chance that the mob may not be
        /// able to pickup items
        /// </summary>
        [JsonProperty("pickup_based_on_chance", NullValueHandling = NullValueHandling.Ignore)]
        public bool? PickupBasedOnChance { get; set; } = new bool?();

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }

        /// <summary>
        /// If true, this mob will chase after the target as long as it's a valid target
        /// </summary>
        [JsonProperty("track_target", NullValueHandling = NullValueHandling.Ignore)]
        public bool? TrackTarget { get; set; } = new bool?();
    }

    /// <summary>
    /// Allows the mob to play with other baby villagers. This can only be used by Villagers.
    /// </summary>
    public partial class BehaviorPlay180
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }
    }

    /// <summary>
    /// Allows the mob to be ridden by the player after being tamed.
    /// </summary>
    public partial class MinecraftBehaviorPlayerRideTamedClass
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Allows the mob to eat/raid crops out of farms until they are full.
    /// </summary>
    public partial class BehaviorRaidGarden180
    {
        /// <summary>
        /// Blocks that the mob is looking for to eat
        /// </summary>
        [JsonProperty("blocks", NullValueHandling = NullValueHandling.Ignore)]
        public List<string> Blocks { get; set; }

        /// <summary>
        /// Time in seconds between each time it eats
        /// </summary>
        [JsonProperty("eat_delay", NullValueHandling = NullValueHandling.Ignore)]
        public long? EatDelay { get; set; } = 2;

        /// <summary>
        /// Amount of time in seconds before this mob wants to eat again
        /// </summary>
        [JsonProperty("full_delay", NullValueHandling = NullValueHandling.Ignore)]
        public long? FullDelay { get; set; } = 100;

        /// <summary>
        /// Distance in blocks within the mob considers it has reached the goal. This is the "wiggle
        /// room" to stop the AI from bouncing back and forth trying to reach a specific spot
        /// </summary>
        [JsonProperty("goal_radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? GoalRadius { get; set; } = 0.5;

        /// <summary>
        /// Time in seconds before starting to eat/raid once it arrives at it
        /// </summary>
        [JsonProperty("initial_eat_delay", NullValueHandling = NullValueHandling.Ignore)]
        public long? InitialEatDelay { get; set; } = 0;

        /// <summary>
        /// Maximum number of things this entity wants to eat
        /// </summary>
        [JsonProperty("max_to_eat", NullValueHandling = NullValueHandling.Ignore)]
        public long? MaxToEat { get; set; } = 6;

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("search_height", NullValueHandling = NullValueHandling.Ignore)]
        public long? SearchHeight { get; set; } = 0;

        /// <summary>
        /// Distance in blocks the mob will look for crops to eat
        /// </summary>
        [JsonProperty("search_range", NullValueHandling = NullValueHandling.Ignore)]
        public long? SearchRange { get; set; } = 0;

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }
    }

    /// <summary>
    /// Allows the mob to randomly break surface of the water.
    /// </summary>
    public partial class MinecraftBehaviorRandomBreachClass
    {
        /// <summary>
        /// Time in seconds the mob has to wait before using the goal again
        /// </summary>
        [JsonProperty("cooldown_time", NullValueHandling = NullValueHandling.Ignore)]
        public double? CooldownTime { get; set; } = 0;

        /// <summary>
        /// A random value to determine when to randomly move somewhere. This has a 1/interval chance
        /// to choose this goal
        /// </summary>
        [JsonProperty("interval", NullValueHandling = NullValueHandling.Ignore)]
        public long? Interval { get; set; } = 120;

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }

        /// <summary>
        /// Distance in blocks on ground that the mob will look for a new spot to move to. Must be at
        /// least 1
        /// </summary>
        [JsonProperty("xz_dist", NullValueHandling = NullValueHandling.Ignore)]
        public long? XzDist { get; set; } = 10;

        /// <summary>
        /// Distance in blocks that the mob will look up or down for a new spot to move to. Must be
        /// at least 1
        /// </summary>
        [JsonProperty("y_dist", NullValueHandling = NullValueHandling.Ignore)]
        public long? YDist { get; set; } = 7;
    }

    /// <summary>
    /// Allows a mob to randomly fly around
    /// </summary>
    public partial class BehaviorRandomFly1160
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("avoid_damage_blocks", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AvoidDamageBlocks { get; set; }

        /// <summary>
        /// If true, the mob can stop flying and land on a tree instead of the ground
        /// </summary>
        [JsonProperty("can_land_on_trees", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanLandOnTrees { get; set; } = new bool?();

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }

        /// <summary>
        /// Distance in blocks on ground that the mob will look for a new spot to move to. Must be at
        /// least 1
        /// </summary>
        [JsonProperty("xz_dist", NullValueHandling = NullValueHandling.Ignore)]
        public long? XzDist { get; set; } = 10;

        /// <summary>
        /// Distance in blocks that the mob will look up or down for a new spot to move to. Must be
        /// at least 1
        /// </summary>
        [JsonProperty("y_dist", NullValueHandling = NullValueHandling.Ignore)]
        public long? YDist { get; set; } = 7;

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("y_offset", NullValueHandling = NullValueHandling.Ignore)]
        public long? YOffset { get; set; }
    }

    /// <summary>
    /// Allows the mob to hover around randomly, close to the surface
    /// </summary>
    public partial class BehaviorRandomHover1160
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("hover_height", NullValueHandling = NullValueHandling.Ignore)]
        public List<double> HoverHeight { get; set; }

        /// <summary>
        /// A random value to determine when to randomly move somewhere. This has a 1/interval chance
        /// to choose this goal
        /// </summary>
        [JsonProperty("interval", NullValueHandling = NullValueHandling.Ignore)]
        public long? Interval { get; set; } = 120;

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }

        /// <summary>
        /// Distance in blocks on ground that the mob will look for a new spot to move to. Must be at
        /// least 1
        /// </summary>
        [JsonProperty("xz_dist", NullValueHandling = NullValueHandling.Ignore)]
        public long? XzDist { get; set; } = 10;

        /// <summary>
        /// Distance in blocks that the mob will look up or down for a new spot to move to. Must be
        /// at least 1
        /// </summary>
        [JsonProperty("y_dist", NullValueHandling = NullValueHandling.Ignore)]
        public long? YDist { get; set; } = 7;

        /// <summary>
        /// Height in blocks to add to the selected target position
        /// </summary>
        [JsonProperty("y_offset", NullValueHandling = NullValueHandling.Ignore)]
        public double? YOffset { get; set; } = 0;
    }

    /// <summary>
    /// Allows the mob to randomly look around.
    /// </summary>
    public partial class BehaviorRandomLookAround180
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("look_distance", NullValueHandling = NullValueHandling.Ignore)]
        public double? LookDistance { get; set; }

        /// <summary>
        /// The range of time in seconds the mob will stay looking in a random direction before
        /// looking elsewhere
        /// </summary>
        [JsonProperty("look_time", NullValueHandling = NullValueHandling.Ignore)]
        public List<double> LookTime { get; set; } = new List<double> {2.0,4.0};

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Allows the mob to randomly sit and look around for a duration. Note: Must have a sitting
    /// animation set up to use this.
    /// </summary>
    public partial class BehaviorRandomLookAroundAndSit1160
    {
        /// <summary>
        /// The max amount of unique looks a mob will have while looking around.
        /// </summary>
        [JsonProperty("max_look_count", NullValueHandling = NullValueHandling.Ignore)]
        public long? MaxLookCount { get; set; } = 2;

        /// <summary>
        /// The max amount of time (in ticks) a mob will stay looking at a direction while looking
        /// around.
        /// </summary>
        [JsonProperty("max_look_time", NullValueHandling = NullValueHandling.Ignore)]
        public long? MaxLookTime { get; set; } = 40;

        /// <summary>
        /// The min amount of unique looks a mob will have while looking around.
        /// </summary>
        [JsonProperty("min_look_count", NullValueHandling = NullValueHandling.Ignore)]
        public long? MinLookCount { get; set; } = 1;

        /// <summary>
        /// The min amount of time (in ticks) a mob will stay looking at a direction while looking
        /// around.
        /// </summary>
        [JsonProperty("min_look_time", NullValueHandling = NullValueHandling.Ignore)]
        public long? MinLookTime { get; set; } = 20;

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// The probability of randomly looking around/sitting.
        /// </summary>
        [JsonProperty("probability", NullValueHandling = NullValueHandling.Ignore)]
        public double? Probability { get; set; } = 0.02;
    }

    /// <summary>
    /// Allows the mob to randomly sit for a duration.
    /// </summary>
    public partial class BehaviorRandomSitting180
    {
        /// <summary>
        /// Time in seconds the mob has to wait before using the goal again
        /// </summary>
        [JsonProperty("cooldown", NullValueHandling = NullValueHandling.Ignore)]
        public double? Cooldown { get; set; } = 0;

        /// <summary>
        /// Time in seconds the mob has to wait before using the goal again
        /// </summary>
        [JsonProperty("cooldown_time", NullValueHandling = NullValueHandling.Ignore)]
        public double? CooldownTime { get; set; } = 0;

        /// <summary>
        /// The minimum amount of time in seconds before the mob can stand back up
        /// </summary>
        [JsonProperty("min_sit_time", NullValueHandling = NullValueHandling.Ignore)]
        public double? MinSitTime { get; set; } = 10;

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }

        /// <summary>
        /// This is the chance that the mob will start this goal, from 0 to 1
        /// </summary>
        [JsonProperty("start_chance", NullValueHandling = NullValueHandling.Ignore)]
        public double? StartChance { get; set; } = 0.1;

        /// <summary>
        /// This is the chance that the mob will stop this goal, from 0 to 1
        /// </summary>
        [JsonProperty("stop_chance", NullValueHandling = NullValueHandling.Ignore)]
        public double? StopChance { get; set; } = 0.3;
    }

    /// <summary>
    /// Allows a mob to randomly stroll around.
    /// </summary>
    public partial class BehaviorRandomStroll180
    {
        /// <summary>
        /// A random value to determine when to randomly move somewhere. This has a 1/interval chance
        /// to choose this goal
        /// </summary>
        [JsonProperty("interval", NullValueHandling = NullValueHandling.Ignore)]
        public long? Interval { get; set; } = 120;

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }

        /// <summary>
        /// Distance in blocks on ground that the mob will look for a new spot to move to. Must be at
        /// least 1
        /// </summary>
        [JsonProperty("xz_dist", NullValueHandling = NullValueHandling.Ignore)]
        public long? XzDist { get; set; } = 10;

        /// <summary>
        /// Distance in blocks that the mob will look up or down for a new spot to move to. Must be
        /// at least 1
        /// </summary>
        [JsonProperty("y_dist", NullValueHandling = NullValueHandling.Ignore)]
        public long? YDist { get; set; } = 7;
    }

    /// <summary>
    /// Allows an entity to randomly move through water
    /// </summary>
    public partial class BehaviorRandomSwim180
    {
        /// <summary>
        /// If true, the mob will avoid surface water blocks by swimming below them
        /// </summary>
        [JsonProperty("avoid_surface", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AvoidSurface { get; set; } = new bool?();

        /// <summary>
        /// A random value to determine when to randomly move somewhere. This has a 1/interval chance
        /// to choose this goal
        /// </summary>
        [JsonProperty("interval", NullValueHandling = NullValueHandling.Ignore)]
        public long? Interval { get; set; } = 120;

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }

        /// <summary>
        /// Distance in blocks on ground that the mob will look for a new spot to move to. Must be at
        /// least 1
        /// </summary>
        [JsonProperty("xz_dist", NullValueHandling = NullValueHandling.Ignore)]
        public long? XzDist { get; set; } = 10;

        /// <summary>
        /// Distance in blocks that the mob will look up or down for a new spot to move to. Must be
        /// at least 1
        /// </summary>
        [JsonProperty("y_dist", NullValueHandling = NullValueHandling.Ignore)]
        public long? YDist { get; set; } = 7;
    }

    /// <summary>
    /// Allows the mob to use ranged attacks like shooting arrows.
    /// </summary>
    public partial class BehaviorRangedAttack180
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("attack_interval", NullValueHandling = NullValueHandling.Ignore)]
        public double? AttackInterval { get; set; } = 0;

        /// <summary>
        /// Maximum amount of time in seconds the entity will wait after an attack before launching
        /// another
        /// </summary>
        [JsonProperty("attack_interval_max", NullValueHandling = NullValueHandling.Ignore)]
        public double? AttackIntervalMax { get; set; } = 0;

        /// <summary>
        /// Minimum amount of time in seconds the entity will wait after an attack before launching
        /// another
        /// </summary>
        [JsonProperty("attack_interval_min", NullValueHandling = NullValueHandling.Ignore)]
        public double? AttackIntervalMin { get; set; } = 0;

        /// <summary>
        /// Maximum distance the target can be for this mob to fire. If the target is further away,
        /// this mob will move first before firing
        /// </summary>
        [JsonProperty("attack_radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? AttackRadius { get; set; } = 0;

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("attack_radius_min", NullValueHandling = NullValueHandling.Ignore)]
        public double? AttackRadiusMin { get; set; }

        /// <summary>
        /// Amount of time in seconds between each individual shot when firing multiple shots per
        /// attack
        /// </summary>
        [JsonProperty("burst_interval", NullValueHandling = NullValueHandling.Ignore)]
        public double? BurstInterval { get; set; } = 0;

        /// <summary>
        /// Number of shots fired every time the mob uses a charged attack
        /// </summary>
        [JsonProperty("burst_shots", NullValueHandling = NullValueHandling.Ignore)]
        public long? BurstShots { get; set; } = 1;

        /// <summary>
        /// The minimum amount of time in ticks the mob has to charge before firing a charged attack
        /// </summary>
        [JsonProperty("charge_charged_trigger", NullValueHandling = NullValueHandling.Ignore)]
        public double? ChargeChargedTrigger { get; set; } = 0;

        /// <summary>
        /// The minimum amount of time in ticks for the mob to start charging a charged shot. Must be
        /// greater than 0 to enable burst shots
        /// </summary>
        [JsonProperty("charge_shoot_trigger", NullValueHandling = NullValueHandling.Ignore)]
        public double? ChargeShootTrigger { get; set; } = 0;

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// The allowable FOV the actor will use to determine if it can make a valid ranged attack
        /// </summary>
        [JsonProperty("ranged_fov", NullValueHandling = NullValueHandling.Ignore)]
        public double? RangedFov { get; set; } = 90;

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("target_in_sight_time", NullValueHandling = NullValueHandling.Ignore)]
        public double? TargetInSightTime { get; set; }
    }

    /// <summary>
    /// Allows the villager to stop so another villager can breed with it. Can only be used by a
    /// Villager.
    /// </summary>
    public partial class BehaviorReceiveLove180
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Allows the mob to stay indoors during night time.
    /// </summary>
    public partial class MinecraftBehaviorRestrictOpenDoorClass
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Allows the mob to automatically start avoiding the sun when its a clear day out.
    /// </summary>
    public partial class BehaviorRestrictSun180
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Allows the mob to stay at a certain level when in liquid.
    /// </summary>
    public partial class BehaviorRiseToLiquidLevel1160
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("liquid_y_offset", NullValueHandling = NullValueHandling.Ignore)]
        public double? LiquidYOffset { get; set; }

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("rise_delta", NullValueHandling = NullValueHandling.Ignore)]
        public double? RiseDelta { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("sink_delta", NullValueHandling = NullValueHandling.Ignore)]
        public double? SinkDelta { get; set; }
    }

    /// <summary>
    /// This allows the mob to roll forward.
    /// </summary>
    public partial class BehaviorRoll180
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// The probability that the mob will use the goal.
        /// </summary>
        [JsonProperty("probability", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(FluffyMinMaxValueCheckConverter))]
        public double? Probability { get; set; }
    }

    /// <summary>
    /// Allows the mob to run around aimlessly.
    /// </summary>
    public partial class MinecraftBehaviorRunAroundLikeCrazyClass
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }
    }

    /// <summary>
    /// Allows the a mob to become scared when the weather outside is thundering.
    /// </summary>
    public partial class BehaviorScared180
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// The interval in which a sound will play when active in a 1/delay chance to kick off
        /// </summary>
        [JsonProperty("sound_interval", NullValueHandling = NullValueHandling.Ignore)]
        public long? SoundInterval { get; set; } = 0;
    }

    /// <summary>
    /// Allows the mob to send an event to another mob.
    /// </summary>
    public partial class BehaviorSendEvent1160
    {
        /// <summary>
        /// Time in seconds for the entire event sending process
        /// </summary>
        [JsonProperty("cast_duration", NullValueHandling = NullValueHandling.Ignore)]
        public double? CastDuration { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("event_choices", NullValueHandling = NullValueHandling.Ignore)]
        public List<EventChoiceElement> EventChoices { get; set; }

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// TODO description
        /// </summary>
        [JsonProperty("sequence", NullValueHandling = NullValueHandling.Ignore)]
        public List<EventChoiceSequence> Sequence { get; set; }
    }

    /// <summary>
    /// UNDOCUMENTATED
    /// </summary>
    public partial class EventChoiceElement
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("cast_duration", NullValueHandling = NullValueHandling.Ignore)]
        public double? CastDuration { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("cooldown_time", NullValueHandling = NullValueHandling.Ignore)]
        public double? CooldownTime { get; set; }

        [JsonProperty("filters", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject Filters { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("max_activation_range", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaxActivationRange { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("min_activation_range", NullValueHandling = NullValueHandling.Ignore)]
        public double? MinActivationRange { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("particle_color", NullValueHandling = NullValueHandling.Ignore)]
        public string ParticleColor { get; set; }

        [JsonProperty("sequence", NullValueHandling = NullValueHandling.Ignore)]
        public List<EventChoiceSequence> Sequence { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("start_sound_event", NullValueHandling = NullValueHandling.Ignore)]
        public string StartSoundEvent { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("weight", NullValueHandling = NullValueHandling.Ignore)]
        public long? Weight { get; set; }
    }

    /// <summary>
    /// List of events to send
    /// </summary>
    public partial class EventChoiceSequence
    {
        /// <summary>
        /// Amount of time in seconds before starting this step
        /// </summary>
        [JsonProperty("base_delay", NullValueHandling = NullValueHandling.Ignore)]
        public double? BaseDelay { get; set; } = 0;

        /// <summary>
        /// The event to send to the entity
        /// </summary>
        [JsonProperty("event", NullValueHandling = NullValueHandling.Ignore)]
        public string Event { get; set; } = "";

        /// <summary>
        /// The sound event to play when this step happens
        /// </summary>
        [JsonProperty("sound_event", NullValueHandling = NullValueHandling.Ignore)]
        public string SoundEvent { get; set; } = "";
    }

    /// <summary>
    /// Allows the mob to send an event to another mob.
    /// </summary>
    public partial class BehaviorShareItems180
    {
        /// <summary>
        /// List of entities this mob will share items with
        /// </summary>
        [JsonProperty("entity_types", NullValueHandling = NullValueHandling.Ignore)]
        public EntityTypes180? EntityTypes { get; set; }

        /// <summary>
        /// Distance in blocks within the mob considers it has reached the goal. This is the "wiggle
        /// room" to stop the AI from bouncing back and forth trying to reach a specific spot
        /// </summary>
        [JsonProperty("goal_radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? GoalRadius { get; set; } = 0.5;

        /// <summary>
        /// Maximum distance in blocks this mob will look for entities to share items with
        /// </summary>
        [JsonProperty("max_dist", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaxDist { get; set; } = 0;

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }
    }

    /// <summary>
    /// Allows the mob to go into stone blocks like Silverfish do. Currently it can only be used
    /// by Silverfish.
    /// </summary>
    public partial class BehaviorSilverfishMergeWithStone180
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Allows the mob to alert mobs in nearby blocks to come out. Currently it can only be used
    /// by Silverfish.
    /// </summary>
    public partial class BehaviorSilverfishWakeUpFriends180
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Allows Equine mobs to be Horse Traps and be triggered like them, spawning a lightning
    /// bolt and a bunch of horses when a player is nearby. Can only be used by Horses, Mules,
    /// Donkeys and Skeleton Horses.
    /// </summary>
    public partial class BehaviorSkeletonHorseTrap180
    {
        /// <summary>
        /// Amount of time in seconds the trap exists. After this amount of time is elapsed, the trap
        /// is removed from the world if it hasn't been activated
        /// </summary>
        [JsonProperty("duration", NullValueHandling = NullValueHandling.Ignore)]
        public double? Duration { get; set; } = 1;

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// Distance in blocks that the player has to be within to trigger the horse trap
        /// </summary>
        [JsonProperty("within_radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? WithinRadius { get; set; } = 0;
    }

    /// <summary>
    /// Allows mobs that own a bed to in a village to move to and sleep in it.
    /// </summary>
    public partial class BehaviorSleep180
    {
        /// <summary>
        /// Time in seconds the mob has to wait before using the goal again
        /// </summary>
        [JsonProperty("cooldown_time", NullValueHandling = NullValueHandling.Ignore)]
        public double? CooldownTime { get; set; } = 0;

        /// <summary>
        /// UNDOCUMANTED
        /// </summary>
        [JsonProperty("goal_radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? GoalRadius { get; set; } = 0;

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// The height of the mob's collider while sleeping
        /// </summary>
        [JsonProperty("sleep_collider_height", NullValueHandling = NullValueHandling.Ignore)]
        public double? SleepColliderHeight { get; set; } = 1;

        /// <summary>
        /// The width of the mob's collider while sleeping
        /// </summary>
        [JsonProperty("sleep_collider_width", NullValueHandling = NullValueHandling.Ignore)]
        public double? SleepColliderWidth { get; set; } = 1;

        /// <summary>
        /// The y offset of the mob's collider while sleeping
        /// </summary>
        [JsonProperty("sleep_y_offset", NullValueHandling = NullValueHandling.Ignore)]
        public double? SleepYOffset { get; set; } = 1;

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }

        /// <summary>
        /// The cooldown time in seconds before the goal can be reused after a internal failure or
        /// timeout condition
        /// </summary>
        [JsonProperty("timeout_cooldown", NullValueHandling = NullValueHandling.Ignore)]
        public double? TimeoutCooldown { get; set; } = 8;
    }

    /// <summary>
    /// Can only be used by Slimes and Magma Cubes. Allows the mob to use a melee attack like the
    /// slime's.
    /// </summary>
    public partial class BehaviorSlimeAttack180
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// Allows the actor to be set to persist upon targeting a player
        /// </summary>
        [JsonProperty("set_persistent", NullValueHandling = NullValueHandling.Ignore)]
        public bool? SetPersistent { get; set; } = new bool?();
    }

    /// <summary>
    /// Can only be used by Slimes and Magma Cubes. Controls their ability to float in water /
    /// lava.
    /// </summary>
    public partial class BehaviorSlimeFloat180
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("jump_chance_percentage", NullValueHandling = NullValueHandling.Ignore)]
        public double? JumpChancePercentage { get; set; }

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }
    }

    /// <summary>
    /// Can only be used by Slimes and Magma Cubes. Allows the mob to continuously jump around
    /// like a slime.
    /// </summary>
    public partial class BehaviorSlimeKeepOnJumping180
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }
    }

    /// <summary>
    /// Can only be used by Slimes and Magma Cubes. Allows the mob to move in random directions
    /// like a slime.
    /// </summary>
    public partial class BehaviorSlimeRandomDirection180
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("add_random_time_range", NullValueHandling = NullValueHandling.Ignore)]
        public double? AddRandomTimeRange { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("min_change_direction_time", NullValueHandling = NullValueHandling.Ignore)]
        public double? MinChangeDirectionTime { get; set; }

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("turn_range", NullValueHandling = NullValueHandling.Ignore)]
        public double? TurnRange { get; set; }
    }

    /// <summary>
    /// Allows the mob to take a load off and snack on food that it found nearby.
    /// </summary>
    public partial class BehaviorSnacking180
    {
        /// <summary>
        /// Items that we are interested in snacking on
        /// </summary>
        [JsonProperty("items", NullValueHandling = NullValueHandling.Ignore)]
        public List<string> Items { get; set; }

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// The cooldown time in seconds before the mob is able to snack again
        /// </summary>
        [JsonProperty("snacking_cooldown", NullValueHandling = NullValueHandling.Ignore)]
        public double? SnackingCooldown { get; set; } = 7.5;

        /// <summary>
        /// The minimum time in seconds before the mob is able to snack again
        /// </summary>
        [JsonProperty("snacking_cooldown_min", NullValueHandling = NullValueHandling.Ignore)]
        public double? SnackingCooldownMin { get; set; } = 0.5;

        /// <summary>
        /// This is the chance that the mob will stop snacking, from 0 to 1
        /// </summary>
        [JsonProperty("snacking_stop_chance", NullValueHandling = NullValueHandling.Ignore)]
        public double? SnackingStopChance { get; set; } = 0.0017;
    }

    /// <summary>
    /// Allows the mob to stop and sneeze possibly startling nearby mobs and dropping an item.
    /// </summary>
    public partial class BehaviorSneeze180
    {
        /// <summary>
        /// Time in seconds the mob has to wait before using the goal again
        /// </summary>
        [JsonProperty("cooldown_time", NullValueHandling = NullValueHandling.Ignore)]
        public double? CooldownTime { get; set; } = 0;

        /// <summary>
        /// The probability that the mob will drop an item when it sneezes.
        /// </summary>
        [JsonProperty("drop_item_chance", NullValueHandling = NullValueHandling.Ignore)]
        public double? DropItemChance { get; set; } = 1;

        /// <summary>
        /// List of entity types this mob will startle (cause to jump) when it sneezes.
        /// </summary>
        [JsonProperty("entity_types", NullValueHandling = NullValueHandling.Ignore)]
        public EntityTypes180? EntityTypes { get; set; }

        /// <summary>
        /// Loot table to select dropped items from.
        /// </summary>
        [JsonProperty("loot_table", NullValueHandling = NullValueHandling.Ignore)]
        public string LootTable { get; set; } = "";

        /// <summary>
        /// Sound to play when the sneeze is about to happen.
        /// </summary>
        [JsonProperty("prepare_sound", NullValueHandling = NullValueHandling.Ignore)]
        public string PrepareSound { get; set; } = "";

        /// <summary>
        /// The time in seconds that the mob takes to prepare to sneeze (while the prepare_sound is
        /// playing).
        /// </summary>
        [JsonProperty("prepare_time", NullValueHandling = NullValueHandling.Ignore)]
        public double? PrepareTime { get; set; } = 1;

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// The probability of sneezing. A value of 1.00 is 100%
        /// </summary>
        [JsonProperty("probability", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(PurpleMinMaxValueCheckConverter))]
        public double? Probability { get; set; } = 0.02;

        /// <summary>
        /// Sound to play when the sneeze occurs.
        /// </summary>
        [JsonProperty("sound", NullValueHandling = NullValueHandling.Ignore)]
        public string Sound { get; set; } = "";

        /// <summary>
        /// Distance in blocks that mobs will be startled.
        /// </summary>
        [JsonProperty("within_radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? WithinRadius { get; set; } = 0;
    }

    /// <summary>
    /// Allows the squid to dive down in water. Can only be used by the Squid.
    /// </summary>
    public partial class BehaviorSquidDive180
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Allows the squid to swim away. Can only be used by the Squid.
    /// </summary>
    public partial class BehaviorSquidFlee180
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Allows the squid to swim in place idly. Can only be used by the Squid.
    /// </summary>
    public partial class BehaviorSquidIdle180
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Allows the squid to move away from ground blocks and back to water. Can only be used by
    /// the Squid.
    /// </summary>
    public partial class BehaviorSquidMoveAwayFromGround180
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Allows the squid to stick to the ground when outside water. Can only be used by the Squid.
    /// </summary>
    public partial class BehaviorSquidOutOfWater180
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Allows the mob to stay at a certain level when in liquid.
    /// </summary>
    public partial class BehaviorStalkAndPounceOnTarget1160
    {
        /// <summary>
        /// The amount of time the mob will be interested before pouncing. This happens when the mob
        /// is within range of pouncing
        /// </summary>
        [JsonProperty("interest_time", NullValueHandling = NullValueHandling.Ignore)]
        public double? InterestTime { get; set; } = 2;

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("leap_dist", NullValueHandling = NullValueHandling.Ignore)]
        public double? LeapDist { get; set; }

        /// <summary>
        /// The distance in blocks the mob jumps in the direction of its target
        /// </summary>
        [JsonProperty("leap_distance", NullValueHandling = NullValueHandling.Ignore)]
        public double? LeapDistance { get; set; } = 0.8;

        /// <summary>
        /// The height in blocks the mob jumps when leaping at its target
        /// </summary>
        [JsonProperty("leap_height", NullValueHandling = NullValueHandling.Ignore)]
        public double? LeapHeight { get; set; } = 0.9;

        /// <summary>
        /// The maximum distance away a target can be before the mob gives up on stalking
        /// </summary>
        [JsonProperty("max_stalk_dist", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaxStalkDist { get; set; } = 10;

        /// <summary>
        /// The maximum distance away from the target in blocks to begin pouncing at the target
        /// </summary>
        [JsonProperty("pounce_max_dist", NullValueHandling = NullValueHandling.Ignore)]
        public double? PounceMaxDist { get; set; } = 5;

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// Allows the actor to be set to persist upon targeting a player
        /// </summary>
        [JsonProperty("set_persistent", NullValueHandling = NullValueHandling.Ignore)]
        public bool? SetPersistent { get; set; } = new bool?();

        /// <summary>
        /// The movement speed in which you stalk your target
        /// </summary>
        [JsonProperty("stalk_speed", NullValueHandling = NullValueHandling.Ignore)]
        public double? StalkSpeed { get; set; } = 1.2;

        /// <summary>
        /// The max distance away from the target when landing from the pounce that will still result
        /// in damaging the target
        /// </summary>
        [JsonProperty("strike_dist", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrikeDist { get; set; } = 2;

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("stuck_blocks", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject StuckBlocks { get; set; }

        /// <summary>
        /// The amount of time the mob will be stuck if they fail and land on a block they can be
        /// stuck on
        /// </summary>
        [JsonProperty("stuck_time", NullValueHandling = NullValueHandling.Ignore)]
        public double? StuckTime { get; set; } = 2;
    }

    /// <summary>
    /// Allows the mob to stay put while it is in a sitting state instead of doing something else.
    /// </summary>
    public partial class MinecraftBehaviorStayWhileSittingClass
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Allows the mob to use the polar bear's melee attack.
    /// </summary>
    public partial class BehaviorStompAttack180
    {
        /// <summary>
        /// If true, this mob will attack only one time.
        /// </summary>
        [JsonProperty("attack_once", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AttackOnce { get; set; } = new bool?();

        /// <summary>
        /// Defines the entity types this mob will attack
        /// </summary>
        [JsonProperty("attack_types", NullValueHandling = NullValueHandling.Ignore)]
        public string AttackTypes { get; set; } = "";

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("no_damage_range_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? NoDamageRangeMultiplier { get; set; }

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// The probability of sneezing. A value of 1.00 is 100%
        /// </summary>
        [JsonProperty("probability", NullValueHandling = NullValueHandling.Ignore)]
        public double? Probability { get; set; } = 0.02;

        /// <summary>
        /// Defines the probability the mob will stop fighting. A value of 0 disables randomly
        /// stopping, while a value of 1 defines a 50% chance
        /// </summary>
        [JsonProperty("random_stop_interval", NullValueHandling = NullValueHandling.Ignore)]
        public long? RandomStopInterval { get; set; } = 0;

        /// <summary>
        /// Multiplier for how far outside its box the mob can reach its target (this can be used to
        /// simulate a mob with longer arms by making this bigger)
        /// </summary>
        [JsonProperty("reach_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? ReachMultiplier { get; set; } = 2;

        /// <summary>
        /// If true, this goal will only trigger if the mob can reach its target.
        /// </summary>
        [JsonProperty("require_complete_path", NullValueHandling = NullValueHandling.Ignore)]
        public bool? RequireCompletePath { get; set; } = new bool?();

        /// <summary>
        /// Sound to play when the sneeze occurs.
        /// </summary>
        [JsonProperty("sound", NullValueHandling = NullValueHandling.Ignore)]
        public string Sound { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("stomp_range_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? StompRangeMultiplier { get; set; }

        /// <summary>
        /// If true, this mob will chase after the target as long as it's a valid target
        /// </summary>
        [JsonProperty("track_target", NullValueHandling = NullValueHandling.Ignore)]
        public bool? TrackTarget { get; set; } = new bool?();
    }

    /// <summary>
    /// Allows this mob to stomp turtle eggs
    /// </summary>
    public partial class BehaviorStompTurtleEgg180
    {
        /// <summary>
        /// Distance in blocks within the mob considers it has reached the goal. This is the "wiggle
        /// room" to stop the AI from bouncing back and forth trying to reach a specific spot
        /// </summary>
        [JsonProperty("goal_radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? GoalRadius { get; set; } = 0.5;

        /// <summary>
        /// A random value to determine when to randomly move somewhere. This has a 1/interval chance
        /// to choose this goal
        /// </summary>
        [JsonProperty("interval", NullValueHandling = NullValueHandling.Ignore)]
        public long? Interval { get; set; } = 120;

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// Height in blocks the mob will look for turtle eggs to move towards
        /// </summary>
        [JsonProperty("search_height", NullValueHandling = NullValueHandling.Ignore)]
        public long? SearchHeight { get; set; } = 1;

        /// <summary>
        /// The distance in blocks it will look for turtle eggs to move towards
        /// </summary>
        [JsonProperty("search_range", NullValueHandling = NullValueHandling.Ignore)]
        public long? SearchRange { get; set; } = 0;

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }
    }

    /// <summary>
    /// Allows the mob to stay at a certain level when in liquid.
    /// </summary>
    public partial class BehaviorStrollTowardsVillage1160
    {
        /// <summary>
        /// Time in seconds the mob has to wait before using the goal again
        /// </summary>
        [JsonProperty("cooldown_time", NullValueHandling = NullValueHandling.Ignore)]
        public double? CooldownTime { get; set; } = 0;

        /// <summary>
        /// Distance in blocks within the mob considers it has reached the goal. This is the "wiggle
        /// room" to stop the AI from bouncing back and forth trying to reach a specific spot
        /// </summary>
        [JsonProperty("goal_radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? GoalRadius { get; set; } = 0.5;

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// The distance in blocks to search for points inside villages. If <= 0, find the closest
        /// village regardless of distance.
        /// </summary>
        [JsonProperty("search_range", NullValueHandling = NullValueHandling.Ignore)]
        public long? SearchRange { get; set; } = 0;

        /// <summary>
        /// Movement speed multiplier of the mob when using this AI Goal
        /// </summary>
        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; } = 1;

        /// <summary>
        /// This is the chance that the mob will start this goal, from 0 to 1
        /// </summary>
        [JsonProperty("start_chance", NullValueHandling = NullValueHandling.Ignore)]
        public double? StartChance { get; set; } = 0.1;
    }

    /// <summary>
    /// Allows the mob to attack the player by summoning other entities.
    /// </summary>
    public partial class MinecraftBehaviorSummonEntityClass
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// List of spells for the mob to use to summon entities. Each spell has the following
        /// parameters:
        /// </summary>
        [JsonProperty("summon_choices", NullValueHandling = NullValueHandling.Ignore)]
        public List<SummonChoice> SummonChoices { get; set; }
    }

    public partial class SummonChoice
    {
        /// <summary>
        /// Time in seconds the spell casting will take
        /// </summary>
        [JsonProperty("cast_duration", NullValueHandling = NullValueHandling.Ignore)]
        public double? CastDuration { get; set; }

        /// <summary>
        /// Time in seconds the mob has to wait before using the spell again
        /// </summary>
        [JsonProperty("cooldown_time", NullValueHandling = NullValueHandling.Ignore)]
        public double? CooldownTime { get; set; } = 0;

        /// <summary>
        /// If true, the mob will do the casting animations and render spell particles
        /// </summary>
        [JsonProperty("do_casting", NullValueHandling = NullValueHandling.Ignore)]
        public bool? DoCasting { get; set; } = new bool?();

        [JsonProperty("filters", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject Filters { get; set; }

        /// <summary>
        /// Upper bound of the activation distance in blocks for this spell
        /// </summary>
        [JsonProperty("max_activation_range", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaxActivationRange { get; set; } = -1;

        /// <summary>
        /// Lower bound of the activation distance in blocks for this spell
        /// </summary>
        [JsonProperty("min_activation_range", NullValueHandling = NullValueHandling.Ignore)]
        public double? MinActivationRange { get; set; } = 1;

        /// <summary>
        /// The color of the particles for this spell
        /// </summary>
        [JsonProperty("particle_color", NullValueHandling = NullValueHandling.Ignore)]
        public ParticleColor? ParticleColor { get; set; }

        /// <summary>
        /// List of steps for the spell. Each step has the following parameters:
        /// </summary>
        [JsonProperty("sequence", NullValueHandling = NullValueHandling.Ignore)]
        public List<SummonChoiceSequence> Sequence { get; set; }

        /// <summary>
        /// The sound event to play when using this spell
        /// </summary>
        [JsonProperty("start_sound_event", NullValueHandling = NullValueHandling.Ignore)]
        public string StartSoundEvent { get; set; }

        /// <summary>
        /// The weight of this spell. Controls how likely the mob is to choose this spell when
        /// casting one
        /// </summary>
        [JsonProperty("weight", NullValueHandling = NullValueHandling.Ignore)]
        public double? Weight { get; set; } = 0;
    }

    public partial class SummonChoiceSequence
    {
        /// <summary>
        /// Amount of time in seconds to wait before this step starts
        /// </summary>
        [JsonProperty("base_delay", NullValueHandling = NullValueHandling.Ignore)]
        public double? BaseDelay { get; set; } = 0;

        /// <summary>
        /// Amount of time in seconds before each entity is summoned in this step
        /// </summary>
        [JsonProperty("delay_per_summon", NullValueHandling = NullValueHandling.Ignore)]
        public double? DelayPerSummon { get; set; } = 0;

        /// <summary>
        /// Amount of time in seconds that the spawned entity will be alive for. A value of -1.0
        /// means it will remain alive for as long as it can
        /// </summary>
        [JsonProperty("entity_lifespan", NullValueHandling = NullValueHandling.Ignore)]
        public double? EntityLifespan { get; set; } = -1;

        /// <summary>
        /// The entity type of the entities we will spawn in this step
        /// </summary>
        [JsonProperty("entity_type", NullValueHandling = NullValueHandling.Ignore)]
        public string EntityType { get; set; }

        /// <summary>
        /// Number of entities that will be spawned in this step
        /// </summary>
        [JsonProperty("num_entities_spawned", NullValueHandling = NullValueHandling.Ignore)]
        public long? NumEntitiesSpawned { get; set; } = 1;

        /// <summary>
        /// The base shape of this step. Valid values are circle and line
        /// </summary>
        [JsonProperty("shape", NullValueHandling = NullValueHandling.Ignore)]
        public string Shape { get; set; } = "line";

        /// <summary>
        /// The base size of the entity
        /// </summary>
        [JsonProperty("size", NullValueHandling = NullValueHandling.Ignore)]
        public double? Size { get; set; } = 1;

        /// <summary>
        /// The sound event to play for this step
        /// </summary>
        [JsonProperty("sound_event", NullValueHandling = NullValueHandling.Ignore)]
        public string SoundEvent { get; set; }

        /// <summary>
        /// Maximum number of summoned entities at any given time
        /// </summary>
        [JsonProperty("summon_cap", NullValueHandling = NullValueHandling.Ignore)]
        public long? SummonCap { get; set; } = 0;

        [JsonProperty("summon_cap_radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? SummonCapRadius { get; set; } = 0;

        /// <summary>
        /// The target of the spell. This is where the spell will start (line will start here, circle
        /// will be centered here)
        /// </summary>
        [JsonProperty("target", NullValueHandling = NullValueHandling.Ignore)]
        public string Target { get; set; } = "self";
    }

    /// <summary>
    /// Allows the creeper to swell up when a player is nearby. It can only be used by Creepers.
    /// </summary>
    public partial class MinecraftBehaviorSwellClass
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// This mob starts swelling when a target is at least this many blocks away
        /// </summary>
        [JsonProperty("start_distance", NullValueHandling = NullValueHandling.Ignore)]
        public double? StartDistance { get; set; } = 10;

        /// <summary>
        /// This mob stops swelling when a target has moved away at least this many blocks
        /// </summary>
        [JsonProperty("stop_distance", NullValueHandling = NullValueHandling.Ignore)]
        public double? StopDistance { get; set; } = 2;
    }

    /// <summary>
    /// TODO description
    /// </summary>
    public partial class MinecraftBehaviorSwimIdleClass
    {
        /// <summary>
        /// TODO Description
        /// </summary>
        [JsonProperty("idle_time", NullValueHandling = NullValueHandling.Ignore)]
        public double? IdleTime { get; set; }

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// TODO Description
        /// </summary>
        [JsonProperty("success_rate", NullValueHandling = NullValueHandling.Ignore)]
        public double? SuccessRate { get; set; }
    }

    /// <summary>
    /// Has the fish swim around when they can't pathfind
    /// </summary>
    public partial class MinecraftBehaviorSwimWanderClass
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("interval", NullValueHandling = NullValueHandling.Ignore)]
        public double? Interval { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("look_ahead", NullValueHandling = NullValueHandling.Ignore)]
        public double? LookAhead { get; set; }

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("wander_time", NullValueHandling = NullValueHandling.Ignore)]
        public double? WanderTime { get; set; }
    }

    /// <summary>
    /// UNDOCUMENTATED
    /// </summary>
    public partial class BehaviorSwimWithEntity180
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("catch_up_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? CatchUpMultiplier { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("catch_up_threshold", NullValueHandling = NullValueHandling.Ignore)]
        public double? CatchUpThreshold { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("chance_to_stop", NullValueHandling = NullValueHandling.Ignore)]
        public double? ChanceToStop { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("entity_types", NullValueHandling = NullValueHandling.Ignore)]
        public EntityTypes180? EntityTypes { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("match_direction_threshold", NullValueHandling = NullValueHandling.Ignore)]
        public double? MatchDirectionThreshold { get; set; }

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("search_range", NullValueHandling = NullValueHandling.Ignore)]
        public double? SearchRange { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("state_check_interval", NullValueHandling = NullValueHandling.Ignore)]
        public double? StateCheckInterval { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("stop_distance", NullValueHandling = NullValueHandling.Ignore)]
        public double? StopDistance { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("success_rate", NullValueHandling = NullValueHandling.Ignore)]
        public double? SuccessRate { get; set; }
    }

    /// <summary>
    /// Allows the mob to move to attack a target. The goal ends if it has a horizontal collision
    /// or gets hit. Built to be used with flying mobs.
    /// </summary>
    public partial class BehaviorSwoopAttack180
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("damage_reach", NullValueHandling = NullValueHandling.Ignore)]
        public double? DamageReach { get; set; }

        /// <summary>
        /// Range of time in seconds between uses of this goal.
        /// </summary>
        [JsonProperty("delay_range", NullValueHandling = NullValueHandling.Ignore)]
        public List<double> DelayRange { get; set; } = new List<double> {10.0,20.0};

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }
    }

    /// <summary>
    /// Can only be used by Villagers. Allows the mob to accept flowers from Iron Golems.
    /// </summary>
    public partial class BehaviorTakeFlower180
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// UNDOCUMENTATED
    /// </summary>
    public partial class BehaviorTargetWhenPushed180
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("entity_types", NullValueHandling = NullValueHandling.Ignore)]
        public EntityTypes180? EntityTypes { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("percent_chance", NullValueHandling = NullValueHandling.Ignore)]
        public double? PercentChance { get; set; }

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Allows the mob to be tempted by food they like.
    /// </summary>
    public partial class MinecraftBehaviorTemptClass
    {
        /// <summary>
        /// If true, the mob can stop being tempted if the player moves too fast while close to this
        /// mob
        /// </summary>
        [JsonProperty("can_get_scared", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanGetScared { get; set; } = new bool?();

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("can_tempt_vertically", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanTemptVertically { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("can_tempt_while_ridden", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanTemptWhileRidden { get; set; }

        /// <summary>
        /// List of items this mob is tempted by
        /// </summary>
        [JsonProperty("items", NullValueHandling = NullValueHandling.Ignore)]
        public List<string> Items { get; set; }

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }

        /// <summary>
        /// Distance in blocks this mob can get tempted by a player holding an item they like
        /// </summary>
        [JsonProperty("within_radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? WithinRadius { get; set; } = 0;
    }

    /// <summary>
    /// Allows the mob to look at a player that is holding a tradable item.
    /// </summary>
    public partial class MinecraftBehaviorTradeInterestClass
    {
        /// <summary>
        /// The max time in seconds that the trader will hold an item before attempting to switch for
        /// a different item that takes the same trade
        /// </summary>
        [JsonProperty("carried_item_switch_time", NullValueHandling = NullValueHandling.Ignore)]
        public double? CarriedItemSwitchTime { get; set; } = 2;

        /// <summary>
        /// The time in seconds before the trader can use this goal again
        /// </summary>
        [JsonProperty("cooldown", NullValueHandling = NullValueHandling.Ignore)]
        public double? Cooldown { get; set; } = 2;

        /// <summary>
        /// The max time in seconds that the trader will be interested with showing it's trade items
        /// </summary>
        [JsonProperty("interest_time", NullValueHandling = NullValueHandling.Ignore)]
        public double? InterestTime { get; set; } = 45;

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// The max time in seconds that the trader will wait when you no longer have items to trade
        /// </summary>
        [JsonProperty("remove_item_time", NullValueHandling = NullValueHandling.Ignore)]
        public double? RemoveItemTime { get; set; } = 1;

        /// <summary>
        /// Distance in blocks this mob can be interested by a player holding an item they like
        /// </summary>
        [JsonProperty("within_radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? WithinRadius { get; set; } = 0;
    }

    /// <summary>
    /// Allows the player to trade with this mob.
    /// </summary>
    public partial class BehaviorTradeWithPlayer180
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Allows the mob to target the same entity its owner is targeting.
    /// </summary>
    public partial class BehaviorVexCopyOwnerTarget180
    {
        /// <summary>
        /// List of entities this mob can copy the owner from.
        /// </summary>
        [JsonProperty("entity_types", NullValueHandling = NullValueHandling.Ignore)]
        public EntityTypes180? EntityTypes { get; set; }

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Allows the mob to target the same entity its owner is targeting.
    /// </summary>
    public partial class BehaviorVexRandomMove180
    {
        /// <summary>
        /// List of entities this mob can copy the owner from.
        /// </summary>
        [JsonProperty("entity_types", NullValueHandling = NullValueHandling.Ignore)]
        public EntityTypes180? EntityTypes { get; set; }

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Allows the wither to launch random attacks. Can only be used by the Wither Boss.
    /// </summary>
    public partial class BehaviorWitherRandomAttackPosGoal180
    {
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// Allows the wither to launch random attacks. Can only be used by the Wither Boss.
    /// </summary>
    public partial class BehaviorWitherTargetHighestDamage180
    {
        /// <summary>
        /// List of entity types the wither takes into account to find who dealt the most damage to it
        /// </summary>
        [JsonProperty("entity_types", NullValueHandling = NullValueHandling.Ignore)]
        public EntityTypes180? EntityTypes { get; set; }

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    }

    /// <summary>
    /// TODO description
    /// </summary>
    public partial class BehaviorWork180
    {
        /// <summary>
        /// The amount of ticks the NPC will stay in their the work location
        /// </summary>
        [JsonProperty("active_time", NullValueHandling = NullValueHandling.Ignore)]
        public long? ActiveTime { get; set; } = 0;

        /// <summary>
        /// If true, this entity can work when their jobsite POI is being rained on.
        /// </summary>
        [JsonProperty("can_work_in_rain", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanWorkInRain { get; set; } = new bool?();

        /// <summary>
        /// The amount of ticks the goal will be on cooldown before it can be used again
        /// </summary>
        [JsonProperty("goal_cooldown", NullValueHandling = NullValueHandling.Ignore)]
        public long? GoalCooldown { get; set; } = 0;

        /// <summary>
        /// Event to run when the mob reaches their jobsite and finishes working.
        /// </summary>
        [JsonProperty("on_arrival", NullValueHandling = NullValueHandling.Ignore)]
        public Event? OnArrival { get; set; }

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// The max interval in which a sound will play
        /// </summary>
        [JsonProperty("sound_delay_max", NullValueHandling = NullValueHandling.Ignore)]
        public long? SoundDelayMax { get; set; } = 0;

        /// <summary>
        /// The min interval in which a sound will play
        /// </summary>
        [JsonProperty("sound_delay_min", NullValueHandling = NullValueHandling.Ignore)]
        public long? SoundDelayMin { get; set; } = 0;

        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; }

        /// <summary>
        /// If "can_work_in_rain" is false, this is the maximum number of ticks left in the goal
        /// where rain will not interrupt the goal
        /// </summary>
        [JsonProperty("work_in_rain_tolerance", NullValueHandling = NullValueHandling.Ignore)]
        public long? WorkInRainTolerance { get; set; } = -1;
    }

    /// <summary>
    /// Fires off a specified event when a block in the block list is broken within the sensor
    /// range.
    /// </summary>
    public partial class BlockSensor1160
    {
        /// <summary>
        /// TODO description
        /// </summary>
        [JsonProperty("on_break", NullValueHandling = NullValueHandling.Ignore)]
        public List<OnBlockBroken> OnBreak { get; set; }

        /// <summary>
        /// TODO
        /// </summary>
        [JsonProperty("sensor_radius", NullValueHandling = NullValueHandling.Ignore)]
        public long? SensorRadius { get; set; }
    }

    public partial class OnBlockBroken
    {
        /// <summary>
        /// TODO
        /// </summary>
        [JsonProperty("block_list", NullValueHandling = NullValueHandling.Ignore)]
        public List<string> BlockList { get; set; }

        /// <summary>
        /// On block broken
        /// </summary>
        [JsonProperty("on_block_broken", NullValueHandling = NullValueHandling.Ignore)]
        public string OnBlockBrokenOnBlockBroken { get; set; }
    }

    /// <summary>
    /// Defines the conditions and behavior of a rideable entity's boost
    /// </summary>
    public partial class Boostable1160
    {
        /// <summary>
        /// List of items that can be used to boost while riding this entity
        /// </summary>
        [JsonProperty("boost_items", NullValueHandling = NullValueHandling.Ignore)]
        public List<BoostItem> BoostItems { get; set; }

        /// <summary>
        /// Time in seconds for the boost.
        /// </summary>
        [JsonProperty("duration", NullValueHandling = NullValueHandling.Ignore)]
        public double? Duration { get; set; } = 3;

        /// <summary>
        /// Factor by which the entity's normal speed increases. E.g. 2.0 means go twice as fast.
        /// </summary>
        [JsonProperty("speed_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedMultiplier { get; set; } = 1;
    }

    /// <summary>
    /// List of items that can be used to boost while riding this entity.
    /// </summary>
    public partial class BoostItem
    {
        /// <summary>
        /// This is the damage that the item will take each time it is used.
        /// </summary>
        [JsonProperty("damage", NullValueHandling = NullValueHandling.Ignore)]
        public long? Damage { get; set; } = 1;

        /// <summary>
        /// Name of the item that can be used to boost.
        /// </summary>
        [JsonProperty("item", NullValueHandling = NullValueHandling.Ignore)]
        public string Item { get; set; } = "";

        /// <summary>
        /// The item used to boost will become this item once it is used up.
        /// </summary>
        [JsonProperty("replace_item", NullValueHandling = NullValueHandling.Ignore)]
        public string ReplaceItem { get; set; } = "";
    }

    /// <summary>
    /// The current state of the boss for updating the boss HUD
    /// </summary>
    public partial class Boss180
    {
        /// <summary>
        /// The max distance from the boss at which the boss's health bar is present on the players
        /// screen.
        /// </summary>
        [JsonProperty("hud_range", NullValueHandling = NullValueHandling.Ignore)]
        public long? HudRange { get; set; } = 55;

        /// <summary>
        /// The name that will be displayed above the boss's health bar.
        /// </summary>
        [JsonProperty("name", NullValueHandling = NullValueHandling.Ignore)]
        public string Name { get; set; } = "";

        /// <summary>
        /// Whether the sky should darken in the presence of the boss.
        /// </summary>
        [JsonProperty("should_darken_sky", NullValueHandling = NullValueHandling.Ignore)]
        public bool? ShouldDarkenSky { get; set; } = new bool?();
    }

    /// <summary>
    /// Specifies the blocks that this entity can break as it moves around.
    /// </summary>
    public partial class BehaviorBreakBlocks180
    {
        /// <summary>
        /// A list of the blocks that can be broken as this entity moves around
        /// </summary>
        [JsonProperty("breakable_blocks", NullValueHandling = NullValueHandling.Ignore)]
        public List<string> BreakableBlocks { get; set; }
    }

    /// <summary>
    /// Defines what blocks this entity can breathe in and gives them the ability to suffocate.
    /// </summary>
    public partial class Breathable180
    {
        /// <summary>
        /// List of blocks this entity can breathe in, in addition to the above
        /// </summary>
        [JsonProperty("breathe_blocks", NullValueHandling = NullValueHandling.Ignore)]
        public List<string> Breathable180_BreatheBlocks { get; set; }

        /// <summary>
        /// List of blocks this entity can breathe in, in addition to the above
        /// </summary>
        [JsonProperty("breatheBlocks", NullValueHandling = NullValueHandling.Ignore)]
        public List<string> BreatheBlocks { get; set; }

        /// <summary>
        /// If true, this entity can breathe in air
        /// </summary>
        [JsonProperty("breathes_air", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Breathable180_BreathesAir { get; set; } = new bool?();

        /// <summary>
        /// If true, this entity can breathe in lava
        /// </summary>
        [JsonProperty("breathes_lava", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Breathable180_BreathesLava { get; set; } = new bool?();

        /// <summary>
        /// If true, this entity can breathe in solid blocks
        /// </summary>
        [JsonProperty("breathes_solids", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Breathable180_BreathesSolids { get; set; } = new bool?();

        /// <summary>
        /// If true, this entity can breathe in water
        /// </summary>
        [JsonProperty("breathes_water", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Breathable180_BreathesWater { get; set; } = new bool?();

        /// <summary>
        /// If true, this entity can breathe in air
        /// </summary>
        [JsonProperty("breathesAir", NullValueHandling = NullValueHandling.Ignore)]
        public bool? BreathesAir { get; set; } = new bool?();

        /// <summary>
        /// If true, this entity can breathe in lava
        /// </summary>
        [JsonProperty("breathesLava", NullValueHandling = NullValueHandling.Ignore)]
        public bool? BreathesLava { get; set; } = new bool?();

        /// <summary>
        /// If true, this entity can breathe in solid blocks
        /// </summary>
        [JsonProperty("breathesSolids", NullValueHandling = NullValueHandling.Ignore)]
        public bool? BreathesSolids { get; set; } = new bool?();

        /// <summary>
        /// If true, this entity can breathe in water
        /// </summary>
        [JsonProperty("breathesWater", NullValueHandling = NullValueHandling.Ignore)]
        public bool? BreathesWater { get; set; } = new bool?();

        /// <summary>
        /// If true, this entity will have visible bubbles while in water
        /// </summary>
        [JsonProperty("generates_bubbles", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Breathable180_GeneratesBubbles { get; set; } = new bool?();

        /// <summary>
        /// If true, this entity will have visible bubbles while in water
        /// </summary>
        [JsonProperty("generatesBubbles", NullValueHandling = NullValueHandling.Ignore)]
        public bool? GeneratesBubbles { get; set; } = new bool?();

        /// <summary>
        /// Time in seconds to recover breath to maximum
        /// </summary>
        [JsonProperty("inhale_time", NullValueHandling = NullValueHandling.Ignore)]
        public double? Breathable180_InhaleTime { get; set; } = 0;

        /// <summary>
        /// Time in seconds to recover breath to maximum
        /// </summary>
        [JsonProperty("inhaleTime", NullValueHandling = NullValueHandling.Ignore)]
        public double? InhaleTime { get; set; } = 0;

        /// <summary>
        /// List of blocks this entity can't breathe in, in addition to the above
        /// </summary>
        [JsonProperty("non_breathe_blocks", NullValueHandling = NullValueHandling.Ignore)]
        public List<string> Breathable180_NonBreatheBlocks { get; set; }

        /// <summary>
        /// List of blocks this entity can't breathe in, in addition to the above
        /// </summary>
        [JsonProperty("nonBreatheBlocks", NullValueHandling = NullValueHandling.Ignore)]
        public List<string> NonBreatheBlocks { get; set; }

        /// <summary>
        /// Time in seconds between suffocation damage
        /// </summary>
        [JsonProperty("suffocate_time", NullValueHandling = NullValueHandling.Ignore)]
        public long? Breathable180_SuffocateTime { get; set; } = -20;

        /// <summary>
        /// Time in seconds between suffocation damage
        /// </summary>
        [JsonProperty("suffocateTime", NullValueHandling = NullValueHandling.Ignore)]
        public long? SuffocateTime { get; set; } = -20;

        /// <summary>
        /// Time in seconds the entity can hold its breath
        /// </summary>
        [JsonProperty("total_supply", NullValueHandling = NullValueHandling.Ignore)]
        public long? Breathable180_TotalSupply { get; set; } = 15;

        /// <summary>
        /// Time in seconds the entity can hold its breath
        /// </summary>
        [JsonProperty("totalSupply", NullValueHandling = NullValueHandling.Ignore)]
        public long? TotalSupply { get; set; } = 15;
    }

    /// <summary>
    /// Specifies the blocks that this entity can break as it moves around.
    /// </summary>
    public partial class Breedable1160
    {
        /// <summary>
        /// If true, entities can breed while sitting.
        /// </summary>
        [JsonProperty("allow_sitting", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AllowSitting { get; set; } = new bool?();

        /// <summary>
        /// If true, the entities will blend their attributes in the offspring after they breed. For
        /// example, horses blend their health, movement, and jump_strength in their offspring.
        /// </summary>
        [JsonProperty("blend_attributes", NullValueHandling = NullValueHandling.Ignore)]
        public bool? BlendAttributes { get; set; } = new bool?();

        /// <summary>
        /// Time in seconds before the Entity can breed again.
        /// </summary>
        [JsonProperty("breed_cooldown", NullValueHandling = NullValueHandling.Ignore)]
        public double? BreedCooldown { get; set; } = 60;

        /// <summary>
        /// The list of items that can be used to get the entity into the 'love' state
        /// </summary>
        [JsonProperty("breed_items", NullValueHandling = NullValueHandling.Ignore)]
        public Items? BreedItems { get; set; }

        /// <summary>
        /// The list of entity definitions that this entity can breed with.
        /// </summary>
        [JsonProperty("breeds_with", NullValueHandling = NullValueHandling.Ignore)]
        public BreedsWith? BreedsWith { get; set; }

        /// <summary>
        /// If true, the entity will become pregnant instead of spawning a baby.
        /// </summary>
        [JsonProperty("causes_pregnancy", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CausesPregnancy { get; set; } = new bool?();

        /// <summary>
        /// Determines how likely the baby of parents with the same variant will deny that variant
        /// and take a random variant within the given range instead.
        /// </summary>
        [JsonProperty("deny_parents_variant", NullValueHandling = NullValueHandling.Ignore)]
        public DenyParentsVariant DenyParentsVariant { get; set; }

        /// <summary>
        /// The list of nearby block requirements to get the entity into the 'love' state.
        /// </summary>
        [JsonProperty("environment_requirements", NullValueHandling = NullValueHandling.Ignore)]
        public EnvironmentRequirements? EnvironmentRequirements { get; set; }

        /// <summary>
        /// Chance that up to 16 babies will spawn between 0.0 and 1.0, where 1.0 is 100%.
        /// </summary>
        [JsonProperty("extra_baby_chance", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(PurpleMinMaxValueCheckConverter))]
        public double? ExtraBabyChance { get; set; } = 0;

        /// <summary>
        /// If true, the babies will be automatically tamed if its parents are
        /// </summary>
        [JsonProperty("inherit_tamed", NullValueHandling = NullValueHandling.Ignore)]
        public bool? InheritTamed { get; set; } = new bool?();

        /// <summary>
        /// The filters to run when attempting to fall in love.
        /// </summary>
        [JsonProperty("love_filters", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject LoveFilters { get; set; }

        /// <summary>
        /// Determines how likely the babies are to NOT inherit one of their parent's variances.
        /// Values are between 0.0 and 1.0, with a higher number meaning more likely to mutate.
        /// </summary>
        [JsonProperty("mutation_factor", NullValueHandling = NullValueHandling.Ignore)]
        public MutationFactor MutationFactor { get; set; }

        /// <summary>
        /// If true, the entity needs to be at full health before it can breed.
        /// </summary>
        [JsonProperty("require_full_health", NullValueHandling = NullValueHandling.Ignore)]
        public bool? RequireFullHealth { get; set; } = new bool?();

        /// <summary>
        /// If true, the entities need to be tamed first before they can breed.
        /// </summary>
        [JsonProperty("require_tame", NullValueHandling = NullValueHandling.Ignore)]
        public bool? RequireTame { get; set; } = new bool?();
    }

    /// <summary>
    /// An entity definitions that this entity can breed with.
    /// </summary>
    public partial class BreedsWithElement
    {
        /// <summary>
        /// The entity definition of this entity's babies.
        /// </summary>
        [JsonProperty("baby_type", NullValueHandling = NullValueHandling.Ignore)]
        public string BabyType { get; set; }

        /// <summary>
        /// Event to run when this entity breeds.
        /// </summary>
        [JsonProperty("breed_event", NullValueHandling = NullValueHandling.Ignore)]
        public Event? BreedEvent { get; set; }

        /// <summary>
        /// The entity definition of this entity's mate.
        /// </summary>
        [JsonProperty("mate_type", NullValueHandling = NullValueHandling.Ignore)]
        public string MateType { get; set; }
    }

    /// <summary>
    /// An entity definitions that this entity can breed with.
    /// </summary>
    public partial class PurpleBreedsWithSpec
    {
        /// <summary>
        /// The entity definition of this entity's babies.
        /// </summary>
        [JsonProperty("baby_type", NullValueHandling = NullValueHandling.Ignore)]
        public string BabyType { get; set; }

        /// <summary>
        /// Event to run when this entity breeds.
        /// </summary>
        [JsonProperty("breed_event", NullValueHandling = NullValueHandling.Ignore)]
        public Event? BreedEvent { get; set; }

        /// <summary>
        /// The entity definition of this entity's mate.
        /// </summary>
        [JsonProperty("mate_type", NullValueHandling = NullValueHandling.Ignore)]
        public string MateType { get; set; }
    }

    /// <summary>
    /// Determines how likely the baby of parents with the same variant will deny that variant
    /// and take a random variant within the given range instead.
    /// </summary>
    public partial class DenyParentsVariant
    {
        /// <summary>
        /// The percentage chance of denying the parents' variant.
        /// </summary>
        [JsonProperty("chance", NullValueHandling = NullValueHandling.Ignore)]
        public double? Chance { get; set; } = 0;

        /// <summary>
        /// The inclusive maximum of the variant range.
        /// </summary>
        [JsonProperty("max_variant", NullValueHandling = NullValueHandling.Ignore)]
        public long? MaxVariant { get; set; } = 0;

        /// <summary>
        /// The inclusive minimum of the variant range.
        /// </summary>
        [JsonProperty("min_variant", NullValueHandling = NullValueHandling.Ignore)]
        public long? MinVariant { get; set; } = 0;
    }

    /// <summary>
    /// A nearby block requirements to get the entity into the 'love' state.
    /// </summary>
    public partial class EnvironmentRequirementElement
    {
        /// <summary>
        /// The block types required nearby for the entity to breed.
        /// </summary>
        [JsonProperty("blocks", NullValueHandling = NullValueHandling.Ignore)]
        public MinglePartnerType? Blocks { get; set; }

        /// <summary>
        /// The number of the required block types nearby for the entity to breed.
        /// </summary>
        [JsonProperty("count", NullValueHandling = NullValueHandling.Ignore)]
        public double? Count { get; set; }

        /// <summary>
        /// How many blocks radius from the mob's center to search in for the required blocks.
        /// Bounded between 0 and 16.
        /// </summary>
        [JsonProperty("radius", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(FluffyMinMaxValueCheckConverter))]
        public double? Radius { get; set; }
    }

    /// <summary>
    /// A nearby block requirements to get the entity into the 'love' state.
    /// </summary>
    public partial class EnvironmentRequirementsClass
    {
        /// <summary>
        /// The block types required nearby for the entity to breed.
        /// </summary>
        [JsonProperty("blocks", NullValueHandling = NullValueHandling.Ignore)]
        public MinglePartnerType? Blocks { get; set; }

        /// <summary>
        /// The number of the required block types nearby for the entity to breed.
        /// </summary>
        [JsonProperty("count", NullValueHandling = NullValueHandling.Ignore)]
        public double? Count { get; set; }

        /// <summary>
        /// How many blocks radius from the mob's center to search in for the required blocks.
        /// Bounded between 0 and 16.
        /// </summary>
        [JsonProperty("radius", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(FluffyMinMaxValueCheckConverter))]
        public double? Radius { get; set; }
    }

    /// <summary>
    /// Determines how likely the babies are to NOT inherit one of their parent's variances.
    /// Values are between 0.0 and 1.0, with a higher number meaning more likely to mutate.
    /// </summary>
    public partial class MutationFactor
    {
        /// <summary>
        /// The percentage chance of a mutation on the entity's color.
        /// </summary>
        [JsonProperty("color", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(PurpleMinMaxValueCheckConverter))]
        public double? Color { get; set; } = 0;

        /// <summary>
        /// The percentage chance of a mutation on the entity's extra variant type.
        /// </summary>
        [JsonProperty("extra_variant", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(PurpleMinMaxValueCheckConverter))]
        public double? ExtraVariant { get; set; } = 0;

        /// <summary>
        /// The percentage chance of a mutation on the entity's variant type.
        /// </summary>
        [JsonProperty("variant", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(PurpleMinMaxValueCheckConverter))]
        public double? Variant { get; set; } = 0;
    }

    /// <summary>
    /// Specifies if/how a mob burns in daylight.
    /// </summary>
    public partial class Bribeable180
    {
        /// <summary>
        /// Time in seconds before the Entity can be bribed again
        /// </summary>
        [JsonProperty("bribe_cooldown", NullValueHandling = NullValueHandling.Ignore)]
        public double? BribeCooldown { get; set; } = 2;

        /// <summary>
        /// The list of items that can be used to bribe the entity
        /// </summary>
        [JsonProperty("bribe_items", NullValueHandling = NullValueHandling.Ignore)]
        public List<string> BribeItems { get; set; }
    }

    /// <summary>
    /// Enables an entity to float on the specified liquid blocks.
    /// </summary>
    public partial class Buoyant1160
    {
        /// <summary>
        /// Applies gravity each tick. Causes more of a wave simulation, but will cause more gravity
        /// to be applied outside liquids.
        /// </summary>
        [JsonProperty("apply_gravity", NullValueHandling = NullValueHandling.Ignore)]
        public bool? ApplyGravity { get; set; } = new bool?();

        /// <summary>
        /// Base buoyancy used to calculate how much will a mob float.
        /// </summary>
        [JsonProperty("base_buoyancy", NullValueHandling = NullValueHandling.Ignore)]
        public double? BaseBuoyancy { get; set; } = 1;

        /// <summary>
        /// Probability for a big wave hitting the entity. Only used if `simulate_waves` is true.
        /// </summary>
        [JsonProperty("big_wave_probability", NullValueHandling = NullValueHandling.Ignore)]
        public double? BigWaveProbability { get; set; } = 0.03;

        /// <summary>
        /// Multiplier for the speed to make a big wave. Triggered depending on
        /// 'big_wave_probability'.
        /// </summary>
        [JsonProperty("big_wave_speed", NullValueHandling = NullValueHandling.Ignore)]
        public double? BigWaveSpeed { get; set; } = 10;

        /// <summary>
        /// How much an actor will be dragged down when the Buoyancy Component is removed.
        /// </summary>
        [JsonProperty("drag_down_on_buoyancy_removed", NullValueHandling = NullValueHandling.Ignore)]
        public double? DragDownOnBuoyancyRemoved { get; set; } = 0;

        /// <summary>
        /// List of blocks this entity can float on. Must be a liquid block.
        /// </summary>
        [JsonProperty("liquid_blocks", NullValueHandling = NullValueHandling.Ignore)]
        public List<string> LiquidBlocks { get; set; }

        /// <summary>
        /// Should the movement simulate waves going through.
        /// </summary>
        [JsonProperty("simulate_waves", NullValueHandling = NullValueHandling.Ignore)]
        public bool? SimulateWaves { get; set; } = new bool?();
    }

    public partial class BurnsInDaylight180_Class
    {
    }

    /// <summary>
    /// Allows this entity to climb up ladders.
    /// </summary>
    public partial class CanClimb180
    {
    }

    /// <summary>
    /// Marks the entity as being able to fly, the pathfinder won't be restricted to paths where
    /// a solid block is required underneath it.
    /// </summary>
    public partial class CanFly180
    {
        /// <summary>
        /// TODO description: value
        /// </summary>
        [JsonProperty("value", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Value { get; set; } = new bool?();
    }

    /// <summary>
    /// Allows the entity to power jump like the horse does in vanilla.
    /// </summary>
    public partial class CanPowerJump180
    {
    }

    /// <summary>
    /// Specifies hunt celebration behaviour.
    /// </summary>
    public partial class CelebrateHunt1160
    {
        /// <summary>
        /// If true, celebration will be broadcasted to other entities in the radius.
        /// </summary>
        [JsonProperty("broadcast", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Broadcast { get; set; } = new bool?();

        /// <summary>
        /// The sound event to play when the mob is celebrating
        /// </summary>
        [JsonProperty("celebrate_sound", NullValueHandling = NullValueHandling.Ignore)]
        public string CelebrateSound { get; set; } = "";

        /// <summary>
        /// The list of conditions that target of hunt must satisfy to initiate celebration.
        /// </summary>
        [JsonProperty("celebration_targets", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject CelebrationTargets { get; set; }

        /// <summary>
        /// Duration, in seconds, of celebration
        /// </summary>
        [JsonProperty("duration", NullValueHandling = NullValueHandling.Ignore)]
        public long? Duration { get; set; } = 4;

        /// <summary>
        /// If broadcast is enabled, specifies the radius in which it will notify other entities for
        /// celebration.
        /// </summary>
        [JsonProperty("radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? Radius { get; set; } = 16;

        /// <summary>
        /// The range of time in seconds to randomly wait before playing the sound again
        /// </summary>
        [JsonProperty("sound_interval", NullValueHandling = NullValueHandling.Ignore)]
        public SoundIntervalUnion? SoundInterval { get; set; } = 0;
    }

    /// <summary>
    /// Sets the width and height of the Entity's collision box.
    /// </summary>
    public partial class CollisionBox180
    {
        /// <summary>
        /// Height of the collision box in blocks. A negative value will be assumed to be 0
        /// </summary>
        [JsonProperty("height", NullValueHandling = NullValueHandling.Ignore)]
        public double? Height { get; set; } = 1;

        /// <summary>
        /// Width and Depth of the collision box in blocks. A negative value will be assumed to be 0
        /// </summary>
        [JsonProperty("width", NullValueHandling = NullValueHandling.Ignore)]
        public double? Width { get; set; } = 1;
    }

    /// <summary>
    /// Defines the entity's color. Only works on vanilla entities that have predefined color
    /// values (sheep, llama, shulker).
    /// </summary>
    public partial class Color180
    {
        /// <summary>
        /// The Palette Color value of the entity
        /// </summary>
        [JsonProperty("value", NullValueHandling = NullValueHandling.Ignore)]
        public long? Value { get; set; } = 0;
    }

    /// <summary>
    /// Defines the entity's second texture color. Only works on vanilla entities that have a
    /// second predefined color values (tropical fish).
    /// </summary>
    public partial class Color2180
    {
        /// <summary>
        /// The second Palette Color value of the entity
        /// </summary>
        [JsonProperty("value", NullValueHandling = NullValueHandling.Ignore)]
        public long? Value { get; set; } = 0;
    }

    /// <summary>
    /// Defines the Conditional Spatial Update Bandwidth Optimizations of this entity.
    /// </summary>
    public partial class ConditionalBandwidthOptimization180
    {
        /// <summary>
        /// The object containing the conditional bandwidth optimization values.
        /// </summary>
        [JsonProperty("conditional_values", NullValueHandling = NullValueHandling.Ignore)]
        public List<ConditionalValue> ConditionalValues { get; set; }

        /// <summary>
        /// The object containing the default bandwidth optimization values.
        /// </summary>
        [JsonProperty("default_values", NullValueHandling = NullValueHandling.Ignore)]
        public DefaultValues DefaultValues { get; set; }
    }

    /// <summary>
    /// The object containing the conditional bandwidth optimization values.
    /// </summary>
    public partial class ConditionalValue
    {
        /// <summary>
        /// Conditions that must be met for these optimization values to be used.
        /// </summary>
        [JsonProperty("conditional_values", NullValueHandling = NullValueHandling.Ignore)]
        public List<CustomFilterObject> ConditionalValues { get; set; }

        /// <summary>
        /// In relation to the optimization value, determines the maximum ticks spatial update
        /// packets can be not sent.
        /// </summary>
        [JsonProperty("max_dropped_ticks", NullValueHandling = NullValueHandling.Ignore)]
        public long? MaxDroppedTicks { get; set; }

        /// <summary>
        /// The maximum distance considered during bandwidth optimizations. Any value below the max
        /// is interpolated to find optimization, and any value greater than or equal to this max
        /// results in max optimization.
        /// </summary>
        [JsonProperty("max_optimized_distance", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaxOptimizedDistance { get; set; }

        /// <summary>
        /// When set to true, smaller motion packets will be sent during drop packet intervals,
        /// resulting in the same amount of packets being sent as without optimizations but with much
        /// less data being sent. This should be used when actors are travelling very quickly or
        /// teleporting to prevent visual oddities.
        /// </summary>
        [JsonProperty("use_motion_prediction_hints", NullValueHandling = NullValueHandling.Ignore)]
        public bool? UseMotionPredictionHints { get; set; }
    }

    /// <summary>
    /// The object containing the default bandwidth optimization values.
    /// </summary>
    public partial class DefaultValues
    {
        /// <summary>
        /// In relation to the optimization value, determines the maximum ticks spatial update
        /// packets can be not sent.
        /// </summary>
        [JsonProperty("max_dropped_ticks", NullValueHandling = NullValueHandling.Ignore)]
        public long? MaxDroppedTicks { get; set; }

        /// <summary>
        /// The maximum distance considered during bandwidth optimizations. Any value below the max
        /// is interpolated to find optimization, and any value greater than or equal to this max
        /// results in max optimization.
        /// </summary>
        [JsonProperty("max_optimized_distance", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaxOptimizedDistance { get; set; }

        /// <summary>
        /// When set to true, smaller motion packets will be sent during drop packet intervals,
        /// resulting in the same amount of packets being sent as without optimizations but with much
        /// less data being sent. This should be used when actors are travelling very quickly or
        /// teleporting to prevent visual oddities.
        /// </summary>
        [JsonProperty("use_motion_prediction_hints", NullValueHandling = NullValueHandling.Ignore)]
        public bool? UseMotionPredictionHints { get; set; }
    }

    /// <summary>
    /// List of hitboxes for melee and ranged hits against the entity.
    /// </summary>
    public partial class CustomHitTest1160
    {
        /// <summary>
        /// TODO
        /// </summary>
        [JsonProperty("hitboxes", NullValueHandling = NullValueHandling.Ignore)]
        public List<Hitbox> Hitboxes { get; set; }
    }

    /// <summary>
    /// TODO
    /// </summary>
    public partial class Hitbox
    {
        /// <summary>
        /// TODO
        /// </summary>
        [JsonProperty("height", NullValueHandling = NullValueHandling.Ignore)]
        public double? Height { get; set; }

        /// <summary>
        /// TODO
        /// </summary>
        [JsonProperty("pivot", NullValueHandling = NullValueHandling.Ignore)]
        public List<double> Pivot { get; set; }

        /// <summary>
        /// TODO
        /// </summary>
        [JsonProperty("width", NullValueHandling = NullValueHandling.Ignore)]
        public double? Width { get; set; }
    }

    /// <summary>
    /// Applies defined amount of damage to the entity at specified intervals.
    /// </summary>
    public partial class DamageOverTime180
    {
        /// <summary>
        /// Amount of damage caused each hurt.
        /// </summary>
        [JsonProperty("damage_per_hurt", NullValueHandling = NullValueHandling.Ignore)]
        public long? DamagePerHurt { get; set; } = 1;

        /// <summary>
        /// Time in seconds between damage.
        /// </summary>
        [JsonProperty("time_between_hurt", NullValueHandling = NullValueHandling.Ignore)]
        public double? TimeBetweenHurt { get; set; } = 0;
    }

    /// <summary>
    /// Defines what events to call when this entity is damaged by specific entities or items.
    /// </summary>
    public partial class DamageSensor
    {
        /// <summary>
        /// The list of triggers that fire when the environment conditions match the given filter
        /// criteria.
        /// </summary>
        [JsonProperty("triggers", NullValueHandling = NullValueHandling.Ignore)]
        public DamageTriggers? Triggers { get; set; }
    }

    public partial class DamageTriggerElement
    {
        /// <summary>
        /// Type of damage that triggers the events.
        /// </summary>
        [JsonProperty("cause", NullValueHandling = NullValueHandling.Ignore)]
        public DamageTriggerCause? Cause { get; set; } = DamageTriggerCause.None;

        /// <summary>
        /// A multiplier that modifies the base damage from the damage cause. If deals_damage is true
        /// the multiplier can only reduce the damage the entity will take to a minimum of 1.
        /// </summary>
        [JsonProperty("damage_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? DamageMultiplier { get; set; } = 1;

        /// <summary>
        /// If true, the damage dealt to the entity will take away health from it, set to false to
        /// make the entity ignore that damage.
        /// </summary>
        [JsonProperty("deals_damage", NullValueHandling = NullValueHandling.Ignore)]
        public bool? DealsDamage { get; set; } = new bool?();

        /// <summary>
        /// Specifies filters for entity definitions and events.
        /// </summary>
        [JsonProperty("on_damage", NullValueHandling = NullValueHandling.Ignore)]
        public OnDamage OnDamage { get; set; }
    }

    /// <summary>
    /// Specifies filters for entity definitions and events.
    /// </summary>
    public partial class OnDamage
    {
        /// <summary>
        /// TODO description: event
        /// </summary>
        [JsonProperty("event", NullValueHandling = NullValueHandling.Ignore)]
        public string Event { get; set; }

        [JsonProperty("filters", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject Filters { get; set; }

        /// <summary>
        /// TODO description: target
        /// </summary>
        [JsonProperty("target", NullValueHandling = NullValueHandling.Ignore)]
        public Subject1160? Target { get; set; }
    }

    public partial class DamageTriggersClass
    {
        /// <summary>
        /// Type of damage that triggers the events.
        /// </summary>
        [JsonProperty("cause", NullValueHandling = NullValueHandling.Ignore)]
        public DamageTriggerCause? Cause { get; set; } = DamageTriggerCause.None;

        /// <summary>
        /// A multiplier that modifies the base damage from the damage cause. If deals_damage is true
        /// the multiplier can only reduce the damage the entity will take to a minimum of 1.
        /// </summary>
        [JsonProperty("damage_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? DamageMultiplier { get; set; } = 1;

        /// <summary>
        /// If true, the damage dealt to the entity will take away health from it, set to false to
        /// make the entity ignore that damage.
        /// </summary>
        [JsonProperty("deals_damage", NullValueHandling = NullValueHandling.Ignore)]
        public bool? DealsDamage { get; set; } = new bool?();

        /// <summary>
        /// Specifies filters for entity definitions and events.
        /// </summary>
        [JsonProperty("on_damage", NullValueHandling = NullValueHandling.Ignore)]
        public OnDamage OnDamage { get; set; }
    }

    /// <summary>
    /// Sets this entity's default head rotation angle.
    /// </summary>
    public partial class DefaultLookAngle180
    {
        /// <summary>
        /// Angle in degrees
        /// </summary>
        [JsonProperty("value", NullValueHandling = NullValueHandling.Ignore)]
        public double? Value { get; set; } = 0;
    }

    /// <summary>
    /// Despawns the Actor when the despawn rules or optional filters evaluate to true.
    /// </summary>
    public partial class Despawn1160
    {
        /// <summary>
        /// Determines if "min_range_random_chance" is used in the standard despawn rules
        /// </summary>
        [JsonProperty("despawn_from_chance", NullValueHandling = NullValueHandling.Ignore)]
        public bool? DespawnFromChance { get; set; } = new bool?();

        /// <summary>
        /// TODO description
        /// </summary>
        [JsonProperty("despawn_from_distance", NullValueHandling = NullValueHandling.Ignore)]
        public DespawnFromDistance DespawnFromDistance { get; set; }

        /// <summary>
        /// Determines if the "min_range_inactivity_timer" is used in the standard despawn rules.
        /// </summary>
        [JsonProperty("despawn_from_inactivity", NullValueHandling = NullValueHandling.Ignore)]
        public bool? DespawnFromInactivity { get; set; } = new bool?();

        /// <summary>
        /// Determines if the mob is instantly despawned at the edge of simulation distance in the
        /// standard despawn rules.
        /// </summary>
        [JsonProperty("despawn_from_simulation_edge", NullValueHandling = NullValueHandling.Ignore)]
        public bool? DespawnFromSimulationEdge { get; set; } = new bool?();

        /// <summary>
        /// The list of conditions that must be satisfied before the Actor is despawned. If a filter
        /// is defined then standard despawn rules are ignored.
        /// </summary>
        [JsonProperty("filters", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject Filters { get; set; }

        /// <summary>
        /// The amount of time in seconds that the mob must be inactive.
        /// </summary>
        [JsonProperty("min_range_inactivity_timer", NullValueHandling = NullValueHandling.Ignore)]
        public long? MinRangeInactivityTimer { get; set; } = 30;

        /// <summary>
        /// A random chance between 1 and the given value.
        /// </summary>
        [JsonProperty("min_range_random_chance", NullValueHandling = NullValueHandling.Ignore)]
        public long? MinRangeRandomChance { get; set; } = 800;

        /// <summary>
        /// If true, all entities linked to this entity in a child relationship (eg. leashed) will
        /// also be despawned.
        /// </summary>
        [JsonProperty("remove_child_entities", NullValueHandling = NullValueHandling.Ignore)]
        public bool? RemoveChildEntities { get; set; } = new bool?();
    }

    /// <summary>
    /// TODO description
    /// </summary>
    public partial class DespawnFromDistance
    {
        /// <summary>
        /// Maximum distance for standard despawn rules to instantly despawn the mob.
        /// </summary>
        [JsonProperty("max_distance", NullValueHandling = NullValueHandling.Ignore)]
        public long? MaxDistance { get; set; } = 128;

        /// <summary>
        /// Minimum distance for standard despawn rules to try to despawn the mob.
        /// </summary>
        [JsonProperty("min_distance", NullValueHandling = NullValueHandling.Ignore)]
        public long? MinDistance { get; set; } = 32;
    }

    /// <summary>
    /// UNDOCUMENTATED
    /// </summary>
    public partial class Dweller180
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("can_find_poi", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanFindPoi { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("can_migrate", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanMigrate { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("dweller_role", NullValueHandling = NullValueHandling.Ignore)]
        public string DwellerRole { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("dwelling_type", NullValueHandling = NullValueHandling.Ignore)]
        public string DwellingType { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("first_founding_reward", NullValueHandling = NullValueHandling.Ignore)]
        public long? FirstFoundingReward { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("preferred_profession", NullValueHandling = NullValueHandling.Ignore)]
        public string PreferredProfession { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("update_interval_base", NullValueHandling = NullValueHandling.Ignore)]
        public long? UpdateIntervalBase { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("update_interval_variant", NullValueHandling = NullValueHandling.Ignore)]
        public long? UpdateIntervalVariant { get; set; }
    }

    /// <summary>
    /// Allows the entity to power jump like the horse does in vanilla.
    /// </summary>
    public partial class EconomyTradeTable180
    {
        /// <summary>
        /// Determines when the mob transforms, if the trades should be converted when the new mob
        /// has a economy_trade_table. When the trades are converted, the mob will generate a new
        /// trade list with their new trade table, but then it will try to convert any of the same
        /// trades over to have the same enchantments and user data. For example, if the original has
        /// a Emerald to Enchanted Iron Sword (Sharpness 1), and the new trade also has an Emerald
        /// for Enchanted Iron Sword, then the enchantment will be Sharpness 1.
        /// </summary>
        [JsonProperty("convert_trades_economy", NullValueHandling = NullValueHandling.Ignore)]
        public bool? ConvertTradesEconomy { get; set; } = new bool?();

        /// <summary>
        /// Name to be displayed while trading with this entity
        /// </summary>
        [JsonProperty("display_name", NullValueHandling = NullValueHandling.Ignore)]
        public string DisplayName { get; set; }

        /// <summary>
        /// How much should Demand be modified by when the player has the Hero of the Village mob
        /// effect
        /// </summary>
        [JsonProperty("hero_demand_discount", NullValueHandling = NullValueHandling.Ignore)]
        public long? HeroDemandDiscount { get; set; } = -4;

        /// <summary>
        /// Used to determine if trading with entity opens the new trade screen
        /// </summary>
        [JsonProperty("new_screen", NullValueHandling = NullValueHandling.Ignore)]
        public bool? NewScreen { get; set; } = new bool?();

        /// <summary>
        /// Determines if the trades should persist when the mob transforms. This makes it so that
        /// the next time the mob is transformed to something with a trade_table or
        /// economy_trade_table, then it keeps their trades.
        /// </summary>
        [JsonProperty("persist_trades", NullValueHandling = NullValueHandling.Ignore)]
        public bool? PersistTrades { get; set; } = new bool?();

        /// <summary>
        /// File path relative to the resource pack root for this entity's trades
        /// </summary>
        [JsonProperty("table", NullValueHandling = NullValueHandling.Ignore)]
        public string Table { get; set; }
    }

    /// <summary>
    /// A component that fires an event when a set of conditions are met by other entities within
    /// the defined range.
    /// </summary>
    public partial class EntitySensor1160
    {
        [JsonProperty("event", NullValueHandling = NullValueHandling.Ignore)]
        public Event? Event { get; set; }

        [JsonProperty("event_filters", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject EventFilters { get; set; }

        /// <summary>
        /// The maximum number of entities that must pass the filter conditions for the event to send.
        /// </summary>
        [JsonProperty("maximum_count", NullValueHandling = NullValueHandling.Ignore)]
        public long? MaximumCount { get; set; } = -1;

        /// <summary>
        /// The minimum number of entities that must pass the filter conditions for the event to send.
        /// </summary>
        [JsonProperty("minimum_count", NullValueHandling = NullValueHandling.Ignore)]
        public long? MinimumCount { get; set; } = 1;

        /// <summary>
        /// If true the sensor range is additive on top of the entity's size.
        /// </summary>
        [JsonProperty("relative_range", NullValueHandling = NullValueHandling.Ignore)]
        public bool? RelativeRange { get; set; } = new bool?();

        /// <summary>
        /// If true requires all nearby entities to pass the filter conditions for the event to send.
        /// </summary>
        [JsonProperty("require_all", NullValueHandling = NullValueHandling.Ignore)]
        public bool? RequireAll { get; set; } = new bool?();

        /// <summary>
        /// The maximum distance another entity can be from this and have the filters checked against
        /// it.
        /// </summary>
        [JsonProperty("sensor_range", NullValueHandling = NullValueHandling.Ignore)]
        public double? SensorRange { get; set; } = 10;
    }

    /// <summary>
    /// Creates a trigger based on environment conditions.
    /// </summary>
    public partial class EnvironmentSensor
    {
        /// <summary>
        /// The list of triggers that fire when the environment conditions match the given filter
        /// criteria.
        /// </summary>
        [JsonProperty("triggers", NullValueHandling = NullValueHandling.Ignore)]
        public Triggers? Triggers { get; set; }
    }

    /// <summary>
    /// Event to be runned when the cooldown is complete.
    ///
    /// Trigger to fire for 1.16.0
    ///
    /// The event to trigger when the goal's duration expires.
    ///
    /// On_roar_end
    ///
    /// Event to fire when the interaction occurs.
    ///
    /// Trigger to run when the entity gets named
    /// </summary>
    public partial class TriggersClass
    {
        /// <summary>
        /// Event
        /// </summary>
        [JsonProperty("event", NullValueHandling = NullValueHandling.Ignore)]
        public string Event { get; set; }

        /// <summary>
        /// The filters to check to determine if the event should be fired
        /// </summary>
        [JsonProperty("filters", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject Filters { get; set; }

        /// <summary>
        /// The entity to target
        /// </summary>
        [JsonProperty("target", NullValueHandling = NullValueHandling.Ignore)]
        public Subject1160? Target { get; set; }
    }

    /// <summary>
    /// The entity puts on the desired equipment.
    /// </summary>
    public partial class EquipItem1160
    {
    }

    /// <summary>
    /// TODO description:
    /// </summary>
    public partial class Equipment1160
    {
        /// <summary>
        /// A list of slots with the chance to drop an equipped item from that slot
        /// </summary>
        [JsonProperty("slot_drop_chance", NullValueHandling = NullValueHandling.Ignore)]
        public List<SlotDropChance> SlotDropChance { get; set; }

        /// <summary>
        /// TODO description: table
        /// </summary>
        [JsonProperty("table", NullValueHandling = NullValueHandling.Ignore)]
        public string Table { get; set; }
    }

    /// <summary>
    /// UNDOCUMENTATED
    /// </summary>
    public partial class SlotDropChance
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("drop_chance", NullValueHandling = NullValueHandling.Ignore)]
        public double? DropChance { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("slot", NullValueHandling = NullValueHandling.Ignore)]
        public string Slot { get; set; }
    }

    /// <summary>
    /// Defines an entity's behavior for having items equipped to it
    /// </summary>
    public partial class Equippable1160
    {
        /// <summary>
        /// List of slots and the item that can be equipped
        /// </summary>
        [JsonProperty("slots", NullValueHandling = NullValueHandling.Ignore)]
        public List<Slots> Slots { get; set; }
    }

    /// <summary>
    /// A slot and the item that can be equipped
    /// </summary>
    public partial class Slots
    {
        /// <summary>
        /// The list of items that can go in this slot
        /// </summary>
        [JsonProperty("accepted_items", NullValueHandling = NullValueHandling.Ignore)]
        public List<string> AcceptedItems { get; set; }

        /// <summary>
        /// Text to be displayed when the entity can be equipped with this item when playing with
        /// Touch-screen controls
        /// </summary>
        [JsonProperty("interact_text", NullValueHandling = NullValueHandling.Ignore)]
        public string InteractText { get; set; }

        /// <summary>
        /// Identifier of the item that can be equipped for this slot
        /// </summary>
        [JsonProperty("item", NullValueHandling = NullValueHandling.Ignore)]
        public string Item { get; set; }

        /// <summary>
        /// Event to trigger when this entity is equipped with this item
        /// </summary>
        [JsonProperty("on_equip", NullValueHandling = NullValueHandling.Ignore)]
        public Event? OnEquip { get; set; }

        /// <summary>
        /// Event to trigger when this item is removed from this entity
        /// </summary>
        [JsonProperty("on_unequip", NullValueHandling = NullValueHandling.Ignore)]
        public Event? OnUnequip { get; set; }

        /// <summary>
        /// The slot number of this slot
        /// </summary>
        [JsonProperty("slot", NullValueHandling = NullValueHandling.Ignore)]
        public long? Slot { get; set; } = 0;
    }

    /// <summary>
    /// TODO
    /// </summary>
    public partial class ExperienceReward1160
    {
        /// <summary>
        /// A molang expression defining the amount of experience rewarded when this entity is
        /// successfully bred. An array of expressions adds each expression's result together for a
        /// final total.
        /// </summary>
        [JsonProperty("on_bred", NullValueHandling = NullValueHandling.Ignore)]
        public string OnBred { get; set; }

        /// <summary>
        /// A molang expression defining the amount of experience rewarded when this entity dies. An
        /// array of expressions adds each expression's result together for a final total.
        /// </summary>
        [JsonProperty("on_death", NullValueHandling = NullValueHandling.Ignore)]
        public string OnDeath { get; set; }
    }

    /// <summary>
    /// Defines how the entity explodes.
    /// </summary>
    public partial class Explode1160
    {
        /// <summary>
        /// If true, the explosion will destroy blocks in the explosion radius.
        /// </summary>
        [JsonProperty("breaks_blocks", NullValueHandling = NullValueHandling.Ignore)]
        public bool? BreaksBlocks { get; set; } = new bool?();

        /// <summary>
        /// If true, blocks in the explosion radius will be set on fire.
        /// </summary>
        [JsonProperty("causes_fire", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CausesFire { get; set; } = new bool?();

        /// <summary>
        /// If true, whether the explosion breaks blocks is affected by the mob griefing game rule.
        /// </summary>
        [JsonProperty("destroy_affected_by_griefing", NullValueHandling = NullValueHandling.Ignore)]
        public bool? DestroyAffectedByGriefing { get; set; } = new bool?();

        /// <summary>
        /// If true, whether the explosion causes fire is affected by the mob griefing game rule.
        /// </summary>
        [JsonProperty("fire_affected_by_griefing", NullValueHandling = NullValueHandling.Ignore)]
        public bool? FireAffectedByGriefing { get; set; } = new bool?();

        /// <summary>
        /// The range for the random amount of time the fuse will be lit before exploding, a negative
        /// value means the explosion will be immediate.
        /// </summary>
        [JsonProperty("fuse_length", NullValueHandling = NullValueHandling.Ignore)]
        public AttackCooldownTime? FuseLength { get; set; } = new List<double> {0.0,0.0};

        /// <summary>
        /// If true, the fuse is already lit when this component is added to the entity.
        /// </summary>
        [JsonProperty("fuse_lit", NullValueHandling = NullValueHandling.Ignore)]
        public bool? FuseLit { get; set; } = new bool?();

        /// <summary>
        /// A blocks explosion resistance will be capped at this value when an explosion occurs.
        /// </summary>
        [JsonProperty("max_resistance", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaxResistance { get; set; } = 3.40282e+38;

        /// <summary>
        /// The radius of the explosion in blocks and the amount of damage the explosion deals.
        /// </summary>
        [JsonProperty("power", NullValueHandling = NullValueHandling.Ignore)]
        public double? Power { get; set; } = 3;
    }

    /// <summary>
    /// TODO
    /// </summary>
    public partial class FallDamage180
    {
        /// <summary>
        /// TODO description: value
        /// </summary>
        [JsonProperty("value", NullValueHandling = NullValueHandling.Ignore)]
        public double? Value { get; set; } = 1;
    }

    /// <summary>
    /// Sets that this entity doesn't take damage from fire.
    /// </summary>
    public partial class FireImmune180
    {
    }

    /// <summary>
    /// Sets that this entity can float in liquid blocks.
    /// </summary>
    public partial class FloatsInLiquid180
    {
    }

    /// <summary>
    /// Allows entities to flock in groups in water or not.
    /// </summary>
    public partial class Flocking1160
    {
        /// <summary>
        /// The amount of blocks away the entity will look at to push away from.
        /// </summary>
        [JsonProperty("block_distance", NullValueHandling = NullValueHandling.Ignore)]
        public double? BlockDistance { get; set; } = 0;

        /// <summary>
        /// The weight of the push back away from blocks.
        /// </summary>
        [JsonProperty("block_weight", NullValueHandling = NullValueHandling.Ignore)]
        public double? BlockWeight { get; set; } = 0;

        /// <summary>
        /// The amount of push back given to a flocker that breaches out of the water.
        /// </summary>
        [JsonProperty("breach_influence", NullValueHandling = NullValueHandling.Ignore)]
        public double? BreachInfluence { get; set; } = 0;

        /// <summary>
        /// The threshold in which to start applying cohesion.
        /// </summary>
        [JsonProperty("cohesion_threshold", NullValueHandling = NullValueHandling.Ignore)]
        public double? CohesionThreshold { get; set; } = 1;

        /// <summary>
        /// The weight applied for the cohesion steering of the flock.
        /// </summary>
        [JsonProperty("cohesion_weight", NullValueHandling = NullValueHandling.Ignore)]
        public double? CohesionWeight { get; set; } = 1;

        /// <summary>
        /// The weight on which to apply on the goal output.
        /// </summary>
        [JsonProperty("goal_weight", NullValueHandling = NullValueHandling.Ignore)]
        public double? GoalWeight { get; set; } = 0;

        /// <summary>
        /// Determines the high bound amount of entities that can be allowed in the flock.
        /// </summary>
        [JsonProperty("high_flock_limit", NullValueHandling = NullValueHandling.Ignore)]
        public long? HighFlockLimit { get; set; } = 0;

        /// <summary>
        /// Tells the Flocking Component if the entity exists in water.
        /// </summary>
        [JsonProperty("in_water", NullValueHandling = NullValueHandling.Ignore)]
        public bool? InWater { get; set; } = new bool?();

        /// <summary>
        /// The area around the entity that allows others to be added to the flock.
        /// </summary>
        [JsonProperty("influence_radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? InfluenceRadius { get; set; } = 0;

        /// <summary>
        /// The distance in which the flocker will stop applying cohesion.
        /// </summary>
        [JsonProperty("innner_cohesion_threshold", NullValueHandling = NullValueHandling.Ignore)]
        public double? InnnerCohesionThreshold { get; set; } = 0;

        /// <summary>
        /// The percentage chance between 0-1 that a fish will spawn and not want to join flocks.
        /// Invalid values will be capped at the end points.
        /// </summary>
        [JsonProperty("loner_chance", NullValueHandling = NullValueHandling.Ignore)]
        public double? LonerChance { get; set; } = 0;

        /// <summary>
        /// Determines the low bound amount of entities that can be allowed in the flock.
        /// </summary>
        [JsonProperty("low_flock_limit", NullValueHandling = NullValueHandling.Ignore)]
        public long? LowFlockLimit { get; set; } = 0;

        /// <summary>
        /// Tells the flockers that they can only match similar entities that also match the variant,
        /// mark variants, and color data of the other potential flockers.
        /// </summary>
        [JsonProperty("match_variants", NullValueHandling = NullValueHandling.Ignore)]
        public bool? MatchVariants { get; set; } = new bool?();

        /// <summary>
        /// The max height allowable in the air or water.
        /// </summary>
        [JsonProperty("max_height", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaxHeight { get; set; } = 0;

        /// <summary>
        /// The min height allowable in the air or water.
        /// </summary>
        [JsonProperty("min_height", NullValueHandling = NullValueHandling.Ignore)]
        public double? MinHeight { get; set; } = 0;

        /// <summary>
        /// The distance that is determined to be to close to another flocking and to start applying
        /// separation.
        /// </summary>
        [JsonProperty("separation_threshold", NullValueHandling = NullValueHandling.Ignore)]
        public double? SeparationThreshold { get; set; } = 2;

        /// <summary>
        /// The weight applied to the separation of the flock.
        /// </summary>
        [JsonProperty("separation_weight", NullValueHandling = NullValueHandling.Ignore)]
        public double? SeparationWeight { get; set; } = 1;

        /// <summary>
        /// Tells the flockers that they will follow flocks based on the center of mass.
        /// </summary>
        [JsonProperty("use_center_of_mass", NullValueHandling = NullValueHandling.Ignore)]
        public bool? UseCenterOfMass { get; set; } = new bool?();
    }

    /// <summary>
    /// Speed in Blocks that this entity flies at.
    /// </summary>
    public partial class FlyingSpeed180
    {
        /// <summary>
        /// Flying speed in blocks per tick
        /// </summary>
        [JsonProperty("value", NullValueHandling = NullValueHandling.Ignore)]
        public double? Value { get; set; } = 0.02;
    }

    /// <summary>
    /// TODO description:
    /// </summary>
    public partial class FollowRange180
    {
        /// <summary>
        /// TODO
        /// </summary>
        [JsonProperty("max", NullValueHandling = NullValueHandling.Ignore)]
        public long? Max { get; set; }

        /// <summary>
        /// TODO
        /// </summary>
        [JsonProperty("value", NullValueHandling = NullValueHandling.Ignore)]
        public long? Value { get; set; }
    }

    /// <summary>
    /// Sets the number of blocks the entity can step without jumping.
    /// </summary>
    public partial class FootSize180
    {
        /// <summary>
        /// The value of the size of the entity's step
        /// </summary>
        [JsonProperty("value", NullValueHandling = NullValueHandling.Ignore)]
        public double? Value { get; set; } = 0.5;
    }

    /// <summary>
    /// Defines how much does friction affect this entity.
    /// </summary>
    public partial class FrictionModifier180
    {
        /// <summary>
        /// The higher the number, the more the friction affects this entity. A value of 1.0 means
        /// regular friction, while 2.0 means twice as much
        /// </summary>
        [JsonProperty("value", NullValueHandling = NullValueHandling.Ignore)]
        public double? Value { get; set; } = 1;
    }

    /// <summary>
    /// Defines the way a mob's genes and alleles are passed on to it's offspring, and how those
    /// traits manifest in the child. Compatible parent genes are crossed together, the alleles
    /// are handed down from the parents to the child, and any matching genetic variants fire off
    /// JSON events to modify the child and express the traits.
    /// </summary>
    public partial class Genetics180
    {
        /// <summary>
        /// TODO description
        /// </summary>
        [JsonProperty("genes", NullValueHandling = NullValueHandling.Ignore)]
        public List<Gene> Genes { get; set; }

        /// <summary>
        /// Chance that an allele will be replaced with a random one instead of the parent's allele
        /// during birth.
        /// </summary>
        [JsonProperty("mutation_rate", NullValueHandling = NullValueHandling.Ignore)]
        public double? MutationRate { get; set; } = 0.03125;
    }

    /// <summary>
    /// The list of genes that this entity has and will cross with a partner during breeding.
    /// </summary>
    public partial class Gene
    {
        /// <summary>
        /// The range of positive integer allele values for this gene. Spawned mobs will have a
        /// random number in this range assigned to them.
        /// </summary>
        [JsonProperty("allele_range", NullValueHandling = NullValueHandling.Ignore)]
        public Allele? AlleleRange { get; set; }

        /// <summary>
        /// The list of genetic variants for this gene. These check for particular allele
        /// combinations and fire events when all of them are satisfied.
        /// </summary>
        [JsonProperty("genetic_variants", NullValueHandling = NullValueHandling.Ignore)]
        public List<GeneticVariant> GeneticVariants { get; set; }
    }

    public partial class GeneticVariant
    {
        /// <summary>
        /// Event to run when this mob is created and matches the above allele conditions.
        /// </summary>
        [JsonProperty("birth_event", NullValueHandling = NullValueHandling.Ignore)]
        public Event? BirthEvent { get; set; }

        /// <summary>
        /// If this value is non-negative, compare both the mob's main and hidden alleles with this
        /// value for a match with both. Can also be a range of integers.
        /// </summary>
        [JsonProperty("both_allele", NullValueHandling = NullValueHandling.Ignore)]
        public Allele? BothAllele { get; set; }

        /// <summary>
        /// If this value is non-negative, compare both the mob's main and hidden alleles with this
        /// value for a match with either. Can also be a range of integers.
        /// </summary>
        [JsonProperty("either_allele", NullValueHandling = NullValueHandling.Ignore)]
        public long? EitherAllele { get; set; } = -1;

        /// <summary>
        /// If this value is non-negative, compare the mob's hidden allele with this value for a
        /// match. Can also be a range of integers.
        /// </summary>
        [JsonProperty("hidden_allele", NullValueHandling = NullValueHandling.Ignore)]
        public long? HiddenAllele { get; set; } = -1;

        /// <summary>
        /// If this value is non-negative, compare the mob's main allele with this value for a match.
        /// Can also be a range of integers.
        /// </summary>
        [JsonProperty("main_allele", NullValueHandling = NullValueHandling.Ignore)]
        public long? MainAllele { get; set; } = -1;
    }

    /// <summary>
    /// Defines sets of items that can be used to trigger events when used on this entity. The
    /// item will also be taken and placed in the entity's inventory.
    /// </summary>
    public partial class Giveable1160
    {
        [JsonProperty("triggers", NullValueHandling = NullValueHandling.Ignore)]
        public MinecraftGiveableTriggers Triggers { get; set; }
    }

    public partial class MinecraftGiveableTriggers
    {
        /// <summary>
        /// An optional cool down in seconds to prevent spamming interactions.
        /// </summary>
        [JsonProperty("cooldown", NullValueHandling = NullValueHandling.Ignore)]
        public double? Cooldown { get; set; } = 0;

        /// <summary>
        /// The list of items that can be given to the entity to place in their inventory.
        /// </summary>
        [JsonProperty("items", NullValueHandling = NullValueHandling.Ignore)]
        public List<string> Items { get; set; }

        /// <summary>
        /// Event to fire when the correct item is given.
        /// </summary>
        [JsonProperty("on_give", NullValueHandling = NullValueHandling.Ignore)]
        public Event? OnGive { get; set; }
    }

    /// <summary>
    /// Sets the offset from the ground that the entity is actually at.
    /// </summary>
    public partial class GroundOffset180
    {
        /// <summary>
        /// The value of the entity's offset from the terrain, in blocks
        /// </summary>
        [JsonProperty("value", NullValueHandling = NullValueHandling.Ignore)]
        public double? Value { get; set; } = 0;
    }

    /// <summary>
    /// Keeps track of entity group size in the given radius.
    /// </summary>
    public partial class GroupSize1160
    {
        /// <summary>
        /// The list of conditions that must be satisfied for other entities to be counted towards
        /// group size.
        /// </summary>
        [JsonProperty("filters", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject Filters { get; set; }

        /// <summary>
        /// Radius from center of entity.
        /// </summary>
        [JsonProperty("radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? Radius { get; set; } = 16;
    }

    /// <summary>
    /// Could increase crop growth when entity walks over crop.
    /// </summary>
    public partial class GrowsCrop1160
    {
        /// <summary>
        /// Value between 0-1. Chance of success per tick.
        /// </summary>
        [JsonProperty("chance", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(PurpleMinMaxValueCheckConverter))]
        public double? Chance { get; set; } = 0;

        /// <summary>
        /// Number of charges
        /// </summary>
        [JsonProperty("charges", NullValueHandling = NullValueHandling.Ignore)]
        public long? Charges { get; set; } = 10;
    }

    /// <summary>
    /// Defines the interactions with this entity for healing it.
    /// </summary>
    public partial class Healable180
    {
        /// <summary>
        /// The filter group that defines the conditions for this trigger
        /// </summary>
        [JsonProperty("filters", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject Filters { get; set; }

        /// <summary>
        /// Determines if item can be used regardless of entity being at full health
        /// </summary>
        [JsonProperty("force_use", NullValueHandling = NullValueHandling.Ignore)]
        public bool? ForceUse { get; set; } = new bool?();

        /// <summary>
        /// The array of items that can be used to heal this entity
        /// </summary>
        [JsonProperty("items", NullValueHandling = NullValueHandling.Ignore)]
        public List<MinecraftHealableItem> Items { get; set; }
    }

    public partial class MinecraftHealableItem
    {
        /// <summary>
        /// The filter group that defines the conditions for using this item to heal the entity
        /// </summary>
        [JsonProperty("filters", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject Filters { get; set; }

        /// <summary>
        /// The amount of health this entity gains when fed this item
        /// </summary>
        [JsonProperty("heal_amount", NullValueHandling = NullValueHandling.Ignore)]
        public long? HealAmount { get; set; } = 1;

        /// <summary>
        /// Item identifier that can be used to heal this entity
        /// </summary>
        [JsonProperty("item", NullValueHandling = NullValueHandling.Ignore)]
        public string Item { get; set; }
    }

    /// <summary>
    /// TODO
    /// </summary>
    public partial class Health180
    {
        /// <summary>
        /// TODO
        /// </summary>
        [JsonProperty("max", NullValueHandling = NullValueHandling.Ignore)]
        public long? Max { get; set; }

        /// <summary>
        /// TODO
        /// </summary>
        [JsonProperty("value", NullValueHandling = NullValueHandling.Ignore)]
        public List<double> Value { get; set; }
    }

    /// <summary>
    /// UNDOCUMENTATED
    /// </summary>
    public partial class Hide1160
    {
    }

    /// <summary>
    /// Saves a home pos for when the the entity is spawned.
    /// </summary>
    public partial class Home1160
    {
        /// <summary>
        /// The radius that the entity will be restricted to in relation to its home
        /// </summary>
        [JsonProperty("restriction_radius", NullValueHandling = NullValueHandling.Ignore)]
        public long? RestrictionRadius { get; set; } = -1;
    }

    /// <summary>
    /// UNDOCUMENTATED
    /// </summary>
    public partial class HorseJumpStrength1160
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("value", NullValueHandling = NullValueHandling.Ignore)]
        public Value? Value { get; set; }
    }

    /// <summary>
    /// Defines a set of conditions under which an entity should take damage.
    /// </summary>
    public partial class HurtOnCondition1160
    {
        /// <summary>
        /// TODO
        /// </summary>
        [JsonProperty("damage_conditions", NullValueHandling = NullValueHandling.Ignore)]
        public List<DamageCondition> DamageConditions { get; set; }
    }

    /// <summary>
    /// TODO
    /// </summary>
    public partial class DamageCondition
    {
        /// <summary>
        /// Damage cause
        /// </summary>
        [JsonProperty("cause", NullValueHandling = NullValueHandling.Ignore)]
        public DamageConditionCause? Cause { get; set; }

        /// <summary>
        /// TODO
        /// </summary>
        [JsonProperty("damage_per_tick", NullValueHandling = NullValueHandling.Ignore)]
        public long? DamagePerTick { get; set; }

        [JsonProperty("filters", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject Filters { get; set; }
    }

    /// <summary>
    /// Specifies if an actor is hurt when wet.
    /// </summary>
    public partial class HurtWhenWet180
    {
    }

    /// <summary>
    /// When configured as a rideable entity, the entity will be controlled using WASD controls.
    /// </summary>
    public partial class InputGroundControlled180
    {
    }

    /// <summary>
    /// Verifies whether the entity is inside any of the listed blocks.
    /// </summary>
    public partial class InsideBlockNotifier180
    {
        /// <summary>
        /// List of blocks, with certain block states, that we are monitoring to see if the entity is
        /// inside.
        /// </summary>
        [JsonProperty("block_list", NullValueHandling = NullValueHandling.Ignore)]
        public List<Block> BlockList { get; set; }
    }

    /// <summary>
    /// TODO
    /// </summary>
    public partial class Block
    {
        [JsonProperty("block", NullValueHandling = NullValueHandling.Ignore)]
        public BlockDefinition BlockBlock { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("entered_block_event", NullValueHandling = NullValueHandling.Ignore)]
        public Event? EnteredBlockEvent { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("exited_block_event", NullValueHandling = NullValueHandling.Ignore)]
        public Event? ExitedBlockEvent { get; set; }
    }

    public partial class BlockDefinition
    {
        /// <summary>
        /// The block id, for example: 'minecraft:air'
        /// </summary>
        [JsonProperty("name", NullValueHandling = NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// The block states
        /// </summary>
        [JsonProperty("states", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, State> States { get; set; }
    }

    /// <summary>
    /// Adds a timer since last rested to see if phantoms should spawn.
    /// </summary>
    public partial class Insomnia180
    {
        /// <summary>
        /// Number of days the mob has to stay up until the insomnia effect begins.
        /// </summary>
        [JsonProperty("days_until_insomnia", NullValueHandling = NullValueHandling.Ignore)]
        public double? DaysUntilInsomnia { get; set; } = 3;
    }

    /// <summary>
    /// Despawns the Actor immediately.
    /// </summary>
    public partial class InstantDespawn1160
    {
        /// <summary>
        /// If true, all entities linked to this entity in a child relationship (eg. leashed) will
        /// also be despawned.
        /// </summary>
        [JsonProperty("remove_child_entities", NullValueHandling = NullValueHandling.Ignore)]
        public bool? RemoveChildEntities { get; set; } = new bool?();
    }

    /// <summary>
    /// Defines interactions with this entity.
    /// </summary>
    public partial class MinecraftInteractClass
    {
        /// <summary>
        /// TODO description
        /// </summary>
        [JsonProperty("interactions", NullValueHandling = NullValueHandling.Ignore)]
        public Interactions? Interactions { get; set; }
    }

    public partial class InteractionElement
    {
        /// <summary>
        /// Loot table with items to add to the player's inventory upon successful interaction.
        /// </summary>
        [JsonProperty("add_items", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, object> AddItems { get; set; }

        /// <summary>
        /// Time in seconds before this entity can be interacted with again.
        /// </summary>
        [JsonProperty("cooldown", NullValueHandling = NullValueHandling.Ignore)]
        public double? Cooldown { get; set; } = 0;

        /// <summary>
        /// The amount of damage the item will take when used to interact with this entity. A value
        /// of 0 means the item won't lose durability.
        /// </summary>
        [JsonProperty("hurt_item", NullValueHandling = NullValueHandling.Ignore)]
        public long? HurtItem { get; set; } = 0;

        /// <summary>
        /// Text to show when the player is able to interact in this way with this entity when
        /// playing with Touch-screen controls.
        /// </summary>
        [JsonProperty("interact_text", NullValueHandling = NullValueHandling.Ignore)]
        public string InteractText { get; set; } = "";

        /// <summary>
        /// Event to fire when the interaction occurs.
        /// </summary>
        [JsonProperty("on_interact", NullValueHandling = NullValueHandling.Ignore)]
        public Trigger OnInteract { get; set; }

        /// <summary>
        /// Particle effect that will be triggered at the start of the interaction.
        /// </summary>
        [JsonProperty("particle_on_start", NullValueHandling = NullValueHandling.Ignore)]
        public ParticleOnStart ParticleOnStart { get; set; }

        /// <summary>
        /// List of sounds to play when the interaction occurs.
        /// </summary>
        [JsonProperty("play_sounds", NullValueHandling = NullValueHandling.Ignore)]
        public string PlaySounds { get; set; } = "";

        /// <summary>
        /// List of entities to spawn when the interaction occurs.
        /// </summary>
        [JsonProperty("spawn_entities", NullValueHandling = NullValueHandling.Ignore)]
        public string SpawnEntities { get; set; } = "";

        /// <summary>
        /// Loot table with items to drop on the ground upon successful interaction.
        /// </summary>
        [JsonProperty("spawn_items", NullValueHandling = NullValueHandling.Ignore)]
        public SpawnItems SpawnItems { get; set; }

        /// <summary>
        /// If true, the player will do the 'swing' animation when interacting with this entity.
        /// </summary>
        [JsonProperty("swing", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Swing { get; set; } = new bool?();

        /// <summary>
        /// The item used will transform to this item upon successful interaction. Format:
        /// itemName:auxValue
        /// </summary>
        [JsonProperty("transform_to_item", NullValueHandling = NullValueHandling.Ignore)]
        public string TransformToItem { get; set; } = "";

        /// <summary>
        /// If true, the interaction will use an item.
        /// </summary>
        [JsonProperty("use_item", NullValueHandling = NullValueHandling.Ignore)]
        public bool? UseItem { get; set; } = new bool?();
    }

    /// <summary>
    /// Particle effect that will be triggered at the start of the interaction.
    /// </summary>
    public partial class ParticleOnStart
    {
        /// <summary>
        /// Whether or not the particle will appear closer to who performed the interaction.
        /// </summary>
        [JsonProperty("particle_offset_towards_interactor", NullValueHandling = NullValueHandling.Ignore)]
        public bool? ParticleOffsetTowardsInteractor { get; set; }

        /// <summary>
        /// The type of particle that will be spawned.
        /// </summary>
        [JsonProperty("particle_type", NullValueHandling = NullValueHandling.Ignore)]
        public string ParticleType { get; set; }

        /// <summary>
        /// Will offset the particle this amount in the y direction.
        /// </summary>
        [JsonProperty("particle_y_offset", NullValueHandling = NullValueHandling.Ignore)]
        public double? ParticleYOffset { get; set; }
    }

    /// <summary>
    /// Loot table with items to drop on the ground upon successful interaction.
    /// </summary>
    public partial class SpawnItems
    {
        /// <summary>
        /// File path, relative to the Behavior Pack's path, to the loot table file.
        /// </summary>
        [JsonProperty("table", NullValueHandling = NullValueHandling.Ignore)]
        public string Table { get; set; } = "";
    }

    public partial class InteractionsClass
    {
        /// <summary>
        /// Loot table with items to add to the player's inventory upon successful interaction.
        /// </summary>
        [JsonProperty("add_items", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, object> AddItems { get; set; }

        /// <summary>
        /// Time in seconds before this entity can be interacted with again.
        /// </summary>
        [JsonProperty("cooldown", NullValueHandling = NullValueHandling.Ignore)]
        public double? Cooldown { get; set; } = 0;

        /// <summary>
        /// The amount of damage the item will take when used to interact with this entity. A value
        /// of 0 means the item won't lose durability.
        /// </summary>
        [JsonProperty("hurt_item", NullValueHandling = NullValueHandling.Ignore)]
        public long? HurtItem { get; set; } = 0;

        /// <summary>
        /// Text to show when the player is able to interact in this way with this entity when
        /// playing with Touch-screen controls.
        /// </summary>
        [JsonProperty("interact_text", NullValueHandling = NullValueHandling.Ignore)]
        public string InteractText { get; set; } = "";

        /// <summary>
        /// Event to fire when the interaction occurs.
        /// </summary>
        [JsonProperty("on_interact", NullValueHandling = NullValueHandling.Ignore)]
        public Trigger OnInteract { get; set; }

        /// <summary>
        /// Particle effect that will be triggered at the start of the interaction.
        /// </summary>
        [JsonProperty("particle_on_start", NullValueHandling = NullValueHandling.Ignore)]
        public ParticleOnStart ParticleOnStart { get; set; }

        /// <summary>
        /// List of sounds to play when the interaction occurs.
        /// </summary>
        [JsonProperty("play_sounds", NullValueHandling = NullValueHandling.Ignore)]
        public string PlaySounds { get; set; } = "";

        /// <summary>
        /// List of entities to spawn when the interaction occurs.
        /// </summary>
        [JsonProperty("spawn_entities", NullValueHandling = NullValueHandling.Ignore)]
        public string SpawnEntities { get; set; } = "";

        /// <summary>
        /// Loot table with items to drop on the ground upon successful interaction.
        /// </summary>
        [JsonProperty("spawn_items", NullValueHandling = NullValueHandling.Ignore)]
        public SpawnItems SpawnItems { get; set; }

        /// <summary>
        /// If true, the player will do the 'swing' animation when interacting with this entity.
        /// </summary>
        [JsonProperty("swing", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Swing { get; set; } = new bool?();

        /// <summary>
        /// The item used will transform to this item upon successful interaction. Format:
        /// itemName:auxValue
        /// </summary>
        [JsonProperty("transform_to_item", NullValueHandling = NullValueHandling.Ignore)]
        public string TransformToItem { get; set; } = "";

        /// <summary>
        /// If true, the interaction will use an item.
        /// </summary>
        [JsonProperty("use_item", NullValueHandling = NullValueHandling.Ignore)]
        public bool? UseItem { get; set; } = new bool?();
    }

    /// <summary>
    /// Defines this entity's inventory properties.
    /// </summary>
    public partial class Inventory1160
    {
        /// <summary>
        /// Number of slots that this entity can gain per extra strength
        /// </summary>
        [JsonProperty("additional_slots_per_strength", NullValueHandling = NullValueHandling.Ignore)]
        public long? AdditionalSlotsPerStrength { get; set; } = 0;

        /// <summary>
        /// If true, the contents of this inventory can be removed by a hopper
        /// </summary>
        [JsonProperty("can_be_siphoned_from", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanBeSiphonedFrom { get; set; } = new bool?();

        /// <summary>
        /// Type of container this entity has. Can be horse, minecart_chest, minecart_hopper,
        /// inventory, container or hopper
        /// </summary>
        [JsonProperty("container_type", NullValueHandling = NullValueHandling.Ignore)]
        public ContainerType? ContainerType { get; set; }

        /// <summary>
        /// Number of slots the container has
        /// </summary>
        [JsonProperty("inventory_size", NullValueHandling = NullValueHandling.Ignore)]
        public long? InventorySize { get; set; } = 5;

        /// <summary>
        /// If true, only the entity can access the inventory
        /// </summary>
        [JsonProperty("private", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Private { get; set; } = new bool?();

        /// <summary>
        /// If true, the entity's inventory can only be accessed by its owner or itself
        /// </summary>
        [JsonProperty("restrict_to_owner", NullValueHandling = NullValueHandling.Ignore)]
        public bool? RestrictToOwner { get; set; } = new bool?();
    }

    /// <summary>
    /// Sets that this entity is a baby.
    /// </summary>
    public partial class IsBaby180
    {
    }

    /// <summary>
    /// Sets that this entity is charged.
    /// </summary>
    public partial class IsCharged180
    {
    }

    /// <summary>
    /// Sets that this entity is currently carrying a chest.
    /// </summary>
    public partial class IsChested180
    {
    }

    /// <summary>
    /// Allows dyes to be used on this entity to change its color.
    /// </summary>
    public partial class IsDyeable180
    {
        /// <summary>
        /// The text that will display when interacting with this entity with a dye when playing with
        /// Touch-screen controls
        /// </summary>
        [JsonProperty("interact_text", NullValueHandling = NullValueHandling.Ignore)]
        public string InteractText { get; set; }
    }

    /// <summary>
    /// TODO description
    /// </summary>
    public partial class IsHiddenWhenInvisible180
    {
    }

    /// <summary>
    /// Sets that this entity is currently on fire.
    /// </summary>
    public partial class IsIgnited180
    {
    }

    /// <summary>
    /// Sets that this entity is an illager captain.
    /// </summary>
    public partial class IsIllagerCaptain180
    {
    }

    /// <summary>
    /// Sets that this entity is currently saddled.
    /// </summary>
    public partial class IsSaddled180
    {
    }

    /// <summary>
    /// Sets that this entity is currently shaking.
    /// </summary>
    public partial class IsShaking180
    {
    }

    /// <summary>
    /// Sets that this entity is currently sheared.
    /// </summary>
    public partial class IsSheared180
    {
    }

    /// <summary>
    /// Sets that this entity can be stacked.
    /// </summary>
    public partial class IsStackable180
    {
        /// <summary>
        /// TODO description
        /// </summary>
        [JsonProperty("value", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Value { get; set; }
    }

    /// <summary>
    /// Sets that this entity is currently stunned.
    /// </summary>
    public partial class IsStunned180
    {
    }

    /// <summary>
    /// Sets that this entity is currently tamed.
    /// </summary>
    public partial class IsTamed180
    {
    }

    /// <summary>
    /// Efines what items can be used to control this entity while ridden
    /// </summary>
    public partial class ItemControllable180
    {
        /// <summary>
        /// List of items that can be used to control this entity
        /// </summary>
        [JsonProperty("control_items", NullValueHandling = NullValueHandling.Ignore)]
        public MinglePartnerType? ControlItems { get; set; }
    }

    /// <summary>
    /// Determines that this entity is an item hopper
    /// </summary>
    public partial class ItemHopper180
    {
    }

    /// <summary>
    /// Defines a dynamic type jump control that will change jump properties based on the speed
    /// modifier of the mob.
    /// </summary>
    public partial class JumpDynamic180
    {
    }

    /// <summary>
    /// Gives the entity the ability to jump.
    /// </summary>
    public partial class JumpStatic180
    {
        /// <summary>
        /// The initial vertical velocity for the jump
        /// </summary>
        [JsonProperty("jump_power", NullValueHandling = NullValueHandling.Ignore)]
        public double? JumpPower { get; set; } = 0.42;
    }

    /// <summary>
    /// UNDOCUMENTATED
    /// </summary>
    public partial class KnockbackResistance180
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("max", NullValueHandling = NullValueHandling.Ignore)]
        public double? Max { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("value", NullValueHandling = NullValueHandling.Ignore)]
        public double? Value { get; set; }
    }

    /// <summary>
    /// UNDOCUMENTATED
    /// </summary>
    public partial class LavaMovement180
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("value", NullValueHandling = NullValueHandling.Ignore)]
        public double? Value { get; set; }
    }

    /// <summary>
    /// Defines interactions with this entity.
    /// </summary>
    public partial class Leashable1160
    {
        /// <summary>
        /// If true, players can leash this entity even if it is already leashed to another mob.
        /// </summary>
        [JsonProperty("can_be_stolen", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanBeStolen { get; set; } = new bool?();

        /// <summary>
        /// Distance in blocks at which the leash stiffens, restricting movement.
        /// </summary>
        [JsonProperty("hard_distance", NullValueHandling = NullValueHandling.Ignore)]
        public double? HardDistance { get; set; } = 6;

        /// <summary>
        /// Distance in blocks at which the leash breaks.
        /// </summary>
        [JsonProperty("max_distance", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaxDistance { get; set; } = 10;

        /// <summary>
        /// Event to call when this entity is leashed.
        /// </summary>
        [JsonProperty("on_leash", NullValueHandling = NullValueHandling.Ignore)]
        public Event? OnLeash { get; set; }

        /// <summary>
        /// Event to call when this entity is unleashed.
        /// </summary>
        [JsonProperty("on_unleash", NullValueHandling = NullValueHandling.Ignore)]
        public Event? OnUnleash { get; set; }

        /// <summary>
        /// Distance in blocks at which the 'spring' effect starts acting to keep this entity close
        /// to the entity that leashed it.
        /// </summary>
        [JsonProperty("soft_distance", NullValueHandling = NullValueHandling.Ignore)]
        public double? SoftDistance { get; set; } = 4;
    }

    /// <summary>
    /// Defines the behavior when another entity looks at this entity.
    /// </summary>
    public partial class Lookat1160
    {
        /// <summary>
        /// If true, invulnerable entities (e.g. Players in creative mode) are considered valid
        /// targets.
        /// </summary>
        [JsonProperty("allow_invulnerable", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AllowInvulnerable { get; set; } = new bool?();

        /// <summary>
        /// Defines the entities that can trigger this component
        /// </summary>
        [JsonProperty("filters", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject Filters { get; set; }

        /// <summary>
        /// The range for the random amount of time during which the entity is 'cooling down' and
        /// won't get angered or look for a target
        /// </summary>
        [JsonProperty("look_cooldown", NullValueHandling = NullValueHandling.Ignore)]
        public List<double> LookCooldown { get; set; } = new List<double> {0.0,0.0};

        /// <summary>
        /// The event identifier to run when the entities specified in filters look at this entity
        /// </summary>
        [JsonProperty("look_event", NullValueHandling = NullValueHandling.Ignore)]
        public string LookEvent { get; set; }

        /// <summary>
        /// If true, invulnerable entities (e.g. Players in creative mode) are considered valid
        /// targets
        /// </summary>
        [JsonProperty("mAllowInvulnerable", NullValueHandling = NullValueHandling.Ignore)]
        public bool? MAllowInvulnerable { get; set; } = new bool?();

        /// <summary>
        /// Maximum distance this entity will look for another entity looking at it.
        /// </summary>
        [JsonProperty("search_radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? Lookat1160_SearchRadius { get; set; } = 10;

        /// <summary>
        /// Maximum distance this entity will look for another entity looking at it
        /// </summary>
        [JsonProperty("searchRadius", NullValueHandling = NullValueHandling.Ignore)]
        public double? SearchRadius { get; set; } = 10;

        /// <summary>
        /// If true, this entity will set the attack target as the entity that looked at it.
        /// </summary>
        [JsonProperty("set_target", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Lookat1160_SetTarget { get; set; } = new bool?();

        /// <summary>
        /// If true, this entity will set the attack target as the entity that looked at it
        /// </summary>
        [JsonProperty("setTarget", NullValueHandling = NullValueHandling.Ignore)]
        public bool? SetTarget { get; set; } = new bool?();
    }

    /// <summary>
    /// TODO description:
    /// </summary>
    public partial class Loot180
    {
        /// <summary>
        /// TODO description: table
        /// </summary>
        [JsonProperty("table", NullValueHandling = NullValueHandling.Ignore)]
        public string Table { get; set; }
    }

    /// <summary>
    /// This component is used to implement part of the Wandering Trader behavior
    /// </summary>
    public partial class ManagedWanderingTrader180
    {
    }

    /// <summary>
    /// Additional variant value. Can be used to further differentiate variants.
    /// </summary>
    public partial class MarkVariant180
    {
        /// <summary>
        /// The ID of the variant. By convention, 0 is the ID of the base entity
        /// </summary>
        [JsonProperty("value")]
        public long Value { get; set; } = 0;
    }

    /// <summary>
    /// A component that applies a mob effect to entities that get within range.
    /// </summary>
    public partial class MobEffect1160
    {
        /// <summary>
        /// How close a hostile entity must be to have the mob effect applied.
        /// </summary>
        [JsonProperty("effect_range", NullValueHandling = NullValueHandling.Ignore)]
        public double? EffectRange { get; set; } = 0.2;

        /// <summary>
        /// How long the applied mob effect lasts in seconds.
        /// </summary>
        [JsonProperty("effect_time", NullValueHandling = NullValueHandling.Ignore)]
        public long? EffectTime { get; set; } = 10;

        /// <summary>
        /// TODO
        /// </summary>
        [JsonProperty("entity_filter", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject EntityFilter { get; set; }

        /// <summary>
        /// The mob effect that is applied to entities that enter this entities effect range.
        /// </summary>
        [JsonProperty("mob_effect", NullValueHandling = NullValueHandling.Ignore)]
        public string MobEffect { get; set; } = "";
    }

    /// <summary>
    /// TODO description
    /// </summary>
    public partial class Movement180
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("max", NullValueHandling = NullValueHandling.Ignore)]
        public double? Max { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("value", NullValueHandling = NullValueHandling.Ignore)]
        public SoundIntervalUnion? Value { get; set; }
    }

    /// <summary>
    /// This move control allows the mob to swim in water and walk on land.
    /// </summary>
    public partial class MovementAmphibious180
    {
        /// <summary>
        /// The maximum number in degrees the mob can turn per tick.
        /// </summary>
        [JsonProperty("max_turn", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaxTurn { get; set; } = 30;
    }

    /// <summary>
    /// TODO description
    /// </summary>
    public partial class MovementBasic180
    {
        /// <summary>
        /// The maximum number in degrees the mob can turn per tick.
        /// </summary>
        [JsonProperty("max_turn", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaxTurn { get; set; } = 30;
    }

    /// <summary>
    /// This move control causes the mob to fly.
    /// </summary>
    public partial class MovementFly180
    {
        /// <summary>
        /// The maximum number in degrees the mob can turn per tick.
        /// </summary>
        [JsonProperty("max_turn", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaxTurn { get; set; } = 30;
    }

    /// <summary>
    /// This move control allows a mob to fly, swim, climb, etc.
    /// </summary>
    public partial class MovementGeneric180
    {
        /// <summary>
        /// The maximum number in degrees the mob can turn per tick.
        /// </summary>
        [JsonProperty("max_turn", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaxTurn { get; set; } = 30;
    }

    /// <summary>
    /// TODO description
    /// </summary>
    public partial class MovementGlide180
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("speed_when_turning", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedWhenTurning { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("start_speed", NullValueHandling = NullValueHandling.Ignore)]
        public double? StartSpeed { get; set; }
    }

    /// <summary>
    /// This move control causes the mob to hover.
    /// </summary>
    public partial class MovementHover1160
    {
        /// <summary>
        /// The maximum number in degrees the mob can turn per tick.
        /// </summary>
        [JsonProperty("max_turn", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaxTurn { get; set; } = 30;
    }

    /// <summary>
    /// Move control that causes the mob to jump as it moves with a specified delay between jumps.
    /// </summary>
    public partial class MovementJump1160
    {
        /// <summary>
        /// Delay after landing when using the slime move control.
        /// </summary>
        [JsonProperty("jump_delay", NullValueHandling = NullValueHandling.Ignore)]
        public List<double> JumpDelay { get; set; } = new List<double> {0.0,0.0};

        /// <summary>
        /// The maximum number in degrees the mob can turn per tick.
        /// </summary>
        [JsonProperty("max_turn", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaxTurn { get; set; } = 30;
    }

    /// <summary>
    /// This move control causes the mob to hop as it moves.
    /// </summary>
    public partial class MovementSkip180
    {
        /// <summary>
        /// The maximum number in degrees the mob can turn per tick.
        /// </summary>
        [JsonProperty("max_turn", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaxTurn { get; set; } = 30;
    }

    /// <summary>
    /// This move control causes the mob to sway side to side giving the impression it is
    /// swimming.
    /// </summary>
    public partial class MovementSway1160
    {
        /// <summary>
        /// The maximum number in degrees the mob can turn per tick.
        /// </summary>
        [JsonProperty("max_turn", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaxTurn { get; set; } = 30;

        /// <summary>
        /// TODO description
        /// </summary>
        [JsonProperty("sway_amplitude", NullValueHandling = NullValueHandling.Ignore)]
        public double? SwayAmplitude { get; set; }
    }

    /// <summary>
    /// Allows this entity to be named (e.g. using a name tag).
    /// </summary>
    public partial class Nameable1160
    {
        /// <summary>
        /// If true, this entity can be renamed with name tags
        /// </summary>
        [JsonProperty("allow_name_tag_renaming", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AllowNameTagRenaming { get; set; } = new bool?();

        /// <summary>
        /// If true, the name will always be shown
        /// </summary>
        [JsonProperty("always_show", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AlwaysShow { get; set; } = new bool?();

        /// <summary>
        /// Trigger to run when the entity gets named
        /// </summary>
        [JsonProperty("default_trigger", NullValueHandling = NullValueHandling.Ignore)]
        public Trigger DefaultTrigger { get; set; }

        /// <summary>
        /// TODO description
        /// </summary>
        [JsonProperty("name_actions", NullValueHandling = NullValueHandling.Ignore)]
        public NameActions? NameActions { get; set; }
    }

    /// <summary>
    /// Describes the special names for this entity and the events to call when the entity
    /// acquires those names
    /// </summary>
    public partial class NameActionElement
    {
        /// <summary>
        /// List of special names that will cause the events defined in 'on_named' to fire
        /// </summary>
        [JsonProperty("name_filter", NullValueHandling = NullValueHandling.Ignore)]
        public string NameFilter { get; set; } = "";

        /// <summary>
        /// Event to be called when this entity acquires the name specified in 'name_filter'
        /// </summary>
        [JsonProperty("on_named", NullValueHandling = NullValueHandling.Ignore)]
        public Event? OnNamed { get; set; }
    }

    /// <summary>
    /// Describes the special names for this entity and the events to call when the entity
    /// acquires those names
    /// </summary>
    public partial class NameActionsClass
    {
        /// <summary>
        /// List of special names that will cause the events defined in 'on_named' to fire
        /// </summary>
        [JsonProperty("name_filter", NullValueHandling = NullValueHandling.Ignore)]
        public string NameFilter { get; set; } = "";

        /// <summary>
        /// Event to be called when this entity acquires the name specified in 'name_filter'
        /// </summary>
        [JsonProperty("on_named", NullValueHandling = NullValueHandling.Ignore)]
        public Event? OnNamed { get; set; }
    }

    /// <summary>
    /// Allows this entity to generate paths that include vertical walls like the vanilla Spiders
    /// do.
    /// </summary>
    public partial class NavigationClimb1160
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("avoid_damage_blocks", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AvoidDamageBlocks { get; set; }

        /// <summary>
        /// Tells the pathfinder to avoid portals (like nether portals) when finding a path
        /// </summary>
        [JsonProperty("avoid_portals", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AvoidPortals { get; set; } = new bool?();

        /// <summary>
        /// Whether or not the pathfinder should avoid tiles that are exposed to the sun when
        /// creating paths
        /// </summary>
        [JsonProperty("avoid_sun", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AvoidSun { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder to avoid water when creating a path
        /// </summary>
        [JsonProperty("avoid_water", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AvoidWater { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder that it can path through a closed door and break it
        /// </summary>
        [JsonProperty("can_break_doors", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanBreakDoors { get; set; } = new bool?();

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("can_float", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanFloat { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder that it can path through a closed door assuming the AI will open the
        /// door
        /// </summary>
        [JsonProperty("can_open_doors", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanOpenDoors { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder that it can path through a closed iron door assuming the AI will
        /// open the door
        /// </summary>
        [JsonProperty("can_open_iron_doors", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanOpenIronDoors { get; set; } = new bool?();

        /// <summary>
        /// Whether a path can be created through a door
        /// </summary>
        [JsonProperty("can_pass_doors", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanPassDoors { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder that it can start pathing when in the air
        /// </summary>
        [JsonProperty("can_path_from_air", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanPathFromAir { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder whether or not it can travel on the surface of the lava
        /// </summary>
        [JsonProperty("can_path_over_lava", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanPathOverLava { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder whether or not it can travel on the surface of the water
        /// </summary>
        [JsonProperty("can_path_over_water", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanPathOverWater { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder whether or not it will be pulled down by gravity while in water
        /// </summary>
        [JsonProperty("can_sink", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanSink { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder whether or not it can travel in lava like walking on ground
        /// </summary>
        [JsonProperty("can_walk_in_lava", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanWalkInLava { get; set; } = new bool?();

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("is_amphibious", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsAmphibious { get; set; } = new bool?();
    }

    /// <summary>
    /// Allows this entity to generate paths by flying around the air like the regular Ghast.
    /// </summary>
    public partial class NavigationFloat1160
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("avoid_damage_blocks", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AvoidDamageBlocks { get; set; }

        /// <summary>
        /// Tells the pathfinder to avoid portals (like nether portals) when finding a path
        /// </summary>
        [JsonProperty("avoid_portals", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AvoidPortals { get; set; } = new bool?();

        /// <summary>
        /// Whether or not the pathfinder should avoid tiles that are exposed to the sun when
        /// creating paths
        /// </summary>
        [JsonProperty("avoid_sun", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AvoidSun { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder to avoid water when creating a path
        /// </summary>
        [JsonProperty("avoid_water", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AvoidWater { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder that it can path through a closed door and break it
        /// </summary>
        [JsonProperty("can_break_doors", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanBreakDoors { get; set; } = new bool?();

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("can_float", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanFloat { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder that it can path through a closed door assuming the AI will open the
        /// door
        /// </summary>
        [JsonProperty("can_open_doors", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanOpenDoors { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder that it can path through a closed iron door assuming the AI will
        /// open the door
        /// </summary>
        [JsonProperty("can_open_iron_doors", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanOpenIronDoors { get; set; } = new bool?();

        /// <summary>
        /// Whether a path can be created through a door
        /// </summary>
        [JsonProperty("can_pass_doors", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanPassDoors { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder that it can start pathing when in the air
        /// </summary>
        [JsonProperty("can_path_from_air", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanPathFromAir { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder whether or not it can travel on the surface of the lava
        /// </summary>
        [JsonProperty("can_path_over_lava", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanPathOverLava { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder whether or not it can travel on the surface of the water
        /// </summary>
        [JsonProperty("can_path_over_water", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanPathOverWater { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder whether or not it will be pulled down by gravity while in water
        /// </summary>
        [JsonProperty("can_sink", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanSink { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder whether or not it can travel in lava like walking on ground
        /// </summary>
        [JsonProperty("can_walk_in_lava", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanWalkInLava { get; set; } = new bool?();

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("is_amphibious", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsAmphibious { get; set; } = new bool?();
    }

    /// <summary>
    /// Allows this entity to generate paths in the air like the vanilla Bees do. Keeps them from
    /// falling out of the skies and doing predictive movement.
    /// </summary>
    public partial class NavigationFly1160
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("avoid_damage_blocks", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AvoidDamageBlocks { get; set; }

        /// <summary>
        /// Tells the pathfinder to avoid portals (like nether portals) when finding a path
        /// </summary>
        [JsonProperty("avoid_portals", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AvoidPortals { get; set; } = new bool?();

        /// <summary>
        /// Whether or not the pathfinder should avoid tiles that are exposed to the sun when
        /// creating paths
        /// </summary>
        [JsonProperty("avoid_sun", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AvoidSun { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder to avoid water when creating a path
        /// </summary>
        [JsonProperty("avoid_water", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AvoidWater { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder that it can path through a closed door and break it
        /// </summary>
        [JsonProperty("can_break_doors", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanBreakDoors { get; set; } = new bool?();

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("can_float", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanFloat { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder that it can path through a closed door assuming the AI will open the
        /// door
        /// </summary>
        [JsonProperty("can_open_doors", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanOpenDoors { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder that it can path through a closed iron door assuming the AI will
        /// open the door
        /// </summary>
        [JsonProperty("can_open_iron_doors", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanOpenIronDoors { get; set; } = new bool?();

        /// <summary>
        /// Whether a path can be created through a door
        /// </summary>
        [JsonProperty("can_pass_doors", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanPassDoors { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder that it can start pathing when in the air
        /// </summary>
        [JsonProperty("can_path_from_air", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanPathFromAir { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder whether or not it can travel on the surface of the lava
        /// </summary>
        [JsonProperty("can_path_over_lava", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanPathOverLava { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder whether or not it can travel on the surface of the water
        /// </summary>
        [JsonProperty("can_path_over_water", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanPathOverWater { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder whether or not it will be pulled down by gravity while in water
        /// </summary>
        [JsonProperty("can_sink", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanSink { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder whether or not it can travel in lava like walking on ground
        /// </summary>
        [JsonProperty("can_walk_in_lava", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanWalkInLava { get; set; } = new bool?();

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("is_amphibious", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsAmphibious { get; set; } = new bool?();
    }

    /// <summary>
    /// Allows this entity to generate paths by walking, swimming, flying and/or climbing around
    /// and jumping up and down a block.
    /// </summary>
    public partial class NavigationGeneric1160
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("avoid_damage_blocks", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AvoidDamageBlocks { get; set; }

        /// <summary>
        /// Tells the pathfinder to avoid portals (like nether portals) when finding a path
        /// </summary>
        [JsonProperty("avoid_portals", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AvoidPortals { get; set; } = new bool?();

        /// <summary>
        /// Whether or not the pathfinder should avoid tiles that are exposed to the sun when
        /// creating paths
        /// </summary>
        [JsonProperty("avoid_sun", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AvoidSun { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder to avoid water when creating a path
        /// </summary>
        [JsonProperty("avoid_water", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AvoidWater { get; set; } = new bool?();

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("can_breach", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanBreach { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder that it can path through a closed door and break it
        /// </summary>
        [JsonProperty("can_break_doors", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanBreakDoors { get; set; } = new bool?();

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("can_float", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanFloat { get; set; } = new bool?();

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("can_jump", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanJump { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder that it can path through a closed door assuming the AI will open the
        /// door
        /// </summary>
        [JsonProperty("can_open_doors", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanOpenDoors { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder that it can path through a closed iron door assuming the AI will
        /// open the door
        /// </summary>
        [JsonProperty("can_open_iron_doors", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanOpenIronDoors { get; set; } = new bool?();

        /// <summary>
        /// Whether a path can be created through a door
        /// </summary>
        [JsonProperty("can_pass_doors", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanPassDoors { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder that it can start pathing when in the air
        /// </summary>
        [JsonProperty("can_path_from_air", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanPathFromAir { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder whether or not it can travel on the surface of the lava
        /// </summary>
        [JsonProperty("can_path_over_lava", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanPathOverLava { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder whether or not it can travel on the surface of the water
        /// </summary>
        [JsonProperty("can_path_over_water", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanPathOverWater { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder whether or not it will be pulled down by gravity while in water
        /// </summary>
        [JsonProperty("can_sink", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanSink { get; set; } = new bool?();

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("can_swim", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanSwim { get; set; } = new bool?();

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("can_walk", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanWalk { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder whether or not it can travel in lava like walking on ground
        /// </summary>
        [JsonProperty("can_walk_in_lava", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanWalkInLava { get; set; } = new bool?();

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("is_amphibious", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsAmphibious { get; set; } = new bool?();
    }

    /// <summary>
    /// Allows this entity to generate paths in the air like the vanilla Bees do. Keeps them from
    /// falling out of the skies and doing predictive movement.
    /// </summary>
    public partial class NavigationHover1160
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("avoid_damage_blocks", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AvoidDamageBlocks { get; set; }

        /// <summary>
        /// Tells the pathfinder to avoid portals (like nether portals) when finding a path
        /// </summary>
        [JsonProperty("avoid_portals", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AvoidPortals { get; set; } = new bool?();

        /// <summary>
        /// Whether or not the pathfinder should avoid tiles that are exposed to the sun when
        /// creating paths
        /// </summary>
        [JsonProperty("avoid_sun", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AvoidSun { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder to avoid water when creating a path
        /// </summary>
        [JsonProperty("avoid_water", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AvoidWater { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder that it can path through a closed door and break it
        /// </summary>
        [JsonProperty("can_break_doors", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanBreakDoors { get; set; } = new bool?();

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("can_float", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanFloat { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder that it can path through a closed door assuming the AI will open the
        /// door
        /// </summary>
        [JsonProperty("can_open_doors", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanOpenDoors { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder that it can path through a closed iron door assuming the AI will
        /// open the door
        /// </summary>
        [JsonProperty("can_open_iron_doors", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanOpenIronDoors { get; set; } = new bool?();

        /// <summary>
        /// Whether a path can be created through a door
        /// </summary>
        [JsonProperty("can_pass_doors", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanPassDoors { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder that it can start pathing when in the air
        /// </summary>
        [JsonProperty("can_path_from_air", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanPathFromAir { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder whether or not it can travel on the surface of the lava
        /// </summary>
        [JsonProperty("can_path_over_lava", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanPathOverLava { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder whether or not it can travel on the surface of the water
        /// </summary>
        [JsonProperty("can_path_over_water", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanPathOverWater { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder whether or not it will be pulled down by gravity while in water
        /// </summary>
        [JsonProperty("can_sink", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanSink { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder whether or not it can travel in lava like walking on ground
        /// </summary>
        [JsonProperty("can_walk_in_lava", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanWalkInLava { get; set; } = new bool?();

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("is_amphibious", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsAmphibious { get; set; } = new bool?();
    }

    /// <summary>
    /// Allows this entity to generate paths that include water.
    /// </summary>
    public partial class NavigationSwim1160
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("avoid_damage_blocks", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AvoidDamageBlocks { get; set; }

        /// <summary>
        /// Tells the pathfinder to avoid portals (like nether portals) when finding a path
        /// </summary>
        [JsonProperty("avoid_portals", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AvoidPortals { get; set; } = new bool?();

        /// <summary>
        /// Whether or not the pathfinder should avoid tiles that are exposed to the sun when
        /// creating paths
        /// </summary>
        [JsonProperty("avoid_sun", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AvoidSun { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder to avoid water when creating a path
        /// </summary>
        [JsonProperty("avoid_water", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AvoidWater { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder that it can path through a closed door and break it
        /// </summary>
        [JsonProperty("can_break_doors", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanBreakDoors { get; set; } = new bool?();

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("can_float", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanFloat { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder that it can path through a closed door assuming the AI will open the
        /// door
        /// </summary>
        [JsonProperty("can_open_doors", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanOpenDoors { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder that it can path through a closed iron door assuming the AI will
        /// open the door
        /// </summary>
        [JsonProperty("can_open_iron_doors", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanOpenIronDoors { get; set; } = new bool?();

        /// <summary>
        /// Whether a path can be created through a door
        /// </summary>
        [JsonProperty("can_pass_doors", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanPassDoors { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder that it can start pathing when in the air
        /// </summary>
        [JsonProperty("can_path_from_air", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanPathFromAir { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder whether or not it can travel on the surface of the lava
        /// </summary>
        [JsonProperty("can_path_over_lava", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanPathOverLava { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder whether or not it can travel on the surface of the water
        /// </summary>
        [JsonProperty("can_path_over_water", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanPathOverWater { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder whether or not it will be pulled down by gravity while in water
        /// </summary>
        [JsonProperty("can_sink", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanSink { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder whether or not it can travel in lava like walking on ground
        /// </summary>
        [JsonProperty("can_walk_in_lava", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanWalkInLava { get; set; } = new bool?();

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("is_amphibious", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsAmphibious { get; set; } = new bool?();
    }

    /// <summary>
    /// Allows this entity to generate paths by walking around and jumping up and down a block
    /// like regular mobs.
    /// </summary>
    public partial class NavigationWalk
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("avoid_damage_blocks", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AvoidDamageBlocks { get; set; }

        /// <summary>
        /// Tells the pathfinder to avoid portals (like nether portals) when finding a path
        /// </summary>
        [JsonProperty("avoid_portals", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AvoidPortals { get; set; } = new bool?();

        /// <summary>
        /// Whether or not the pathfinder should avoid tiles that are exposed to the sun when
        /// creating paths
        /// </summary>
        [JsonProperty("avoid_sun", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AvoidSun { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder to avoid water when creating a path
        /// </summary>
        [JsonProperty("avoid_water", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AvoidWater { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder that it can path through a closed door and break it
        /// </summary>
        [JsonProperty("can_break_doors", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanBreakDoors { get; set; } = new bool?();

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("can_float", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanFloat { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder that it can path through a closed door assuming the AI will open the
        /// door
        /// </summary>
        [JsonProperty("can_open_doors", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanOpenDoors { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder that it can path through a closed iron door assuming the AI will
        /// open the door
        /// </summary>
        [JsonProperty("can_open_iron_doors", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanOpenIronDoors { get; set; } = new bool?();

        /// <summary>
        /// Whether a path can be created through a door
        /// </summary>
        [JsonProperty("can_pass_doors", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanPassDoors { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder that it can start pathing when in the air
        /// </summary>
        [JsonProperty("can_path_from_air", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanPathFromAir { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder whether or not it can travel on the surface of the lava
        /// </summary>
        [JsonProperty("can_path_over_lava", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanPathOverLava { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder whether or not it can travel on the surface of the water
        /// </summary>
        [JsonProperty("can_path_over_water", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanPathOverWater { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder whether or not it will be pulled down by gravity while in water
        /// </summary>
        [JsonProperty("can_sink", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanSink { get; set; } = new bool?();

        /// <summary>
        /// TODO description
        /// </summary>
        [JsonProperty("can_walk", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanWalk { get; set; } = new bool?();

        /// <summary>
        /// Tells the pathfinder whether or not it can travel in lava like walking on ground
        /// </summary>
        [JsonProperty("can_walk_in_lava", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanWalkInLava { get; set; } = new bool?();

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("is_amphibious", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsAmphibious { get; set; } = new bool?();
    }

    /// <summary>
    /// A component that applies a mob effect to entities that get within range.
    /// </summary>
    public partial class Npc1160
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("npc_data", NullValueHandling = NullValueHandling.Ignore)]
        public NpcData NpcData { get; set; }
    }

    /// <summary>
    /// UNDOCUMENTATED
    /// </summary>
    public partial class NpcData
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("picker_offsets", NullValueHandling = NullValueHandling.Ignore)]
        public PickerOffsets PickerOffsets { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("portrait_offsets", NullValueHandling = NullValueHandling.Ignore)]
        public PortraitOffsets PortraitOffsets { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("skin_list", NullValueHandling = NullValueHandling.Ignore)]
        public List<Skin> SkinList { get; set; }
    }

    /// <summary>
    /// UNDOCUMENTATED
    /// </summary>
    public partial class PickerOffsets
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("scale", NullValueHandling = NullValueHandling.Ignore)]
        public List<double> Scale { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("translate", NullValueHandling = NullValueHandling.Ignore)]
        public List<double> Translate { get; set; }
    }

    /// <summary>
    /// UNDOCUMENTATED
    /// </summary>
    public partial class PortraitOffsets
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("scale", NullValueHandling = NullValueHandling.Ignore)]
        public List<double> Scale { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("translate", NullValueHandling = NullValueHandling.Ignore)]
        public List<double> Translate { get; set; }
    }

    /// <summary>
    /// UNDOCUMENTATED
    /// </summary>
    public partial class Skin
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("variant", NullValueHandling = NullValueHandling.Ignore)]
        public long? Variant { get; set; }
    }

    /// <summary>
    /// Only usable by the Ender Dragon. Adds a trigger to call on this entity's death.
    /// </summary>
    public partial class OnDeath180
    {
        /// <summary>
        /// The event to run when the conditions for this trigger are met
        /// </summary>
        [JsonProperty("event", NullValueHandling = NullValueHandling.Ignore)]
        public string Event { get; set; }

        /// <summary>
        /// The list of conditions for this trigger
        /// </summary>
        [JsonProperty("filters", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject Filters { get; set; }

        /// <summary>
        /// The target of the event
        /// </summary>
        [JsonProperty("target", NullValueHandling = NullValueHandling.Ignore)]
        public Subject1160? Target { get; set; } = Subject1160.Self;
    }

    /// <summary>
    /// Adds a trigger that will run when a nearby entity of the same type as this entity becomes
    /// Angry.
    /// </summary>
    public partial class OnFriendlyAnger180
    {
        /// <summary>
        /// The event to run when the conditions for this trigger are met
        /// </summary>
        [JsonProperty("event", NullValueHandling = NullValueHandling.Ignore)]
        public string Event { get; set; }

        /// <summary>
        /// The list of conditions for this trigger
        /// </summary>
        [JsonProperty("filters", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject Filters { get; set; }

        /// <summary>
        /// The target of the event
        /// </summary>
        [JsonProperty("target", NullValueHandling = NullValueHandling.Ignore)]
        public Subject1160? Target { get; set; } = Subject1160.Self;
    }

    /// <summary>
    /// Adds a trigger to call when this entity takes damage.
    /// </summary>
    public partial class OnHurt180
    {
        /// <summary>
        /// The event to run when the conditions for this trigger are met
        /// </summary>
        [JsonProperty("event", NullValueHandling = NullValueHandling.Ignore)]
        public string Event { get; set; }

        /// <summary>
        /// The list of conditions for this trigger
        /// </summary>
        [JsonProperty("filters", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject Filters { get; set; }

        /// <summary>
        /// The target of the event
        /// </summary>
        [JsonProperty("target", NullValueHandling = NullValueHandling.Ignore)]
        public Subject1160? Target { get; set; } = Subject1160.Self;
    }

    /// <summary>
    /// Adds a trigger to call when this entity is attacked by the player.
    /// </summary>
    public partial class OnHurtByPlayer180
    {
        /// <summary>
        /// The event to run when the conditions for this trigger are met
        /// </summary>
        [JsonProperty("event", NullValueHandling = NullValueHandling.Ignore)]
        public string Event { get; set; }

        /// <summary>
        /// The list of conditions for this trigger
        /// </summary>
        [JsonProperty("filters", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject Filters { get; set; }

        /// <summary>
        /// The target of the event
        /// </summary>
        [JsonProperty("target", NullValueHandling = NullValueHandling.Ignore)]
        public Subject1160? Target { get; set; } = Subject1160.Self;
    }

    /// <summary>
    /// Adds a trigger to call when this entity is set on fire.
    /// </summary>
    public partial class OnIgnite180
    {
        /// <summary>
        /// The event to run when the conditions for this trigger are met
        /// </summary>
        [JsonProperty("event", NullValueHandling = NullValueHandling.Ignore)]
        public string Event { get; set; }

        /// <summary>
        /// The list of conditions for this trigger
        /// </summary>
        [JsonProperty("filters", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject Filters { get; set; }

        /// <summary>
        /// The target of the event
        /// </summary>
        [JsonProperty("target", NullValueHandling = NullValueHandling.Ignore)]
        public Subject1160? Target { get; set; } = Subject1160.Self;
    }

    /// <summary>
    /// Only usable by the Ender Dragon. Adds a trigger to call when this entity lands.
    /// </summary>
    public partial class OnStartLanding180
    {
        /// <summary>
        /// The event to run when the conditions for this trigger are met
        /// </summary>
        [JsonProperty("event", NullValueHandling = NullValueHandling.Ignore)]
        public string Event { get; set; }

        /// <summary>
        /// The list of conditions for this trigger
        /// </summary>
        [JsonProperty("filters", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject Filters { get; set; }

        /// <summary>
        /// The target of the event
        /// </summary>
        [JsonProperty("target", NullValueHandling = NullValueHandling.Ignore)]
        public Subject1160? Target { get; set; } = Subject1160.Self;
    }

    /// <summary>
    /// Only usable by the Ender Dragon. Adds a trigger to call when this entity starts flying.
    /// </summary>
    public partial class OnStartTakeoff180
    {
        /// <summary>
        /// The event to run when the conditions for this trigger are met
        /// </summary>
        [JsonProperty("event", NullValueHandling = NullValueHandling.Ignore)]
        public string Event { get; set; }

        /// <summary>
        /// The list of conditions for this trigger
        /// </summary>
        [JsonProperty("filters", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject Filters { get; set; }

        /// <summary>
        /// The target of the event
        /// </summary>
        [JsonProperty("target", NullValueHandling = NullValueHandling.Ignore)]
        public Subject1160? Target { get; set; } = Subject1160.Self;
    }

    /// <summary>
    /// Adds a trigger to call when this entity finds a target.
    /// </summary>
    public partial class OnTargetAcquired180
    {
        /// <summary>
        /// The event to run when the conditions for this trigger are met
        /// </summary>
        [JsonProperty("event", NullValueHandling = NullValueHandling.Ignore)]
        public string Event { get; set; }

        /// <summary>
        /// The list of conditions for this trigger
        /// </summary>
        [JsonProperty("filters", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject Filters { get; set; }

        /// <summary>
        /// The target of the event
        /// </summary>
        [JsonProperty("target", NullValueHandling = NullValueHandling.Ignore)]
        public Subject1160? Target { get; set; } = Subject1160.Self;
    }

    /// <summary>
    /// Adds a trigger to call when this entity loses the target it currently has.
    /// </summary>
    public partial class OnTargetEscape180
    {
        /// <summary>
        /// The event to run when the conditions for this trigger are met
        /// </summary>
        [JsonProperty("event", NullValueHandling = NullValueHandling.Ignore)]
        public string Event { get; set; }

        /// <summary>
        /// The list of conditions for this trigger
        /// </summary>
        [JsonProperty("filters", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject Filters { get; set; }

        /// <summary>
        /// The target of the event
        /// </summary>
        [JsonProperty("target", NullValueHandling = NullValueHandling.Ignore)]
        public Subject1160? Target { get; set; } = Subject1160.Self;
    }

    /// <summary>
    /// Adds a trigger to call when this pet's owner awakes after sleeping with the pet.
    /// </summary>
    public partial class OnWakeWithOwner180
    {
        /// <summary>
        /// The event to run when the conditions for this trigger are met
        /// </summary>
        [JsonProperty("event", NullValueHandling = NullValueHandling.Ignore)]
        public string Event { get; set; }

        /// <summary>
        /// The list of conditions for this trigger
        /// </summary>
        [JsonProperty("filters", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject Filters { get; set; }

        /// <summary>
        /// The target of the event
        /// </summary>
        [JsonProperty("target", NullValueHandling = NullValueHandling.Ignore)]
        public Subject1160? Target { get; set; } = Subject1160.Self;
    }

    /// <summary>
    /// Defines the entity's 'out of control' state.
    /// </summary>
    public partial class OutOfControl
    {
    }

    /// <summary>
    /// Defines the entity's 'peek' behavior, defining the events that should be called during it
    /// </summary>
    public partial class Peek180
    {
        /// <summary>
        /// Event to call when the entity is done peeking
        /// </summary>
        [JsonProperty("on_close", NullValueHandling = NullValueHandling.Ignore)]
        public Event? OnClose { get; set; }

        /// <summary>
        /// Event to call when the entity starts peeking
        /// </summary>
        [JsonProperty("on_open", NullValueHandling = NullValueHandling.Ignore)]
        public Event? OnOpen { get; set; }

        /// <summary>
        /// Event to call when the entity's target entity starts peeking
        /// </summary>
        [JsonProperty("on_target_open", NullValueHandling = NullValueHandling.Ignore)]
        public Event? OnTargetOpen { get; set; }
    }

    /// <summary>
    /// Defines whether an entity should be persistent in the game world.
    /// </summary>
    public partial class Persistent180
    {
    }

    /// <summary>
    /// Defines a dynamic type jump control that will change jump properties based on the speed
    /// modifier of the mob.
    /// </summary>
    public partial class Physics180
    {
        /// <summary>
        /// Whether or not the object collides with things.
        /// </summary>
        [JsonProperty("has_collision", NullValueHandling = NullValueHandling.Ignore)]
        public bool? HasCollision { get; set; } = new bool?();

        /// <summary>
        /// Whether or not the entity is affected by gravity.
        /// </summary>
        [JsonProperty("has_gravity", NullValueHandling = NullValueHandling.Ignore)]
        public bool? HasGravity { get; set; } = new bool?();
    }

    /// <summary>
    /// UNDOCUMENTATED
    /// </summary>
    public partial class PlayerExhaustion180
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("max", NullValueHandling = NullValueHandling.Ignore)]
        public double? Max { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("value", NullValueHandling = NullValueHandling.Ignore)]
        public double? Value { get; set; }
    }

    /// <summary>
    /// UNDOCUMENTATED
    /// </summary>
    public partial class PlayerExperience180
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("max", NullValueHandling = NullValueHandling.Ignore)]
        public double? Max { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("value", NullValueHandling = NullValueHandling.Ignore)]
        public double? Value { get; set; }
    }

    /// <summary>
    /// UNDOCUMENTATED
    /// </summary>
    public partial class PlayerLevel180
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("max", NullValueHandling = NullValueHandling.Ignore)]
        public double? Max { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("value", NullValueHandling = NullValueHandling.Ignore)]
        public double? Value { get; set; }
    }

    /// <summary>
    /// UNDOCUMENTATED
    /// </summary>
    public partial class PlayerSaturation180
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("value", NullValueHandling = NullValueHandling.Ignore)]
        public double? Value { get; set; }
    }

    /// <summary>
    /// Specifies costing information for mobs that prefer to walk on preferred paths.
    /// </summary>
    public partial class PreferredPath180
    {
        /// <summary>
        /// Cost for non-preferred blocks
        /// </summary>
        [JsonProperty("default_block_cost", NullValueHandling = NullValueHandling.Ignore)]
        public double? DefaultBlockCost { get; set; } = 0;

        /// <summary>
        /// Added cost for jumping up a node
        /// </summary>
        [JsonProperty("jump_cost", NullValueHandling = NullValueHandling.Ignore)]
        public long? JumpCost { get; set; } = 0;

        /// <summary>
        /// Distance mob can fall without taking damage
        /// </summary>
        [JsonProperty("max_fall_blocks", NullValueHandling = NullValueHandling.Ignore)]
        public long? MaxFallBlocks { get; set; } = 3;

        /// <summary>
        /// A list of blocks with their associated cost
        /// </summary>
        [JsonProperty("preferred_path_blocks")]
        public List<PreferredPathBlock> PreferredPathBlocks { get; set; }
    }

    /// <summary>
    /// Blocks cost
    /// </summary>
    public partial class PreferredPathBlock
    {
        [JsonProperty("blocks", NullValueHandling = NullValueHandling.Ignore)]
        public List<string> Blocks { get; set; }

        [JsonProperty("cost", NullValueHandling = NullValueHandling.Ignore)]
        public double? Cost { get; set; }
    }

    /// <summary>
    /// Allows the entity to be a thrown entity.
    /// </summary>
    public partial class MinecraftProjectileClass
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("anchor", NullValueHandling = NullValueHandling.Ignore)]
        public long? Anchor { get; set; }

        /// <summary>
        /// Determines the angle at which the projectile is thrown
        /// </summary>
        [JsonProperty("angle_offset", NullValueHandling = NullValueHandling.Ignore)]
        public double? AngleOffset { get; set; } = 0;

        /// <summary>
        /// If true, the entity hit will be set on fire
        /// </summary>
        [JsonProperty("catch_fire", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CatchFire { get; set; } = new bool?();

        /// <summary>
        /// If true, the projectile will produce additional particles when a critical hit happens
        /// </summary>
        [JsonProperty("crit_particle_on_hurt", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CritParticleOnHurt { get; set; } = new bool?();

        /// <summary>
        /// If true, this entity will be destroyed when hit
        /// </summary>
        [JsonProperty("destroy_on_hurt", NullValueHandling = NullValueHandling.Ignore)]
        public bool? DestroyOnHurt { get; set; } = new bool?();

        /// <summary>
        /// Entity Definitions defined here can't be hurt by the projectile
        /// </summary>
        [JsonProperty("filter", NullValueHandling = NullValueHandling.Ignore)]
        public string Filter { get; set; } = "";

        /// <summary>
        /// If true, whether the projectile causes fire is affected by the mob griefing game rule
        /// </summary>
        [JsonProperty("fire_affected_by_griefing", NullValueHandling = NullValueHandling.Ignore)]
        public bool? FireAffectedByGriefing { get; set; } = new bool?();

        /// <summary>
        /// The gravity applied to this entity when thrown. The higher the value, the faster the
        /// entity falls
        /// </summary>
        [JsonProperty("gravity", NullValueHandling = NullValueHandling.Ignore)]
        public double? Gravity { get; set; } = 0.05;

        /// <summary>
        /// The sound that plays when the projectile hits something
        /// </summary>
        [JsonProperty("hit_sound", NullValueHandling = NullValueHandling.Ignore)]
        public string HitSound { get; set; } = "";

        /// <summary>
        /// If true, the projectile homes in to the nearest entity
        /// </summary>
        [JsonProperty("homing", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Homing { get; set; } = new bool?();

        /// <summary>
        /// The fraction of the projectile's speed maintained every frame while traveling in air
        /// </summary>
        [JsonProperty("inertia", NullValueHandling = NullValueHandling.Ignore)]
        public double? Inertia { get; set; } = 0.99;

        /// <summary>
        /// If true, the projectile will be treated as dangerous to the players
        /// </summary>
        [JsonProperty("is_dangerous", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsDangerous { get; set; } = new bool?();

        /// <summary>
        /// If true, the projectile will knock back the entity it hits
        /// </summary>
        [JsonProperty("knockback", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Knockback { get; set; } = new bool?();

        /// <summary>
        /// If true, the entity hit will be struck by lightning
        /// </summary>
        [JsonProperty("lightning", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Lightning { get; set; } = new bool?();

        /// <summary>
        /// The fraction of the projectile's speed maintained every frame while traveling in water
        /// </summary>
        [JsonProperty("liquid_inertia", NullValueHandling = NullValueHandling.Ignore)]
        public double? LiquidInertia { get; set; } = 0.6;

        /// <summary>
        /// If true, the projectile can hit multiple entities per flight
        /// </summary>
        [JsonProperty("multiple_targets", NullValueHandling = NullValueHandling.Ignore)]
        public bool? MultipleTargets { get; set; } = new bool?();

        /// <summary>
        /// The offset from the entity's anchor where the projectile will spawn
        /// </summary>
        [JsonProperty("offset", NullValueHandling = NullValueHandling.Ignore)]
        public List<double> Offset { get; set; } = new List<double> {0.0,0.5,0.0};

        /// <summary>
        /// Time in seconds that the entity hit will be on fire for
        /// </summary>
        [JsonProperty("on_fire_time", NullValueHandling = NullValueHandling.Ignore)]
        public double? OnFireTime { get; set; } = 5;

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("on_hit", NullValueHandling = NullValueHandling.Ignore)]
        public OnHitClass OnHit { get; set; }

        /// <summary>
        /// Particle to use upon collision
        /// </summary>
        [JsonProperty("particle", NullValueHandling = NullValueHandling.Ignore)]
        public string Particle { get; set; } = "iconcrack";

        /// <summary>
        /// Defines the effect the arrow will apply to the entity it hits
        /// </summary>
        [JsonProperty("potion_effect", NullValueHandling = NullValueHandling.Ignore)]
        public long? PotionEffect { get; set; } = -1;

        /// <summary>
        /// Determines the velocity of the projectile
        /// </summary>
        [JsonProperty("power", NullValueHandling = NullValueHandling.Ignore)]
        public double? Power { get; set; } = 1.3;

        /// <summary>
        /// If true, this entity will be reflected back when hit
        /// </summary>
        [JsonProperty("reflect_on_hurt", NullValueHandling = NullValueHandling.Ignore)]
        public bool? ReflectOnHurt { get; set; } = new bool?();

        /// <summary>
        /// If true, damage will be randomized based on damage and speed
        /// </summary>
        [JsonProperty("semi_random_diff_damage", NullValueHandling = NullValueHandling.Ignore)]
        public bool? SemiRandomDiffDamage { get; set; } = new bool?();

        /// <summary>
        /// The sound that plays when the projectile is shot
        /// </summary>
        [JsonProperty("shoot_sound", NullValueHandling = NullValueHandling.Ignore)]
        public string ShootSound { get; set; } = "";

        /// <summary>
        /// If true, the projectile will be shot towards the target of the entity firing it
        /// </summary>
        [JsonProperty("shoot_target", NullValueHandling = NullValueHandling.Ignore)]
        public bool? ShootTarget { get; set; } = new bool?();

        /// <summary>
        /// If true, the projectile will bounce upon hit
        /// </summary>
        [JsonProperty("should_bounce", NullValueHandling = NullValueHandling.Ignore)]
        public bool? ShouldBounce { get; set; } = new bool?();

        /// <summary>
        /// If true, the projectile will be treated like a splash potion
        /// </summary>
        [JsonProperty("splash_potion", NullValueHandling = NullValueHandling.Ignore)]
        public bool? SplashPotion { get; set; } = new bool?();

        /// <summary>
        /// Radius in blocks of the 'splash' effect
        /// </summary>
        [JsonProperty("splash_range", NullValueHandling = NullValueHandling.Ignore)]
        public double? SplashRange { get; set; } = 4;

        /// <summary>
        /// The base accuracy. Accuracy is determined by the formula uncertaintyBase -
        /// difficultyLevel * uncertaintyMultiplier
        /// </summary>
        [JsonProperty("uncertainty_base", NullValueHandling = NullValueHandling.Ignore)]
        public double? UncertaintyBase { get; set; } = 0;

        /// <summary>
        /// Determines how much difficulty affects accuracy. Accuracy is determined by the formula
        /// uncertaintyBase - difficultyLevel * uncertaintyMultiplier
        /// </summary>
        [JsonProperty("uncertainty_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? UncertaintyMultiplier { get; set; } = 0;
    }

    /// <summary>
    /// UNDOCUMENTATED
    /// </summary>
    public partial class OnHitClass
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("catch_fire", NullValueHandling = NullValueHandling.Ignore)]
        public CatchFireClass CatchFire { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("definition_event", NullValueHandling = NullValueHandling.Ignore)]
        public DefinitionEventClass DefinitionEvent { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("douse_fire", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, object> DouseFire { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("impact_damage", NullValueHandling = NullValueHandling.Ignore)]
        public ImpactDamageClass ImpactDamage { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("particle_on_hit", NullValueHandling = NullValueHandling.Ignore)]
        public ParticleOnHitClass ParticleOnHit { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("remove_on_hit", NullValueHandling = NullValueHandling.Ignore)]
        public RemoveOnHitClass RemoveOnHit { get; set; }

        [JsonProperty("spawn_aoe_cloud", NullValueHandling = NullValueHandling.Ignore)]
        public SpawnAoeCloud SpawnAoeCloud { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("spawn_chance", NullValueHandling = NullValueHandling.Ignore)]
        public SpawnChanceClass SpawnChance { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("stick_in_ground", NullValueHandling = NullValueHandling.Ignore)]
        public StickInGroundClass StickInGround { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("teleport_owner", NullValueHandling = NullValueHandling.Ignore)]
        public TeleportOwnerClass TeleportOwner { get; set; }
    }

    /// <summary>
    /// UNDOCUMENTATED
    /// </summary>
    public partial class CatchFireClass
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("fire_affected_by_griefing", NullValueHandling = NullValueHandling.Ignore)]
        public bool? FireAffectedByGriefing { get; set; }
    }

    /// <summary>
    /// UNDOCUMENTATED
    /// </summary>
    public partial class DefinitionEventClass
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("affect_projectile", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AffectProjectile { get; set; }

        [JsonProperty("event_trigger", NullValueHandling = NullValueHandling.Ignore)]
        public Event? EventTrigger { get; set; }
    }

    /// <summary>
    /// UNDOCUMENTATED
    /// </summary>
    public partial class ImpactDamageClass
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("catch_fire", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CatchFire { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("damage", NullValueHandling = NullValueHandling.Ignore)]
        public long? Damage { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("destroy_on_hit", NullValueHandling = NullValueHandling.Ignore)]
        public bool? DestroyOnHit { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("filter", NullValueHandling = NullValueHandling.Ignore)]
        public string Filter { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("knockback", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Knockback { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("semi_random_diff_damage", NullValueHandling = NullValueHandling.Ignore)]
        public bool? SemiRandomDiffDamage { get; set; }
    }

    /// <summary>
    /// UNDOCUMENTATED
    /// </summary>
    public partial class ParticleOnHitClass
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("num_particles", NullValueHandling = NullValueHandling.Ignore)]
        public long? NumParticles { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("on_entity_hit", NullValueHandling = NullValueHandling.Ignore)]
        public bool? OnEntityHit { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("on_other_hit", NullValueHandling = NullValueHandling.Ignore)]
        public bool? OnOtherHit { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("particle_type", NullValueHandling = NullValueHandling.Ignore)]
        public string ParticleType { get; set; }
    }

    /// <summary>
    /// UNDOCUMENTATED
    /// </summary>
    public partial class RemoveOnHitClass
    {
    }

    public partial class SpawnAoeCloud
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("affect_owner", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AffectOwner { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("color", NullValueHandling = NullValueHandling.Ignore)]
        public List<long> Color { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("duration", NullValueHandling = NullValueHandling.Ignore)]
        public long? Duration { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("particle", NullValueHandling = NullValueHandling.Ignore)]
        public string Particle { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("potion", NullValueHandling = NullValueHandling.Ignore)]
        public long? Potion { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? Radius { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("radius_on_use", NullValueHandling = NullValueHandling.Ignore)]
        public double? RadiusOnUse { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("reapplication_delay", NullValueHandling = NullValueHandling.Ignore)]
        public long? ReapplicationDelay { get; set; }
    }

    /// <summary>
    /// UNDOCUMENTATED
    /// </summary>
    public partial class SpawnChanceClass
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("first_spawn_chance", NullValueHandling = NullValueHandling.Ignore)]
        public long? FirstSpawnChance { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("first_spawn_count", NullValueHandling = NullValueHandling.Ignore)]
        public long? FirstSpawnCount { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("first_spawn_percent_chance", NullValueHandling = NullValueHandling.Ignore)]
        public double? FirstSpawnPercentChance { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("second_spawn_chance", NullValueHandling = NullValueHandling.Ignore)]
        public long? SecondSpawnChance { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("second_spawn_count", NullValueHandling = NullValueHandling.Ignore)]
        public long? SecondSpawnCount { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("spawn_baby", NullValueHandling = NullValueHandling.Ignore)]
        public bool? SpawnBaby { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("spawn_definition", NullValueHandling = NullValueHandling.Ignore)]
        public string SpawnDefinition { get; set; }
    }

    /// <summary>
    /// UNDOCUMENTATED
    /// </summary>
    public partial class StickInGroundClass
    {
    }

    /// <summary>
    /// UNDOCUMENTATED
    /// </summary>
    public partial class TeleportOwnerClass
    {
    }

    /// <summary>
    /// Sets the distance through which the entity can push through.
    /// </summary>
    public partial class PushThrough180
    {
        /// <summary>
        /// The value of the entity's push-through, in blocks
        /// </summary>
        [JsonProperty("value", NullValueHandling = NullValueHandling.Ignore)]
        public double? Value { get; set; } = 0;
    }

    /// <summary>
    /// Defines what can push an entity between other entities and pistons.
    /// </summary>
    public partial class Pushable180
    {
        /// <summary>
        /// Whether the entity can be pushed by other entities.
        /// </summary>
        [JsonProperty("is_pushable", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsPushable { get; set; } = new bool?();

        /// <summary>
        /// Whether the entity can be pushed by pistons safely.
        /// </summary>
        [JsonProperty("is_pushable_by_piston", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsPushableByPiston { get; set; } = new bool?();
    }

    /// <summary>
    /// Attempts to trigger a raid at the entity's location.
    /// </summary>
    public partial class RaidTrigger180
    {
        /// <summary>
        /// Event to run we attempt to trigger a raid on the village.
        /// </summary>
        [JsonProperty("triggered_event", NullValueHandling = NullValueHandling.Ignore)]
        public Event? TriggeredEvent { get; set; }
    }

    /// <summary>
    /// Defines the entity's movement on the rails. An entity with this component is only allowed
    /// to move on the rail.
    /// </summary>
    public partial class RailMovement180
    {
        /// <summary>
        /// Maximum speed that this entity will move at when on the rail
        /// </summary>
        [JsonProperty("max_speed", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaxSpeed { get; set; } = 0.4;
    }

    /// <summary>
    /// Defines the behavior of the entity when the rail gets activated or deactivated.
    /// </summary>
    public partial class RailSensor180
    {
        /// <summary>
        /// If true, on tick this entity will trigger its on_deactivate behavior
        /// </summary>
        [JsonProperty("check_block_types", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CheckBlockTypes { get; set; } = new bool?();

        /// <summary>
        /// If true, this entity will eject all of its riders when it passes over an activated rail
        /// </summary>
        [JsonProperty("eject_on_activate", NullValueHandling = NullValueHandling.Ignore)]
        public bool? EjectOnActivate { get; set; } = new bool?();

        /// <summary>
        /// If true, this entity will eject all of its riders when it passes over a deactivated rail
        /// </summary>
        [JsonProperty("eject_on_deactivate", NullValueHandling = NullValueHandling.Ignore)]
        public bool? EjectOnDeactivate { get; set; } = new bool?();

        /// <summary>
        /// Event to call when the rail is activated
        /// </summary>
        [JsonProperty("on_activate", NullValueHandling = NullValueHandling.Ignore)]
        public Event? OnActivate { get; set; }

        /// <summary>
        /// Event to call when the rail is deactivated
        /// </summary>
        [JsonProperty("on_deactivate", NullValueHandling = NullValueHandling.Ignore)]
        public Event? OnDeactivate { get; set; }

        /// <summary>
        /// If true, command blocks will start ticking when passing over an activated rail
        /// </summary>
        [JsonProperty("tick_command_block_on_activate", NullValueHandling = NullValueHandling.Ignore)]
        public bool? TickCommandBlockOnActivate { get; set; } = new bool?();

        /// <summary>
        /// If false, command blocks will stop ticking when passing over a deactivated rail
        /// </summary>
        [JsonProperty("tick_command_block_on_deactivate", NullValueHandling = NullValueHandling.Ignore)]
        public bool? TickCommandBlockOnDeactivate { get; set; } = new bool?();
    }

    /// <summary>
    /// Defines the ravager's response to their melee attack being blocked.
    /// </summary>
    public partial class RavagerBlocked180
    {
        /// <summary>
        /// The strength with which blocking entities should be knocked back
        /// </summary>
        [JsonProperty("knockback_strength", NullValueHandling = NullValueHandling.Ignore)]
        public double? KnockbackStrength { get; set; } = 3;

        /// <summary>
        /// A list of weighted responses to the melee attack being blocked
        /// </summary>
        [JsonProperty("reaction_choices", NullValueHandling = NullValueHandling.Ignore)]
        public List<ReactionChoice> ReactionChoices { get; set; }
    }

    public partial class ReactionChoice
    {
        [JsonProperty("value", NullValueHandling = NullValueHandling.Ignore)]
        public ValueClass Value { get; set; }

        [JsonProperty("weight", NullValueHandling = NullValueHandling.Ignore)]
        public long? Weight { get; set; }
    }

    public partial class ValueClass
    {
        [JsonProperty("event", NullValueHandling = NullValueHandling.Ignore)]
        public string Event { get; set; }

        [JsonProperty("target", NullValueHandling = NullValueHandling.Ignore)]
        public Subject1160? Target { get; set; }
    }

    /// <summary>
    /// Determines whether this entity can be ridden. Allows specifying the different seat
    /// positions and quantity.
    /// </summary>
    public partial class Rideable1160
    {
        /// <summary>
        /// The seat that designates the driver of the entity
        /// </summary>
        [JsonProperty("controlling_seat", NullValueHandling = NullValueHandling.Ignore)]
        public long? ControllingSeat { get; set; } = 0;

        /// <summary>
        /// If true, this entity can't be interacted with if the entity interacting with it is
        /// crouching
        /// </summary>
        [JsonProperty("crouching_skip_interact", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CrouchingSkipInteract { get; set; } = new bool?();

        /// <summary>
        /// List of entities that can ride this entity
        /// </summary>
        [JsonProperty("family_types", NullValueHandling = NullValueHandling.Ignore)]
        public List<string> FamilyTypes { get; set; }

        /// <summary>
        /// The text to display when the player can interact with the entity when playing with
        /// Touch-screen controls
        /// </summary>
        [JsonProperty("interact_text", NullValueHandling = NullValueHandling.Ignore)]
        public string InteractText { get; set; } = "";

        /// <summary>
        /// If true, this entity will pull in entities that are in the correct family_types into any
        /// available seats
        /// </summary>
        [JsonProperty("pull_in_entities", NullValueHandling = NullValueHandling.Ignore)]
        public bool? PullInEntities { get; set; } = new bool?();

        /// <summary>
        /// If true, this entity will be picked when looked at by the rider
        /// </summary>
        [JsonProperty("rider_can_interact", NullValueHandling = NullValueHandling.Ignore)]
        public bool? RiderCanInteract { get; set; } = new bool?();

        /// <summary>
        /// The number of entities that can ride this entity at the same time
        /// </summary>
        [JsonProperty("seat_count", NullValueHandling = NullValueHandling.Ignore)]
        public long? SeatCount { get; set; } = 1;

        /// <summary>
        /// The list of positions and number of riders for each position for entities riding this
        /// entity
        /// </summary>
        [JsonProperty("seats", NullValueHandling = NullValueHandling.Ignore)]
        public Seats? Seats { get; set; }
    }

    public partial class SeatElement
    {
        /// <summary>
        /// Angle in degrees that a rider is allowed to rotate while riding this entity. Omit this
        /// property for no limit
        /// </summary>
        [JsonProperty("lock_rider_rotation", NullValueHandling = NullValueHandling.Ignore)]
        public double? LockRiderRotation { get; set; } = 181;

        /// <summary>
        /// Defines the maximum number of riders that can be riding this entity for this seat to be
        /// valid
        /// </summary>
        [JsonProperty("max_rider_count", NullValueHandling = NullValueHandling.Ignore)]
        public long? MaxRiderCount { get; set; } = 0;

        /// <summary>
        /// Defines the minimum number of riders that need to be riding this entity before this seat
        /// can be used
        /// </summary>
        [JsonProperty("min_rider_count", NullValueHandling = NullValueHandling.Ignore)]
        public long? MinRiderCount { get; set; } = 0;

        /// <summary>
        /// Position of this seat relative to this entity's position
        /// </summary>
        [JsonProperty("position", NullValueHandling = NullValueHandling.Ignore)]
        public List<double> Position { get; set; } = new List<double> {0.0,0.0,0.0};

        /// <summary>
        /// Offset to rotate riders by
        /// </summary>
        [JsonProperty("rotate_rider_by", NullValueHandling = NullValueHandling.Ignore)]
        public MolangNumber? RotateRiderBy { get; set; }
    }

    public partial class SeatsClass
    {
        /// <summary>
        /// Angle in degrees that a rider is allowed to rotate while riding this entity. Omit this
        /// property for no limit
        /// </summary>
        [JsonProperty("lock_rider_rotation", NullValueHandling = NullValueHandling.Ignore)]
        public double? LockRiderRotation { get; set; } = 181;

        /// <summary>
        /// Defines the maximum number of riders that can be riding this entity for this seat to be
        /// valid
        /// </summary>
        [JsonProperty("max_rider_count", NullValueHandling = NullValueHandling.Ignore)]
        public long? MaxRiderCount { get; set; } = 0;

        /// <summary>
        /// Defines the minimum number of riders that need to be riding this entity before this seat
        /// can be used
        /// </summary>
        [JsonProperty("min_rider_count", NullValueHandling = NullValueHandling.Ignore)]
        public long? MinRiderCount { get; set; } = 0;

        /// <summary>
        /// Position of this seat relative to this entity's position
        /// </summary>
        [JsonProperty("position", NullValueHandling = NullValueHandling.Ignore)]
        public List<double> Position { get; set; } = new List<double> {0.0,0.0,0.0};

        /// <summary>
        /// Offset to rotate riders by
        /// </summary>
        [JsonProperty("rotate_rider_by", NullValueHandling = NullValueHandling.Ignore)]
        public MolangNumber? RotateRiderBy { get; set; }
    }

    /// <summary>
    /// Allows the player to detect and manuever on the scaffolding block.
    /// </summary>
    public partial class ScaffoldingClimber180
    {
    }

    /// <summary>
    /// Sets the entity's visual size.
    /// </summary>
    public partial class Scale180
    {
        /// <summary>
        /// The value of the scale. 1.0 means the entity will appear at the scale they are defined in
        /// their model. Higher numbers make the entity bigger
        /// </summary>
        [JsonProperty("value", NullValueHandling = NullValueHandling.Ignore)]
        public double? Value { get; set; } = 0;
    }

    /// <summary>
    /// Defines the entity's size interpolation based on the entity's age.
    /// </summary>
    public partial class ScaleByAge180
    {
        /// <summary>
        /// Ending scale of the entity when it's fully grown
        /// </summary>
        [JsonProperty("end_scale", NullValueHandling = NullValueHandling.Ignore)]
        public double? EndScale { get; set; } = 1;

        /// <summary>
        /// Initial scale of the newborn entity
        /// </summary>
        [JsonProperty("start_scale", NullValueHandling = NullValueHandling.Ignore)]
        public double? StartScale { get; set; } = 1;
    }

    /// <summary>
    /// Defines a list of items the mob wants to share or pick up. Each item must have the
    /// following parameters:
    /// </summary>
    public partial class Scheduler1160
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("max_delay_secs", NullValueHandling = NullValueHandling.Ignore)]
        public long? MaxDelaySecs { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("min_delay_secs", NullValueHandling = NullValueHandling.Ignore)]
        public long? MinDelaySecs { get; set; }

        /// <summary>
        /// The list of triggers that fire when the conditions match the given filter criteria. If
        /// any filter criteria overlap the first defined event will be picked.
        /// </summary>
        [JsonProperty("scheduled_events", NullValueHandling = NullValueHandling.Ignore)]
        public List<ScheduledEventElement> ScheduledEvents { get; set; }
    }

    /// <summary>
    /// UNDOCUMENTATED
    /// </summary>
    public partial class ScheduledEventElement
    {
        [JsonProperty("event", NullValueHandling = NullValueHandling.Ignore)]
        public Event? Event { get; set; }

        [JsonProperty("filters", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject Filters { get; set; }
    }

    /// <summary>
    /// Defines a list of items the mob wants to share or pick up. Each item must have the
    /// following parameters:
    /// </summary>
    public partial class Shareables1160
    {
        /// <summary>
        /// A bucket for all other items in the game. Note this category is always least priority
        /// items.
        /// </summary>
        [JsonProperty("all_items", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AllItems { get; set; } = new bool?();

        /// <summary>
        /// Maximum number of this item the mob will hold.
        /// </summary>
        [JsonProperty("all_items_max_amount", NullValueHandling = NullValueHandling.Ignore)]
        public long? AllItemsMaxAmount { get; set; } = -1;

        /// <summary>
        /// Number of this item considered extra that the entity wants to share.
        /// </summary>
        [JsonProperty("all_items_surplus_amount", NullValueHandling = NullValueHandling.Ignore)]
        public long? AllItemsSurplusAmount { get; set; } = -1;

        /// <summary>
        /// Number of this item this entity wants to share.
        /// </summary>
        [JsonProperty("all_items_want_amount", NullValueHandling = NullValueHandling.Ignore)]
        public long? AllItemsWantAmount { get; set; } = -1;

        /// <summary>
        /// List of items that the entity wants to share
        /// </summary>
        [JsonProperty("items", NullValueHandling = NullValueHandling.Ignore)]
        public List<MinecraftShareablesItem> Items { get; set; }
    }

    public partial class MinecraftShareablesItem
    {
        /// <summary>
        /// Mob will admire the item after picking up by looking at it. For this to happen the mob
        /// needs to have an Admire component and an Admire goal.
        /// </summary>
        [JsonProperty("admire", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Admire { get; set; }

        /// <summary>
        /// Mob will barter for the item after picking it up. For this to work the mob needs to have
        /// a Barter component and a Barter goal.
        /// </summary>
        [JsonProperty("barter", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Barter { get; set; }

        /// <summary>
        /// Determines whether the mob will consume the item or not.
        /// </summary>
        [JsonProperty("consume_item", NullValueHandling = NullValueHandling.Ignore)]
        public bool? ConsumeItem { get; set; }

        /// <summary>
        /// Defines the item this entity wants to craft with the item defined above. Should be an
        /// item name.
        /// </summary>
        [JsonProperty("craft_into", NullValueHandling = NullValueHandling.Ignore)]
        public string CraftInto { get; set; }

        /// <summary>
        /// The name of the item
        /// </summary>
        [JsonProperty("item", NullValueHandling = NullValueHandling.Ignore)]
        public string Item { get; set; }

        /// <summary>
        /// Aux value for the item.
        /// </summary>
        [JsonProperty("item_aux", NullValueHandling = NullValueHandling.Ignore)]
        public long? ItemAux { get; set; }

        /// <summary>
        /// Maximum number of this item the mob will hold.
        /// </summary>
        [JsonProperty("max_amount", NullValueHandling = NullValueHandling.Ignore)]
        public long? MaxAmount { get; set; }

        /// <summary>
        /// Maximum number of this item the mob will pick up during a single goal tick.
        /// </summary>
        [JsonProperty("pickup_limit", NullValueHandling = NullValueHandling.Ignore)]
        public long? PickupLimit { get; set; }

        /// <summary>
        /// Prioritizes which items the entity prefers. 0 is the highest priority.
        /// </summary>
        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public long? Priority { get; set; }

        /// <summary>
        /// Determines whether the mob will try to put the item in its inventory if it has the
        /// inventory component and if it can't be equipped.
        /// </summary>
        [JsonProperty("stored_in_inventory", NullValueHandling = NullValueHandling.Ignore)]
        public bool? StoredInInventory { get; set; }

        /// <summary>
        /// Number of this item considered extra that the entity wants to share.
        /// </summary>
        [JsonProperty("surplus_amount", NullValueHandling = NullValueHandling.Ignore)]
        public long? SurplusAmount { get; set; }

        /// <summary>
        /// Number of this item this entity wants to have.
        /// </summary>
        [JsonProperty("want_amount", NullValueHandling = NullValueHandling.Ignore)]
        public long? WantAmount { get; set; }
    }

    /// <summary>
    /// Defines the entity's ranged attack behavior.
    /// </summary>
    public partial class Shooter1160
    {
        /// <summary>
        /// ID of the Potion effect to be applied on hit
        /// </summary>
        [JsonProperty("aux_val", NullValueHandling = NullValueHandling.Ignore)]
        public long? AuxVal { get; set; } = -1;

        /// <summary>
        /// Actor definition to use as projectile for the ranged attack. The actor definition must
        /// have the projectile component to be able to be shot as a projectile
        /// </summary>
        [JsonProperty("def", NullValueHandling = NullValueHandling.Ignore)]
        public string Def { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public string Type { get; set; }
    }

    /// <summary>
    /// Defines the entity's 'sit' state.
    /// </summary>
    public partial class Sittable180
    {
        /// <summary>
        /// Event to run when the entity enters the 'sit' state
        /// </summary>
        [JsonProperty("sit_event", NullValueHandling = NullValueHandling.Ignore)]
        public Event? SitEvent { get; set; }

        /// <summary>
        /// Event to run when the entity exits the 'sit' state
        /// </summary>
        [JsonProperty("stand_event", NullValueHandling = NullValueHandling.Ignore)]
        public Event? StandEvent { get; set; }
    }

    /// <summary>
    /// Skin ID value. Can be used to differentiate skins, such as base skins for villagers.
    /// </summary>
    public partial class SkinId180
    {
        /// <summary>
        /// The ID of the skin. By convention, 0 is the ID of the base skin
        /// </summary>
        [JsonProperty("value", NullValueHandling = NullValueHandling.Ignore)]
        public long? Value { get; set; } = 0;
    }

    /// <summary>
    /// Sets the entity's base volume for sound effects.
    /// </summary>
    public partial class SoundVolume180
    {
        /// <summary>
        /// The value of the volume the entity uses for sound effects
        /// </summary>
        [JsonProperty("value", NullValueHandling = NullValueHandling.Ignore)]
        public double? Value { get; set; } = 1;
    }

    /// <summary>
    /// Adds a timer after which this entity will spawn another entity or item (similar to
    /// vanilla's chicken's egg-laying behavior).
    /// </summary>
    public partial class SpawnEntity1160
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("entities", NullValueHandling = NullValueHandling.Ignore)]
        public Entities? Entities { get; set; }
    }

    public partial class EntitySpawn
    {
        /// <summary>
        /// If present, the specified entity will only spawn if the filter evaluates to true
        /// </summary>
        [JsonProperty("filters", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject Filters { get; set; }

        /// <summary>
        /// Maximum amount of time to randomly wait in seconds before another entity is spawned.
        /// </summary>
        [JsonProperty("max_wait_time", NullValueHandling = NullValueHandling.Ignore)]
        public long? MaxWaitTime { get; set; } = 600;

        /// <summary>
        /// Minimum amount of time to randomly wait in seconds before another entity is spawned.
        /// </summary>
        [JsonProperty("min_wait_time", NullValueHandling = NullValueHandling.Ignore)]
        public long? MinWaitTime { get; set; } = 300;

        /// <summary>
        /// The number of entities of this type to spawn each time that this triggers.
        /// </summary>
        [JsonProperty("num_to_spawn", NullValueHandling = NullValueHandling.Ignore)]
        public long? NumToSpawn { get; set; } = 1;

        /// <summary>
        /// If true, this the spawned entity will be leashed to the parent.
        /// </summary>
        [JsonProperty("should_leash", NullValueHandling = NullValueHandling.Ignore)]
        public bool? ShouldLeash { get; set; } = new bool?();

        /// <summary>
        /// If true, this component will only ever spawn the specified entity once.
        /// </summary>
        [JsonProperty("single_use", NullValueHandling = NullValueHandling.Ignore)]
        public bool? SingleUse { get; set; } = new bool?();

        /// <summary>
        /// Identifier of the entity to spawn, leave empty to spawn the item defined above instead.
        /// </summary>
        [JsonProperty("spawn_entity", NullValueHandling = NullValueHandling.Ignore)]
        public string SpawnEntity { get; set; } = "";

        /// <summary>
        /// Event to call when the entity is spawned.
        /// </summary>
        [JsonProperty("spawn_event", NullValueHandling = NullValueHandling.Ignore)]
        public string SpawnEvent { get; set; } = "minecraft:entity_born";

        /// <summary>
        /// Item identifier of the item to spawn.
        /// </summary>
        [JsonProperty("spawn_item", NullValueHandling = NullValueHandling.Ignore)]
        public string SpawnItem { get; set; } = "egg";

        /// <summary>
        /// Method to use to spawn the entity.
        /// </summary>
        [JsonProperty("spawn_method", NullValueHandling = NullValueHandling.Ignore)]
        public string SpawnMethod { get; set; } = "born";

        /// <summary>
        /// Identifier of the sound effect to play when the entity is spawned.
        /// </summary>
        [JsonProperty("spawn_sound", NullValueHandling = NullValueHandling.Ignore)]
        public string SpawnSound { get; set; } = "plop";
    }

    public partial class Entit
    {
        /// <summary>
        /// If present, the specified entity will only spawn if the filter evaluates to true
        /// </summary>
        [JsonProperty("filters", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject Filters { get; set; }

        /// <summary>
        /// Maximum amount of time to randomly wait in seconds before another entity is spawned.
        /// </summary>
        [JsonProperty("max_wait_time", NullValueHandling = NullValueHandling.Ignore)]
        public long? MaxWaitTime { get; set; } = 600;

        /// <summary>
        /// Minimum amount of time to randomly wait in seconds before another entity is spawned.
        /// </summary>
        [JsonProperty("min_wait_time", NullValueHandling = NullValueHandling.Ignore)]
        public long? MinWaitTime { get; set; } = 300;

        /// <summary>
        /// The number of entities of this type to spawn each time that this triggers.
        /// </summary>
        [JsonProperty("num_to_spawn", NullValueHandling = NullValueHandling.Ignore)]
        public long? NumToSpawn { get; set; } = 1;

        /// <summary>
        /// If true, this the spawned entity will be leashed to the parent.
        /// </summary>
        [JsonProperty("should_leash", NullValueHandling = NullValueHandling.Ignore)]
        public bool? ShouldLeash { get; set; } = new bool?();

        /// <summary>
        /// If true, this component will only ever spawn the specified entity once.
        /// </summary>
        [JsonProperty("single_use", NullValueHandling = NullValueHandling.Ignore)]
        public bool? SingleUse { get; set; } = new bool?();

        /// <summary>
        /// Identifier of the entity to spawn, leave empty to spawn the item defined above instead.
        /// </summary>
        [JsonProperty("spawn_entity", NullValueHandling = NullValueHandling.Ignore)]
        public string SpawnEntity { get; set; } = "";

        /// <summary>
        /// Event to call when the entity is spawned.
        /// </summary>
        [JsonProperty("spawn_event", NullValueHandling = NullValueHandling.Ignore)]
        public string SpawnEvent { get; set; } = "minecraft:entity_born";

        /// <summary>
        /// Item identifier of the item to spawn.
        /// </summary>
        [JsonProperty("spawn_item", NullValueHandling = NullValueHandling.Ignore)]
        public string SpawnItem { get; set; } = "egg";

        /// <summary>
        /// Method to use to spawn the entity.
        /// </summary>
        [JsonProperty("spawn_method", NullValueHandling = NullValueHandling.Ignore)]
        public string SpawnMethod { get; set; } = "born";

        /// <summary>
        /// Identifier of the sound effect to play when the entity is spawned.
        /// </summary>
        [JsonProperty("spawn_sound", NullValueHandling = NullValueHandling.Ignore)]
        public string SpawnSound { get; set; } = "plop";
    }

    /// <summary>
    /// Defines what mob effects to add and remove to the entity when adding this component.
    /// </summary>
    public partial class SpellEffects180
    {
        /// <summary>
        /// List of effects to add to this entity after adding this component
        /// </summary>
        [JsonProperty("add_effects", NullValueHandling = NullValueHandling.Ignore)]
        public List<AddEffectElement> AddEffects { get; set; }

        /// <summary>
        /// List of identifiers of effects to be removed from this entity after adding this component
        /// </summary>
        [JsonProperty("remove_effects", NullValueHandling = NullValueHandling.Ignore)]
        public string RemoveEffects { get; set; }
    }

    public partial class AddEffectClass
    {
        [JsonProperty("display_on_screen_animation", NullValueHandling = NullValueHandling.Ignore)]
        public bool? DisplayOnScreenAnimation { get; set; }

        [JsonProperty("duration", NullValueHandling = NullValueHandling.Ignore)]
        public long? Duration { get; set; }

        [JsonProperty("effect", NullValueHandling = NullValueHandling.Ignore)]
        public string Effect { get; set; }
    }

    /// <summary>
    /// Defines the entity's strength to carry items.
    /// </summary>
    public partial class Strength1160
    {
        /// <summary>
        /// The maximum strength of this entity
        /// </summary>
        [JsonProperty("max", NullValueHandling = NullValueHandling.Ignore)]
        public long? Max { get; set; } = 5;

        /// <summary>
        /// The initial value of the strength
        /// </summary>
        [JsonProperty("value", NullValueHandling = NullValueHandling.Ignore)]
        public long? Value { get; set; } = 1;
    }

    /// <summary>
    /// Defines the rules for a mob to be tamed by the player.
    /// </summary>
    public partial class Tameable180
    {
        /// <summary>
        /// The chance of taming the entity with each item use between 0.0 and 1.0, where 1.0 is 100%
        /// </summary>
        [JsonProperty("probability", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(PurpleMinMaxValueCheckConverter))]
        public double? Probability { get; set; } = 1;

        /// <summary>
        /// Event to run when this entity becomes tamed
        /// </summary>
        [JsonProperty("tame_event", NullValueHandling = NullValueHandling.Ignore)]
        public Event? TameEvent { get; set; }

        /// <summary>
        /// The list of items that can be used to tame this entity
        /// </summary>
        [JsonProperty("tame_items", NullValueHandling = NullValueHandling.Ignore)]
        public Items? TameItems { get; set; }
    }

    /// <summary>
    /// Allows the Entity to be tamed by mounting it.
    /// </summary>
    public partial class Tamemount1160
    {
        /// <summary>
        /// The amount the entity's temper will increase when mounted.
        /// </summary>
        [JsonProperty("attempt_temper_mod", NullValueHandling = NullValueHandling.Ignore)]
        public long? AttemptTemperMod { get; set; } = 5;

        /// <summary>
        /// The list of items that, if carried while interacting with the entity, will anger it.
        /// </summary>
        [JsonProperty("auto_reject_items", NullValueHandling = NullValueHandling.Ignore)]
        public AutoRejectItemsUnion? AutoRejectItems { get; set; }

        /// <summary>
        /// The list of items that can be used to increase the entity's temper and speed up the
        /// taming process
        /// </summary>
        [JsonProperty("feed_items", NullValueHandling = NullValueHandling.Ignore)]
        public FeedItems? FeedItems { get; set; }

        /// <summary>
        /// The text that shows in the feeding interact button
        /// </summary>
        [JsonProperty("feed_text", NullValueHandling = NullValueHandling.Ignore)]
        public string FeedText { get; set; }

        /// <summary>
        /// The maximum value for the entity's random starting temper
        /// </summary>
        [JsonProperty("max_temper", NullValueHandling = NullValueHandling.Ignore)]
        public long? MaxTemper { get; set; } = 100;

        /// <summary>
        /// The minimum value for the entity's random starting temper
        /// </summary>
        [JsonProperty("min_temper", NullValueHandling = NullValueHandling.Ignore)]
        public long? MinTemper { get; set; } = 0;

        /// <summary>
        /// The text that shows in the riding interact button
        /// </summary>
        [JsonProperty("ride_text", NullValueHandling = NullValueHandling.Ignore)]
        public string RideText { get; set; }

        /// <summary>
        /// Event that triggers when the entity becomes tamed
        /// </summary>
        [JsonProperty("tame_event", NullValueHandling = NullValueHandling.Ignore)]
        public Event? TameEvent { get; set; }
    }

    /// <summary>
    /// The list of items that this entity dislikes and will cause it to get angry if used while
    /// untamed.
    /// </summary>
    public partial class AutoRejectItemElement
    {
        /// <summary>
        /// Name of the item this entity dislikes and will cause it to get angry if used while untamed
        /// </summary>
        [JsonProperty("item", NullValueHandling = NullValueHandling.Ignore)]
        public string Item { get; set; }
    }

    /// <summary>
    /// The list of items that this entity dislikes and will cause it to get angry if used while
    /// untamed.
    /// </summary>
    public partial class AutoRejectItemsClass
    {
        /// <summary>
        /// Name of the item this entity dislikes and will cause it to get angry if used while untamed
        /// </summary>
        [JsonProperty("item", NullValueHandling = NullValueHandling.Ignore)]
        public string Item { get; set; }
    }

    /// <summary>
    /// The list of items that can be used to increase the entity's temper and speed up the
    /// taming process
    /// </summary>
    public partial class FeedItemElement
    {
        /// <summary>
        /// Name of the item this entity likes and can be used to increase this entity's temper
        /// </summary>
        [JsonProperty("item", NullValueHandling = NullValueHandling.Ignore)]
        public string Item { get; set; }

        /// <summary>
        /// The amount of temper this entity gains when fed this item
        /// </summary>
        [JsonProperty("temper_mod", NullValueHandling = NullValueHandling.Ignore)]
        public double? TemperMod { get; set; } = 0;
    }

    /// <summary>
    /// The list of items that can be used to increase the entity's temper and speed up the
    /// taming process
    /// </summary>
    public partial class FeedItemsClass
    {
        /// <summary>
        /// Name of the item this entity likes and can be used to increase this entity's temper
        /// </summary>
        [JsonProperty("item", NullValueHandling = NullValueHandling.Ignore)]
        public string Item { get; set; }

        /// <summary>
        /// The amount of temper this entity gains when fed this item
        /// </summary>
        [JsonProperty("temper_mod", NullValueHandling = NullValueHandling.Ignore)]
        public double? TemperMod { get; set; } = 0;
    }

    /// <summary>
    /// Defines the entity's range within which it can see or sense other entities to target them.
    /// </summary>
    public partial class TargetNearbySensor180
    {
        /// <summary>
        /// Maximum distance in blocks that another entity will be considered in the 'inside' range
        /// </summary>
        [JsonProperty("inside_range", NullValueHandling = NullValueHandling.Ignore)]
        public double? InsideRange { get; set; } = 1;

        /// <summary>
        /// Whether the other entity needs to be visible to trigger 'inside' events
        /// </summary>
        [JsonProperty("must_see", NullValueHandling = NullValueHandling.Ignore)]
        public bool? MustSee { get; set; } = new bool?();

        /// <summary>
        /// Event to call when an entity gets in the inside range. Can specify 'event' for the name
        /// of the event and 'target' for the target of the event
        /// </summary>
        [JsonProperty("on_inside_range", NullValueHandling = NullValueHandling.Ignore)]
        public Event? OnInsideRange { get; set; }

        /// <summary>
        /// Event to call when an entity gets in the outside range. Can specify 'event' for the name
        /// of the event and 'target' for the target of the event
        /// </summary>
        [JsonProperty("on_outside_range", NullValueHandling = NullValueHandling.Ignore)]
        public Event? OnOutsideRange { get; set; }

        /// <summary>
        /// Event to call when an entity exits visual range. Can specify 'event' for the name of the
        /// event and 'target' for the target of the event
        /// </summary>
        [JsonProperty("on_vision_lost_inside_range", NullValueHandling = NullValueHandling.Ignore)]
        public Event? OnVisionLostInsideRange { get; set; }

        /// <summary>
        /// Maximum distance in blocks that another entity will be considered in the 'outside' range
        /// </summary>
        [JsonProperty("outside_range", NullValueHandling = NullValueHandling.Ignore)]
        public double? OutsideRange { get; set; } = 5;
    }

    /// <summary>
    /// Defines an entity's teleporting behavior.
    /// </summary>
    public partial class Teleport180
    {
        /// <summary>
        /// Modifies the chance that the entity will teleport if the entity is in darkness
        /// </summary>
        [JsonProperty("dark_teleport_chance", NullValueHandling = NullValueHandling.Ignore)]
        public double? DarkTeleportChance { get; set; } = 0.01;

        /// <summary>
        /// Modifies the chance that the entity will teleport if the entity is in daylight
        /// </summary>
        [JsonProperty("light_teleport_chance", NullValueHandling = NullValueHandling.Ignore)]
        public double? LightTeleportChance { get; set; } = 0.01;

        /// <summary>
        /// Maximum amount of time in seconds between random teleports
        /// </summary>
        [JsonProperty("max_random_teleport_time", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaxRandomTeleportTime { get; set; } = 20;

        /// <summary>
        /// Minimum amount of time in seconds between random teleports
        /// </summary>
        [JsonProperty("min_random_teleport_time", NullValueHandling = NullValueHandling.Ignore)]
        public double? MinRandomTeleportTime { get; set; } = 0;

        /// <summary>
        /// Entity will teleport to a random position within the area defined by this cube
        /// </summary>
        [JsonProperty("random_teleport_cube", NullValueHandling = NullValueHandling.Ignore)]
        public List<double> RandomTeleportCube { get; set; } = new List<double> {32.0,16.0,32.0};

        /// <summary>
        /// If true, the entity will teleport randomly
        /// </summary>
        [JsonProperty("random_teleports", NullValueHandling = NullValueHandling.Ignore)]
        public bool? RandomTeleports { get; set; } = new bool?();

        /// <summary>
        /// Maximum distance the entity will teleport when chasing a target
        /// </summary>
        [JsonProperty("target_distance", NullValueHandling = NullValueHandling.Ignore)]
        public double? TargetDistance { get; set; } = 16;

        /// <summary>
        /// The chance that the entity will teleport between 0.0 and 1.0. 1.0 means 100%
        /// </summary>
        [JsonProperty("target_teleport_chance", NullValueHandling = NullValueHandling.Ignore)]
        public double? TargetTeleportChance { get; set; } = 1;
    }

    /// <summary>
    /// Defines if the entity ticks the world and the radius around it to tick.
    /// </summary>
    public partial class TickWorld180
    {
        /// <summary>
        /// The distance at which the closest player has to be before this entity despawns. This
        /// option will be ignored if never_despawn is true. Min: 128 blocks.
        /// </summary>
        [JsonProperty("distance_to_players", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(TentacledMinMaxValueCheckConverter))]
        public double? DistanceToPlayers { get; set; } = 128;

        /// <summary>
        /// If true, this entity will not despawn even if players are far away. If false,
        /// distance_to_players will be used to determine when to despawn.
        /// </summary>
        [JsonProperty("never_despawn", NullValueHandling = NullValueHandling.Ignore)]
        public bool? NeverDespawn { get; set; } = new bool?();

        /// <summary>
        /// The area around the entity to tick. Default: 2. Allowed range: 2-6.
        /// </summary>
        [JsonProperty("radius", NullValueHandling = NullValueHandling.Ignore)]
        public long? Radius { get; set; } = 2;
    }

    /// <summary>
    /// Adds a timer after which an event will fire.
    /// </summary>
    public partial class Timer180
    {
        /// <summary>
        /// If true, the timer will restart every time after it fires
        /// </summary>
        [JsonProperty("looping", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Looping { get; set; } = new bool?();

        /// <summary>
        /// This is a list of objects, representing one value in seconds that can be picked before
        /// firing the event and an optional weight. Incompatible with time.
        /// </summary>
        [JsonProperty("random_time_choices", NullValueHandling = NullValueHandling.Ignore)]
        public List<RandomTimeChoices> RandomTimeChoices { get; set; }

        /// <summary>
        /// If true, the amount of time on the timer will be random between the min and max values
        /// specified in time
        /// </summary>
        [JsonProperty("randomInterval", NullValueHandling = NullValueHandling.Ignore)]
        public bool? RandomInterval { get; set; } = new bool?();

        /// <summary>
        /// Amount of time in seconds for the timer. Can be specified as a number or a pair of
        /// numbers (min and max). Incompatible with random_time_choices.
        /// </summary>
        [JsonProperty("time", NullValueHandling = NullValueHandling.Ignore)]
        public AttackCooldownTime? Time { get; set; }

        /// <summary>
        /// Event to fire when the time on the timer runs out
        /// </summary>
        [JsonProperty("time_down_event", NullValueHandling = NullValueHandling.Ignore)]
        public Event? TimeDownEvent { get; set; }
    }

    /// <summary>
    /// TODO description: random time choices
    /// </summary>
    public partial class RandomTimeChoices
    {
        /// <summary>
        /// TODO description: value
        /// </summary>
        [JsonProperty("value", NullValueHandling = NullValueHandling.Ignore)]
        public long? Value { get; set; }

        /// <summary>
        /// TODO description: weight
        /// </summary>
        [JsonProperty("weight", NullValueHandling = NullValueHandling.Ignore)]
        public long? Weight { get; set; }
    }

    /// <summary>
    /// UNDOCUMENTATED
    /// </summary>
    public partial class TradeResupply1160
    {
    }

    /// <summary>
    /// Defines this entity's ability to trade with players.
    /// </summary>
    public partial class TradeTable180
    {
        /// <summary>
        /// Determines when the mob transforms, if the trades should be converted when the new mob
        /// has a economy_trade_table. When the trades are converted, the mob will generate a new
        /// trade list with their new trade table, but then it will try to convert any of the same
        /// trades over to have the same enchantments and user data. For example, if the original has
        /// a Emerald to Enchanted Iron Sword (Sharpness 1), and the new trade also has an Emerald
        /// for Enchanted Iron Sword, then the enchantment will be Sharpness 1.
        /// </summary>
        [JsonProperty("convert_trades_economy", NullValueHandling = NullValueHandling.Ignore)]
        public bool? ConvertTradesEconomy { get; set; } = new bool?();

        /// <summary>
        /// Name to be displayed while trading with this entity.
        /// </summary>
        [JsonProperty("display_name", NullValueHandling = NullValueHandling.Ignore)]
        public string DisplayName { get; set; }

        /// <summary>
        /// Used to determine if trading with entity opens the new trade screen.
        /// </summary>
        [JsonProperty("new_screen", NullValueHandling = NullValueHandling.Ignore)]
        public bool? NewScreen { get; set; } = new bool?();

        /// <summary>
        /// Determines if the trades should persist when the mob transforms. This makes it so that
        /// the next time the mob is transformed to something with a trade_table or
        /// economy_trade_table, then it keeps their trades.
        /// </summary>
        [JsonProperty("persist_trades", NullValueHandling = NullValueHandling.Ignore)]
        public bool? PersistTrades { get; set; } = new bool?();

        /// <summary>
        /// File path relative to the resource pack root for this entity's trades.
        /// </summary>
        [JsonProperty("table", NullValueHandling = NullValueHandling.Ignore)]
        public string Table { get; set; }
    }

    /// <summary>
    /// Defines the entity's trail to carry items.
    /// </summary>
    public partial class Trail1160
    {
        /// <summary>
        /// The type of block you wish to be spawned by the entity as it move about the world. Solid
        /// blocks may not be spawned at an offset of (0,0,0).
        /// </summary>
        [JsonProperty("block_type", NullValueHandling = NullValueHandling.Ignore)]
        public string BlockType { get; set; } = "air";

        /// <summary>
        /// One or more conditions that must be met in order to cause the chosen block type to spawn.
        /// </summary>
        [JsonProperty("spawn_filter", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject SpawnFilter { get; set; }

        /// <summary>
        /// The distance from the entities current position to spawn the block. Capped at up to 16
        /// blocks away. The X value is left/right(-/+), the Z value is backward/forward(-/+), the Y
        /// value is below/above(-/+).
        /// </summary>
        [JsonProperty("spawn_offset", NullValueHandling = NullValueHandling.Ignore)]
        public List<double> SpawnOffset { get; set; } = new List<double> {0.0,0.0,0.0};
    }

    /// <summary>
    /// Defines this entity's ability to trade with players.
    /// </summary>
    public partial class Transformation1160
    {
        /// <summary>
        /// List of components to add to the entity after the transformation
        /// </summary>
        [JsonProperty("add", NullValueHandling = NullValueHandling.Ignore)]
        public Add Add { get; set; }

        /// <summary>
        /// Sound to play when the transformation starts
        /// </summary>
        [JsonProperty("begin_transform_sound", NullValueHandling = NullValueHandling.Ignore)]
        public string BeginTransformSound { get; set; }

        /// <summary>
        /// Defines the properties of the delay for the transformation
        /// </summary>
        [JsonProperty("delay", NullValueHandling = NullValueHandling.Ignore)]
        public DelayUnion? Delay { get; set; }

        /// <summary>
        /// Cause the entity to drop all equipment upon transformation
        /// </summary>
        [JsonProperty("drop_equipment", NullValueHandling = NullValueHandling.Ignore)]
        public bool? DropEquipment { get; set; } = new bool?();

        /// <summary>
        /// Cause the entity to drop all items in inventory upon transformation
        /// </summary>
        [JsonProperty("drop_inventory", NullValueHandling = NullValueHandling.Ignore)]
        public bool? DropInventory { get; set; } = new bool?();

        /// <summary>
        /// Entity Definition that this entity will transform into
        /// </summary>
        [JsonProperty("into", NullValueHandling = NullValueHandling.Ignore)]
        public string Into { get; set; } = "";

        /// <summary>
        /// If this entity has trades and has leveled up, it should maintain that level after
        /// transformation.
        /// </summary>
        [JsonProperty("keep_level", NullValueHandling = NullValueHandling.Ignore)]
        public bool? KeepLevel { get; set; } = new bool?();

        /// <summary>
        /// If this entity is owned by another entity, it should remain owned after transformation.
        /// </summary>
        [JsonProperty("keep_owner", NullValueHandling = NullValueHandling.Ignore)]
        public bool? KeepOwner { get; set; } = new bool?();

        /// <summary>
        /// Cause the entity to keep equipment after going through transformation
        /// </summary>
        [JsonProperty("preserve_equipment", NullValueHandling = NullValueHandling.Ignore)]
        public bool? PreserveEquipment { get; set; } = new bool?();

        /// <summary>
        /// Sound to play when the entity is done transforming
        /// </summary>
        [JsonProperty("transformation_sound", NullValueHandling = NullValueHandling.Ignore)]
        public string TransformationSound { get; set; } = "";
    }

    /// <summary>
    /// List of components to add to the entity after the transformation
    /// </summary>
    public partial class Add
    {
        /// <summary>
        /// Names of component groups to add
        /// </summary>
        [JsonProperty("component_groups", NullValueHandling = NullValueHandling.Ignore)]
        public List<string> ComponentGroups { get; set; }
    }

    public partial class DelayClass
    {
        /// <summary>
        /// Chance that the entity will look for nearby blocks that can speed up the transformation.
        /// Value must be between 0.0 and 1.0
        /// </summary>
        [JsonProperty("block_assist_chance", NullValueHandling = NullValueHandling.Ignore)]
        public double? BlockAssistChance { get; set; } = 0;

        /// <summary>
        /// Chance that, once a block is found, will help speed up the transformation
        /// </summary>
        [JsonProperty("block_chance", NullValueHandling = NullValueHandling.Ignore)]
        public double? BlockChance { get; set; } = 0;

        /// <summary>
        /// Maximum number of blocks the entity will look for to aid in the transformation. If not
        /// defined or set to 0, it will be set to the block radius
        /// </summary>
        [JsonProperty("block_max", NullValueHandling = NullValueHandling.Ignore)]
        public long? BlockMax { get; set; } = 0;

        /// <summary>
        /// Distance in Blocks that the entity will search for blocks that can help the transformation
        /// </summary>
        [JsonProperty("block_radius", NullValueHandling = NullValueHandling.Ignore)]
        public long? BlockRadius { get; set; } = 0;

        /// <summary>
        /// List of blocks that can help the transformation of this entity
        /// </summary>
        [JsonProperty("block_types", NullValueHandling = NullValueHandling.Ignore)]
        public List<string> BlockTypes { get; set; }

        /// <summary>
        /// Time in seconds before the entity transforms
        /// </summary>
        [JsonProperty("value", NullValueHandling = NullValueHandling.Ignore)]
        public double? Value { get; set; } = 0;
    }

    /// <summary>
    /// UNDOCUMENTATED
    /// </summary>
    public partial class Trust180
    {
    }

    /// <summary>
    /// Defines the rules for a mob to trust players.
    /// </summary>
    public partial class Trusting180
    {
        /// <summary>
        /// The chance of the entity trusting with each item use between 0.0 and 1.0, where 1.0 is
        /// 100%
        /// </summary>
        [JsonProperty("probability", NullValueHandling = NullValueHandling.Ignore)]
        public double? Probability { get; set; } = 1;

        /// <summary>
        /// Event to run when this entity becomes trusting
        /// </summary>
        [JsonProperty("trust_event", NullValueHandling = NullValueHandling.Ignore)]
        public Event? TrustEvent { get; set; }

        /// <summary>
        /// The list of items that can be used to get the entity to trust players
        /// </summary>
        [JsonProperty("trust_items", NullValueHandling = NullValueHandling.Ignore)]
        public List<string> TrustItems { get; set; }
    }

    /// <summary>
    /// Defines the families this entity belongs to.
    /// </summary>
    public partial class TypeFamily180
    {
        /// <summary>
        /// List of family names
        /// </summary>
        [JsonProperty("family")]
        public List<string> Family { get; set; }
    }

    /// <summary>
    /// UNDOCUMENTATED
    /// </summary>
    public partial class UnderwaterMovement180
    {
        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("value", NullValueHandling = NullValueHandling.Ignore)]
        public double? Value { get; set; }
    }

    /// <summary>
    /// Used to differentiate the component group of a variant of an entity from others (e.g.
    /// ocelot, villager) Parameters
    /// </summary>
    public partial class Variant180
    {
        /// <summary>
        /// The ID of the variant. By convention, 0 is the ID of the base entity
        /// </summary>
        [JsonProperty("value", NullValueHandling = NullValueHandling.Ignore)]
        public long? Value { get; set; } = 0;
    }

    /// <summary>
    /// Sets the speed multiplier for this entity's walk animation speed.
    /// </summary>
    public partial class WalkAnimationSpeed180
    {
        /// <summary>
        /// The higher the number, the faster the animation for walking plays. A value of 1.0 means
        /// normal speed, while 2.0 means twice as fast
        /// </summary>
        [JsonProperty("value", NullValueHandling = NullValueHandling.Ignore)]
        public double? Value { get; set; } = 1;
    }

    /// <summary>
    /// Sets that this entity wants to become a jockey.
    /// </summary>
    public partial class WantsJockey1160
    {
    }

    /// <summary>
    /// TODO description
    /// </summary>
    public partial class WaterMovement180
    {
        /// <summary>
        /// Drag factor to determine movement speed when in water.
        /// </summary>
        [JsonProperty("drag_factor", NullValueHandling = NullValueHandling.Ignore)]
        public double? DragFactor { get; set; } = 0.8;
    }

    /// <summary>
    /// The description of the this entity
    /// </summary>
    public partial class Description
    {
        /// <summary>
        /// Sets the mapping of internal animation / animation controllers references to actual
        /// animations. This is a JSON Object of name/animation pairs
        /// </summary>
        [JsonProperty("animations", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, string> Animations { get; set; }

        /// <summary>
        /// Sets the identifier for this entity's description.
        /// </summary>
        [JsonProperty("identifier")]
        public string Identifier { get; set; }

        /// <summary>
        /// Sets whether or not this entity is experimental. Experimental entities are only enabled
        /// when the experimental toggle is enabled.
        /// </summary>
        [JsonProperty("is_experimental", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsExperimental { get; set; }

        /// <summary>
        /// Sets whether or not this entity has a spawn egg in the creative ui.
        /// </summary>
        [JsonProperty("is_spawnable", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsSpawnable { get; set; }

        /// <summary>
        /// Sets whether or not we can summon this entity using commands such as /summon.
        /// </summary>
        [JsonProperty("is_summonable", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsSummonable { get; set; }

        /// <summary>
        /// Sets the name for the Vanilla Minecraft identifier this entity will use to build itself
        /// from.
        /// </summary>
        [JsonProperty("runtime_identifier", NullValueHandling = NullValueHandling.Ignore)]
        public string RuntimeIdentifier { get; set; }

        /// <summary>
        /// Sets the mapping of internal animation controller references to actual animation
        /// controller. This is a JSON Array of name/animation-controller pairs
        /// </summary>
        [JsonProperty("scripts", NullValueHandling = NullValueHandling.Ignore)]
        public Scripts Scripts { get; set; }
    }

    /// <summary>
    /// Sets the mapping of internal animation controller references to actual animation
    /// controller. This is a JSON Array of name/animation-controller pairs
    /// </summary>
    public partial class Scripts
    {
        /// <summary>
        /// Tells minecraft to run which animation / animation controllers and under what conditions
        /// </summary>
        [JsonProperty("animate", NullValueHandling = NullValueHandling.Ignore)]
        public List<AnimationScript> Animate { get; set; }
    }

    /// <summary>
    /// Event called on an entity that is spawned through two entities breeding.
    ///
    /// Event called on an entity that is placed in the level.
    ///
    /// Event called on an entity that transforms into another entity.
    ///
    /// Event called on an entity whose fuse is lit and is ready to explode.
    /// </summary>
    public partial class EventBase
    {
        /// <summary>
        /// The components groups to be added to this entity
        /// </summary>
        [JsonProperty("add", NullValueHandling = NullValueHandling.Ignore)]
        public AddAndRemove Add { get; set; }

        [JsonProperty("filters", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject Filters { get; set; }

        [JsonProperty("randomize", NullValueHandling = NullValueHandling.Ignore)]
        public List<Randomize> Randomize { get; set; }

        /// <summary>
        /// The components groups and all its components to be removed
        /// </summary>
        [JsonProperty("remove", NullValueHandling = NullValueHandling.Ignore)]
        public AddAndRemove Remove { get; set; }

        /// <summary>
        /// A series of filters and components to be added
        /// </summary>
        [JsonProperty("sequence", NullValueHandling = NullValueHandling.Ignore)]
        public List<Sequence> Sequence { get; set; }

        /// <summary>
        /// The event to run
        /// </summary>
        [JsonProperty("trigger", NullValueHandling = NullValueHandling.Ignore)]
        public string Trigger { get; set; }
    }

    /// <summary>
    /// The components groups to be added to this entity
    ///
    /// The components groups to add or remove
    ///
    /// TODO description: add
    ///
    /// TODO description: remove
    ///
    /// The components groups and all its components to be removed
    /// </summary>
    public partial class AddAndRemove
    {
        /// <summary>
        /// The components groups to add or remove
        /// </summary>
        [JsonProperty("component_groups", NullValueHandling = NullValueHandling.Ignore)]
        public List<string> ComponentGroups { get; set; } = new List<string>();
    }

    /// <summary>
    /// TODO description: randomize
    /// </summary>
    public partial class Randomize
    {
        /// <summary>
        /// TODO description: add
        /// </summary>
        [JsonProperty("add", NullValueHandling = NullValueHandling.Ignore)]
        public AddAndRemove Add { get; set; }

        /// <summary>
        /// TODO description: remove
        /// </summary>
        [JsonProperty("remove", NullValueHandling = NullValueHandling.Ignore)]
        public AddAndRemove Remove { get; set; }

        /// <summary>
        /// UNDOCUMENTATED
        /// </summary>
        [JsonProperty("trigger", NullValueHandling = NullValueHandling.Ignore)]
        public string Trigger { get; set; }

        /// <summary>
        /// TODO description: weight
        /// </summary>
        [JsonProperty("weight")]
        public double Weight { get; set; }
    }

    /// <summary>
    /// TODO description: sequence
    ///
    /// Event called on an entity that is spawned through two entities breeding.
    ///
    /// Event called on an entity that is placed in the level.
    ///
    /// Event called on an entity that transforms into another entity.
    ///
    /// Event called on an entity whose fuse is lit and is ready to explode.
    /// </summary>
    public partial class Sequence
    {
        /// <summary>
        /// The components groups to be added to this entity
        /// </summary>
        [JsonProperty("add", NullValueHandling = NullValueHandling.Ignore)]
        public AddAndRemove Add { get; set; }

        [JsonProperty("filters", NullValueHandling = NullValueHandling.Ignore)]
        public CustomFilterObject Filters { get; set; }

        [JsonProperty("randomize", NullValueHandling = NullValueHandling.Ignore)]
        public List<Randomize> Randomize { get; set; }

        /// <summary>
        /// The components groups and all its components to be removed
        /// </summary>
        [JsonProperty("remove", NullValueHandling = NullValueHandling.Ignore)]
        public AddAndRemove Remove { get; set; }

        /// <summary>
        /// A series of filters and components to be added
        /// </summary>
        [JsonProperty("sequence", NullValueHandling = NullValueHandling.Ignore)]
        public List<Sequence> SequenceSequence { get; set; }

        /// <summary>
        /// The event to run
        /// </summary>
        [JsonProperty("trigger", NullValueHandling = NullValueHandling.Ignore)]
        public string Trigger { get; set; }
    }

    /// <summary>
    /// The target of the event
    /// </summary>
    public enum Target { Baby, Block, Damager, Other, Parent, Player, Self, Target };

    /// <summary>
    /// TODO
    /// </summary>
    public enum MinecraftAreaAttackCause { Anvil, Attack, BlockExplosion, Contact, Drowning, EntityExplosion, Fall, FallingBlock, Fatal, Fire, FireTick, FlyIntoWall, Lava, Magic, None, Override, Piston, Projectile, Starve, Suffocation, Suicide, Thorns, Void, Wither };

    /// <summary>
    /// The entity to target
    ///
    /// The subject of this filter test.
    ///
    /// TODO description: target
    ///
    /// UNDOCUMENTATED
    ///
    /// TODO description: properties
    ///
    /// Items names to be used.
    ///
    /// The entity type that this entity is allowed to mingle with
    ///
    /// TODO description
    ///
    /// An item that can be used to control this entity
    ///
    /// Family name
    ///
    /// The name of the animation controller / animation
    ///
    /// The name of an animation controller referenced in animations
    ///
    /// TODO description: component groups
    ///
    /// A block type required nearby for the entity to breed.
    /// </summary>
    public enum Subject1160 { Block, Damager, Other, Parent, Player, Self, Target };

    /// <summary>
    /// TODO description: control flags
    /// </summary>
    public enum ControlFlags { Look, Move };

    /// <summary>
    /// TODO description
    /// </summary>
    public enum EntityDamageName { All, Anvil, BlockExplosion, Charging, Contact, Drowning, EntityAttack, EntityExplosion, Fall, FallingBlock, Fire, FireTick, Fireworks, FlyIntoWall, Lava, Lightning, Magic, Magma, None, Override, Piston, Projectile, Starve, Suffocation, Suicide, Temperature, Thorns, Void, Wither };

    /// <summary>
    /// Type of damage that triggers the events.
    /// </summary>
    public enum DamageTriggerCause { All, Anvil, Attack, BlockExplosion, Contact, Drowning, EntityAttack, EntityExplosion, Fall, FallingBlock, Fata, Fire, FireTick, FlyIntoWall, Lava, Lightning, Magic, None, Override, Piston, Projectile, Starve, Suffocation, Suicide, Thorns, Void, Wither };

    /// <summary>
    /// Damage cause
    /// </summary>
    public enum DamageConditionCause { Anvil, Attack, BlockExplosion, Contact, Drowning, EntityExplosion, Fall, FallingBlock, Fatal, Fire, FireTick, FlyIntoWall, Lava, Magic, None, Override, Piston, Projectile, Starve, Suffocation, Suicide, Temperature, Thorns, Void, Wither };

    /// <summary>
    /// Type of container this entity has. Can be horse, minecart_chest, minecart_hopper,
    /// inventory, container or hopper
    /// </summary>
    public enum ContainerType { Container, Hopper, Horse, Inventory, MinecartChest, MinecartHopper };

    /// <summary>
    /// List of items that the entity drops when it grows up.
    ///
    /// The list of items that can be used to get the entity into the 'love' state
    ///
    /// The list of items that can be used to tame this entity
    /// </summary>
    public partial struct Items
    {
        public string String;
        public List<string> StringArray;

        public static implicit operator Items(string String) => new Items { String = String };
        public static implicit operator Items(List<string> StringArray) => new Items { StringArray = StringArray };
    }

    public partial struct FeedableItemElement
    {
        public FeedableItemClass FeedableItemClass;
        public string String;

        public static implicit operator FeedableItemElement(FeedableItemClass FeedableItemClass) => new FeedableItemElement { FeedableItemClass = FeedableItemClass };
        public static implicit operator FeedableItemElement(string String) => new FeedableItemElement { String = String };
    }

    /// <summary>
    /// List of items that can be fed to the entity. Includes 'item' for the item name and
    /// 'growth' to define how much time it grows up by
    /// </summary>
    public partial struct FeedableItems
    {
        public List<FeedableItemElement> AnythingArray;
        public string String;

        public static implicit operator FeedableItems(List<FeedableItemElement> AnythingArray) => new FeedableItems { AnythingArray = AnythingArray };
        public static implicit operator FeedableItems(string String) => new FeedableItems { String = String };
    }

    /// <summary>
    /// Event to run when this entity grows up.
    ///
    /// Minecraft behaviour event 1.16.100
    ///
    /// Event to run after the number of seconds specified in duration expires (when the entity
    /// stops being 'angry')
    ///
    /// UNDOCUMENTATED
    ///
    /// Event to run when this mob attempts to drop an item.
    ///
    /// Event to run when target is within the radius. This event is broadcasted if broadcast is
    /// true.
    ///
    /// Event to run when this mob lays the egg.
    ///
    /// Event to run when the mob reaches their jobsite and finishes working.
    ///
    /// Event to run when this entity breeds.
    ///
    /// Event to trigger when this entity is equipped with this item
    ///
    /// Event to trigger when this item is removed from this entity
    ///
    /// Event to run when this mob is created and matches the above allele conditions.
    ///
    /// Event to fire when the correct item is given.
    ///
    /// Event to call when this entity is leashed.
    ///
    /// Event to call when this entity is unleashed.
    ///
    /// Event to be called when this entity acquires the name specified in 'name_filter'
    ///
    /// Event to call when the entity is done peeking
    ///
    /// Event to call when the entity starts peeking
    ///
    /// Event to call when the entity's target entity starts peeking
    ///
    /// Event to run we attempt to trigger a raid on the village.
    ///
    /// Event to call when the rail is activated
    ///
    /// Event to call when the rail is deactivated
    ///
    /// Event to run when the entity enters the 'sit' state
    ///
    /// Event to run when the entity exits the 'sit' state
    ///
    /// Event to run when this entity becomes tamed
    ///
    /// Event that triggers when the entity becomes tamed
    ///
    /// Event to call when an entity gets in the inside range. Can specify 'event' for the name
    /// of the event and 'target' for the target of the event
    ///
    /// Event to call when an entity gets in the outside range. Can specify 'event' for the name
    /// of the event and 'target' for the target of the event
    ///
    /// Event to call when an entity exits visual range. Can specify 'event' for the name of the
    /// event and 'target' for the target of the event
    ///
    /// Event to fire when the time on the timer runs out
    ///
    /// Event to run when this entity becomes trusting
    /// </summary>
    public partial struct Event
    {
        public BuiltInEvent BuiltInEvent;
        public string String;

        public static implicit operator Event(BuiltInEvent BuiltInEvent) => new Event { BuiltInEvent = BuiltInEvent };
        public static implicit operator Event(string String) => new Event { String = String };
    }

    /// <summary>
    /// The range of time in seconds to randomly wait before playing the sound again
    /// </summary>
    public partial struct SoundInterval
    {
        public List<long> IntegerArray;
        public Range Range;

        public static implicit operator SoundInterval(List<long> IntegerArray) => new SoundInterval { IntegerArray = IntegerArray };
        public static implicit operator SoundInterval(Range Range) => new SoundInterval { Range = Range };
    }

    /// <summary>
    /// Amount of time in seconds for the cooldown. Can be specified as a number or a pair of
    /// numbers (min and max).
    ///
    /// The range for the random amount of time the fuse will be lit before exploding, a negative
    /// value means the explosion will be immediate.
    ///
    /// Amount of time in seconds for the timer. Can be specified as a number or a pair of
    /// numbers (min and max). Incompatible with random_time_choices.
    /// </summary>
    public partial struct AttackCooldownTime
    {
        public double? Double;
        public List<double> DoubleArray;

        public static implicit operator AttackCooldownTime(double Double) => new AttackCooldownTime { Double = Double };
        public static implicit operator AttackCooldownTime(List<double> DoubleArray) => new AttackCooldownTime { DoubleArray = DoubleArray };
    }

    /// <summary>
    /// The range of time in seconds to randomly wait before playing the sound again.
    ///
    /// UNDOCUMENTATED
    ///
    /// The range of time in seconds to randomly wait before jumping again.
    ///
    /// The range of time in seconds to randomly wait before playing the sound again
    /// </summary>
    public partial struct SoundIntervalUnion
    {
        public double? Double;
        public List<double> DoubleArray;
        public Range Range;

        public static implicit operator SoundIntervalUnion(double Double) => new SoundIntervalUnion { Double = Double };
        public static implicit operator SoundIntervalUnion(List<double> DoubleArray) => new SoundIntervalUnion { DoubleArray = DoubleArray };
        public static implicit operator SoundIntervalUnion(Range Range) => new SoundIntervalUnion { Range = Range };
    }

    /// <summary>
    /// TODO description: entity types
    ///
    /// List of entity types this mob considers a threat to the village
    ///
    /// List of entity types that this mob can follow in a caravan
    ///
    /// List of entity types that this mob can target if they hurt their owner
    ///
    /// List of entity types that this entity can target if the potential target is hurt by this
    /// mob's owner
    ///
    /// List of entities this mob will share items with
    ///
    /// List of entity types this mob will startle (cause to jump) when it sneezes.
    ///
    /// UNDOCUMENTATED
    ///
    /// List of entities this mob can copy the owner from.
    ///
    /// List of entity types the wither takes into account to find who dealt the most damage to it
    /// </summary>
    public partial struct EntityTypes180
    {
        public TheEntityType TheEntityType;
        public List<TheEntityType> TheEntityTypeArray;

        public static implicit operator EntityTypes180(TheEntityType TheEntityType) => new EntityTypes180 { TheEntityType = TheEntityType };
        public static implicit operator EntityTypes180(List<TheEntityType> TheEntityTypeArray) => new EntityTypes180 { TheEntityTypeArray = TheEntityTypeArray };
    }

    /// <summary>
    /// UNDOCUMENTATED
    /// </summary>
    public partial struct SuccesChance
    {
        public double? Double;
        public string String;

        public static implicit operator SuccesChance(double Double) => new SuccesChance { Double = Double };
        public static implicit operator SuccesChance(string String) => new SuccesChance { String = String };
    }

    /// <summary>
    /// Event to run when this mob gets home.
    /// </summary>
    public partial struct OnHome
    {
        public OnHomeClass OnHomeClass;
        public List<OnHomeEvent> OnHomeEventArray;
        public string String;

        public static implicit operator OnHome(OnHomeClass OnHomeClass) => new OnHome { OnHomeClass = OnHomeClass };
        public static implicit operator OnHome(List<OnHomeEvent> OnHomeEventArray) => new OnHome { OnHomeEventArray = OnHomeEventArray };
        public static implicit operator OnHome(string String) => new OnHome { String = String };
    }

    /// <summary>
    /// The entity type that this entity is allowed to mingle with
    ///
    /// List of items that can be used to control this entity
    ///
    /// The block types required nearby for the entity to breed.
    /// </summary>
    public partial struct MinglePartnerType
    {
        public string String;
        public List<string> StringArray;

        public static implicit operator MinglePartnerType(string String) => new MinglePartnerType { String = String };
        public static implicit operator MinglePartnerType(List<string> StringArray) => new MinglePartnerType { StringArray = StringArray };
    }

    /// <summary>
    /// Filters which types of targets are valid for this entity.
    /// </summary>
    public partial struct EntityTypes
    {
        public EntityType EntityType;
        public List<EntityType> EntityTypeArray;

        public static implicit operator EntityTypes(EntityType EntityType) => new EntityTypes { EntityType = EntityType };
        public static implicit operator EntityTypes(List<EntityType> EntityTypeArray) => new EntityTypes { EntityTypeArray = EntityTypeArray };
    }

    /// <summary>
    /// The color of the particles for this spell
    /// </summary>
    public partial struct ParticleColor
    {
        public long? Integer;
        public string String;

        public static implicit operator ParticleColor(long Integer) => new ParticleColor { Integer = Integer };
        public static implicit operator ParticleColor(string String) => new ParticleColor { String = String };
    }

    /// <summary>
    /// The list of entity definitions that this entity can breed with.
    /// </summary>
    public partial struct BreedsWith
    {
        public List<BreedsWithElement> BreedsWithElementArray;
        public PurpleBreedsWithSpec PurpleBreedsWithSpec;

        public static implicit operator BreedsWith(List<BreedsWithElement> BreedsWithElementArray) => new BreedsWith { BreedsWithElementArray = BreedsWithElementArray };
        public static implicit operator BreedsWith(PurpleBreedsWithSpec PurpleBreedsWithSpec) => new BreedsWith { PurpleBreedsWithSpec = PurpleBreedsWithSpec };
    }

    /// <summary>
    /// The list of nearby block requirements to get the entity into the 'love' state.
    /// </summary>
    public partial struct EnvironmentRequirements
    {
        public List<EnvironmentRequirementElement> EnvironmentRequirementElementArray;
        public EnvironmentRequirementsClass EnvironmentRequirementsClass;

        public static implicit operator EnvironmentRequirements(List<EnvironmentRequirementElement> EnvironmentRequirementElementArray) => new EnvironmentRequirements { EnvironmentRequirementElementArray = EnvironmentRequirementElementArray };
        public static implicit operator EnvironmentRequirements(EnvironmentRequirementsClass EnvironmentRequirementsClass) => new EnvironmentRequirements { EnvironmentRequirementsClass = EnvironmentRequirementsClass };
    }

    /// <summary>
    /// Specifies if/how a mob burns in daylight.
    /// </summary>
    public partial struct BurnsInDaylight180
    {
        public bool? Bool;
        public BurnsInDaylight180_Class BurnsInDaylight180Class;

        public static implicit operator BurnsInDaylight180(bool Bool) => new BurnsInDaylight180 { Bool = Bool };
        public static implicit operator BurnsInDaylight180(BurnsInDaylight180_Class BurnsInDaylight180Class) => new BurnsInDaylight180 { BurnsInDaylight180Class = BurnsInDaylight180Class };
    }

    /// <summary>
    /// The list of triggers that fire when the environment conditions match the given filter
    /// criteria.
    /// </summary>
    public partial struct DamageTriggers
    {
        public List<DamageTriggerElement> DamageTriggerElementArray;
        public DamageTriggersClass DamageTriggersClass;

        public static implicit operator DamageTriggers(List<DamageTriggerElement> DamageTriggerElementArray) => new DamageTriggers { DamageTriggerElementArray = DamageTriggerElementArray };
        public static implicit operator DamageTriggers(DamageTriggersClass DamageTriggersClass) => new DamageTriggers { DamageTriggersClass = DamageTriggersClass };
    }

    /// <summary>
    /// The list of triggers that fire when the environment conditions match the given filter
    /// criteria.
    /// </summary>
    public partial struct Triggers
    {
        public List<Trigger> TriggerArray;
        public TriggersClass TriggersClass;

        public static implicit operator Triggers(List<Trigger> TriggerArray) => new Triggers { TriggerArray = TriggerArray };
        public static implicit operator Triggers(TriggersClass TriggersClass) => new Triggers { TriggersClass = TriggersClass };
    }

    public partial struct Allele
    {
        public long? Integer;
        public Range Range;

        public static implicit operator Allele(long Integer) => new Allele { Integer = Integer };
        public static implicit operator Allele(Range Range) => new Allele { Range = Range };
    }

    /// <summary>
    /// UNDOCUMENTATED
    /// </summary>
    public partial struct Value
    {
        public double? Double;
        public Range Range;

        public static implicit operator Value(double Double) => new Value { Double = Double };
        public static implicit operator Value(Range Range) => new Value { Range = Range };
    }

    /// <summary>
    /// A single state of a block
    /// </summary>
    public partial struct State
    {
        public bool? Bool;
        public double? Double;
        public string String;

        public static implicit operator State(bool Bool) => new State { Bool = Bool };
        public static implicit operator State(double Double) => new State { Double = Double };
        public static implicit operator State(string String) => new State { String = String };
    }

    /// <summary>
    /// TODO description
    /// </summary>
    public partial struct Interactions
    {
        public List<InteractionElement> InteractionElementArray;
        public InteractionsClass InteractionsClass;

        public static implicit operator Interactions(List<InteractionElement> InteractionElementArray) => new Interactions { InteractionElementArray = InteractionElementArray };
        public static implicit operator Interactions(InteractionsClass InteractionsClass) => new Interactions { InteractionsClass = InteractionsClass };
    }

    /// <summary>
    /// TODO description
    /// </summary>
    public partial struct NameActions
    {
        public List<NameActionElement> NameActionElementArray;
        public NameActionsClass NameActionsClass;

        public static implicit operator NameActions(List<NameActionElement> NameActionElementArray) => new NameActions { NameActionElementArray = NameActionElementArray };
        public static implicit operator NameActions(NameActionsClass NameActionsClass) => new NameActions { NameActionsClass = NameActionsClass };
    }

    /// <summary>
    /// Offset to rotate riders by
    ///
    /// The minecraft molang definition that results in a float
    /// </summary>
    public partial struct MolangNumber
    {
        public double? Double;
        public string String;

        public static implicit operator MolangNumber(double Double) => new MolangNumber { Double = Double };
        public static implicit operator MolangNumber(string String) => new MolangNumber { String = String };
    }

    /// <summary>
    /// The list of positions and number of riders for each position for entities riding this
    /// entity
    /// </summary>
    public partial struct Seats
    {
        public List<SeatElement> SeatElementArray;
        public SeatsClass SeatsClass;

        public static implicit operator Seats(List<SeatElement> SeatElementArray) => new Seats { SeatElementArray = SeatElementArray };
        public static implicit operator Seats(SeatsClass SeatsClass) => new Seats { SeatsClass = SeatsClass };
    }

    /// <summary>
    /// UNDOCUMENTATED
    /// </summary>
    public partial struct Entities
    {
        public Entit Entit;
        public List<EntitySpawn> EntitySpawnArray;

        public static implicit operator Entities(Entit Entit) => new Entities { Entit = Entit };
        public static implicit operator Entities(List<EntitySpawn> EntitySpawnArray) => new Entities { EntitySpawnArray = EntitySpawnArray };
    }

    public partial struct AddEffectElement
    {
        public AddEffectClass AddEffectClass;
        public string String;

        public static implicit operator AddEffectElement(AddEffectClass AddEffectClass) => new AddEffectElement { AddEffectClass = AddEffectClass };
        public static implicit operator AddEffectElement(string String) => new AddEffectElement { String = String };
    }

    /// <summary>
    /// The list of items that, if carried while interacting with the entity, will anger it.
    /// </summary>
    public partial struct AutoRejectItemsUnion
    {
        public List<AutoRejectItemElement> AutoRejectItemElementArray;
        public AutoRejectItemsClass AutoRejectItemsClass;

        public static implicit operator AutoRejectItemsUnion(List<AutoRejectItemElement> AutoRejectItemElementArray) => new AutoRejectItemsUnion { AutoRejectItemElementArray = AutoRejectItemElementArray };
        public static implicit operator AutoRejectItemsUnion(AutoRejectItemsClass AutoRejectItemsClass) => new AutoRejectItemsUnion { AutoRejectItemsClass = AutoRejectItemsClass };
    }

    /// <summary>
    /// The list of items that can be used to increase the entity's temper and speed up the
    /// taming process
    /// </summary>
    public partial struct FeedItems
    {
        public List<FeedItemElement> FeedItemElementArray;
        public FeedItemsClass FeedItemsClass;

        public static implicit operator FeedItems(List<FeedItemElement> FeedItemElementArray) => new FeedItems { FeedItemElementArray = FeedItemElementArray };
        public static implicit operator FeedItems(FeedItemsClass FeedItemsClass) => new FeedItems { FeedItemsClass = FeedItemsClass };
    }

    /// <summary>
    /// Defines the properties of the delay for the transformation
    /// </summary>
    public partial struct DelayUnion
    {
        public DelayClass DelayClass;
        public double? Double;

        public static implicit operator DelayUnion(DelayClass DelayClass) => new DelayUnion { DelayClass = DelayClass };
        public static implicit operator DelayUnion(double Double) => new DelayUnion { Double = Double };
    }

    public partial struct AnimationScript
    {
        public string String;
        public Dictionary<string, string> StringMap;

        public static implicit operator AnimationScript(string String) => new AnimationScript { String = String };
        public static implicit operator AnimationScript(Dictionary<string, string> StringMap) => new AnimationScript { StringMap = StringMap };
    }

    public partial class EntityFile
    {
        public static EntityFile FromJson(string json) => JsonConvert.DeserializeObject<EntityFile>(json, CowLibCore.Schemas.Entity.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this EntityFile self) => JsonConvert.SerializeObject(self, CowLibCore.Schemas.Entity.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                ItemsConverter.Singleton,
                FeedableItemsConverter.Singleton,
                FeedableItemElementConverter.Singleton,
                EventConverter.Singleton,
                TargetConverter.Singleton,
                SoundIntervalConverter.Singleton,
                MinecraftAreaAttackCauseConverter.Singleton,
                Subject1160Converter.Singleton,
                AttackCooldownTimeConverter.Singleton,
                SoundIntervalUnionConverter.Singleton,
                EntityTypes180Converter.Singleton,
                SuccesChanceConverter.Singleton,
                OnHomeConverter.Singleton,
                MinglePartnerTypeConverter.Singleton,
                ControlFlagsConverter.Singleton,
                EntityTypesConverter.Singleton,
                EntityDamageNameConverter.Singleton,
                ParticleColorConverter.Singleton,
                BreedsWithConverter.Singleton,
                EnvironmentRequirementsConverter.Singleton,
                BurnsInDaylight180Converter.Singleton,
                DamageTriggersConverter.Singleton,
                DamageTriggerCauseConverter.Singleton,
                TriggersConverter.Singleton,
                AlleleConverter.Singleton,
                ValueConverter.Singleton,
                DamageConditionCauseConverter.Singleton,
                StateConverter.Singleton,
                InteractionsConverter.Singleton,
                ContainerTypeConverter.Singleton,
                NameActionsConverter.Singleton,
                SeatsConverter.Singleton,
                MolangNumberConverter.Singleton,
                EntitiesConverter.Singleton,
                AddEffectElementConverter.Singleton,
                AutoRejectItemsUnionConverter.Singleton,
                FeedItemsConverter.Singleton,
                DelayUnionConverter.Singleton,
                AnimationScriptConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class ItemsConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Items) || t == typeof(Items?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new Items { String = stringValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<List<string>>(reader);
                    return new Items { StringArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type Items");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Items)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.StringArray != null)
            {
                serializer.Serialize(writer, value.StringArray);
                return;
            }
            throw new Exception("Cannot marshal type Items");
        }

        public static readonly ItemsConverter Singleton = new ItemsConverter();
    }

    internal class FeedableItemsConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FeedableItems) || t == typeof(FeedableItems?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new FeedableItems { String = stringValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<List<FeedableItemElement>>(reader);
                    return new FeedableItems { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type FeedableItems");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (FeedableItems)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            throw new Exception("Cannot marshal type FeedableItems");
        }

        public static readonly FeedableItemsConverter Singleton = new FeedableItemsConverter();
    }

    internal class FeedableItemElementConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FeedableItemElement) || t == typeof(FeedableItemElement?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new FeedableItemElement { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FeedableItemClass>(reader);
                    return new FeedableItemElement { FeedableItemClass = objectValue };
            }
            throw new Exception("Cannot unmarshal type FeedableItemElement");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (FeedableItemElement)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.FeedableItemClass != null)
            {
                serializer.Serialize(writer, value.FeedableItemClass);
                return;
            }
            throw new Exception("Cannot marshal type FeedableItemElement");
        }

        public static readonly FeedableItemElementConverter Singleton = new FeedableItemElementConverter();
    }

    internal class EventConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Event) || t == typeof(Event?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new Event { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<BuiltInEvent>(reader);
                    return new Event { BuiltInEvent = objectValue };
            }
            throw new Exception("Cannot unmarshal type Event");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Event)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.BuiltInEvent != null)
            {
                serializer.Serialize(writer, value.BuiltInEvent);
                return;
            }
            throw new Exception("Cannot marshal type Event");
        }

        public static readonly EventConverter Singleton = new EventConverter();
    }

    internal class TargetConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Target) || t == typeof(Target?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "baby":
                    return Target.Baby;
                case "block":
                    return Target.Block;
                case "damager":
                    return Target.Damager;
                case "other":
                    return Target.Other;
                case "parent":
                    return Target.Parent;
                case "player":
                    return Target.Player;
                case "self":
                    return Target.Self;
                case "target":
                    return Target.Target;
            }
            throw new Exception("Cannot unmarshal type Target");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Target)untypedValue;
            switch (value)
            {
                case Target.Baby:
                    serializer.Serialize(writer, "baby");
                    return;
                case Target.Block:
                    serializer.Serialize(writer, "block");
                    return;
                case Target.Damager:
                    serializer.Serialize(writer, "damager");
                    return;
                case Target.Other:
                    serializer.Serialize(writer, "other");
                    return;
                case Target.Parent:
                    serializer.Serialize(writer, "parent");
                    return;
                case Target.Player:
                    serializer.Serialize(writer, "player");
                    return;
                case Target.Self:
                    serializer.Serialize(writer, "self");
                    return;
                case Target.Target:
                    serializer.Serialize(writer, "target");
                    return;
            }
            throw new Exception("Cannot marshal type Target");
        }

        public static readonly TargetConverter Singleton = new TargetConverter();
    }

    internal class SoundIntervalConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(SoundInterval) || t == typeof(SoundInterval?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<Range>(reader);
                    return new SoundInterval { Range = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<List<long>>(reader);
                    return new SoundInterval { IntegerArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type SoundInterval");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (SoundInterval)untypedValue;
            if (value.IntegerArray != null)
            {
                serializer.Serialize(writer, value.IntegerArray);
                return;
            }
            if (value.Range != null)
            {
                serializer.Serialize(writer, value.Range);
                return;
            }
            throw new Exception("Cannot marshal type SoundInterval");
        }

        public static readonly SoundIntervalConverter Singleton = new SoundIntervalConverter();
    }

    internal class MinecraftAreaAttackCauseConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(MinecraftAreaAttackCause) || t == typeof(MinecraftAreaAttackCause?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "anvil":
                    return MinecraftAreaAttackCause.Anvil;
                case "attack":
                    return MinecraftAreaAttackCause.Attack;
                case "block_explosion":
                    return MinecraftAreaAttackCause.BlockExplosion;
                case "contact":
                    return MinecraftAreaAttackCause.Contact;
                case "drowning":
                    return MinecraftAreaAttackCause.Drowning;
                case "entity_explosion":
                    return MinecraftAreaAttackCause.EntityExplosion;
                case "fall":
                    return MinecraftAreaAttackCause.Fall;
                case "falling_block":
                    return MinecraftAreaAttackCause.FallingBlock;
                case "fatal":
                    return MinecraftAreaAttackCause.Fatal;
                case "fire":
                    return MinecraftAreaAttackCause.Fire;
                case "fire_tick":
                    return MinecraftAreaAttackCause.FireTick;
                case "fly_into_wall":
                    return MinecraftAreaAttackCause.FlyIntoWall;
                case "lava":
                    return MinecraftAreaAttackCause.Lava;
                case "magic":
                    return MinecraftAreaAttackCause.Magic;
                case "none":
                    return MinecraftAreaAttackCause.None;
                case "override":
                    return MinecraftAreaAttackCause.Override;
                case "piston":
                    return MinecraftAreaAttackCause.Piston;
                case "projectile":
                    return MinecraftAreaAttackCause.Projectile;
                case "starve":
                    return MinecraftAreaAttackCause.Starve;
                case "suffocation":
                    return MinecraftAreaAttackCause.Suffocation;
                case "suicide":
                    return MinecraftAreaAttackCause.Suicide;
                case "thorns":
                    return MinecraftAreaAttackCause.Thorns;
                case "void":
                    return MinecraftAreaAttackCause.Void;
                case "wither":
                    return MinecraftAreaAttackCause.Wither;
            }
            throw new Exception("Cannot unmarshal type MinecraftAreaAttackCause");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (MinecraftAreaAttackCause)untypedValue;
            switch (value)
            {
                case MinecraftAreaAttackCause.Anvil:
                    serializer.Serialize(writer, "anvil");
                    return;
                case MinecraftAreaAttackCause.Attack:
                    serializer.Serialize(writer, "attack");
                    return;
                case MinecraftAreaAttackCause.BlockExplosion:
                    serializer.Serialize(writer, "block_explosion");
                    return;
                case MinecraftAreaAttackCause.Contact:
                    serializer.Serialize(writer, "contact");
                    return;
                case MinecraftAreaAttackCause.Drowning:
                    serializer.Serialize(writer, "drowning");
                    return;
                case MinecraftAreaAttackCause.EntityExplosion:
                    serializer.Serialize(writer, "entity_explosion");
                    return;
                case MinecraftAreaAttackCause.Fall:
                    serializer.Serialize(writer, "fall");
                    return;
                case MinecraftAreaAttackCause.FallingBlock:
                    serializer.Serialize(writer, "falling_block");
                    return;
                case MinecraftAreaAttackCause.Fatal:
                    serializer.Serialize(writer, "fatal");
                    return;
                case MinecraftAreaAttackCause.Fire:
                    serializer.Serialize(writer, "fire");
                    return;
                case MinecraftAreaAttackCause.FireTick:
                    serializer.Serialize(writer, "fire_tick");
                    return;
                case MinecraftAreaAttackCause.FlyIntoWall:
                    serializer.Serialize(writer, "fly_into_wall");
                    return;
                case MinecraftAreaAttackCause.Lava:
                    serializer.Serialize(writer, "lava");
                    return;
                case MinecraftAreaAttackCause.Magic:
                    serializer.Serialize(writer, "magic");
                    return;
                case MinecraftAreaAttackCause.None:
                    serializer.Serialize(writer, "none");
                    return;
                case MinecraftAreaAttackCause.Override:
                    serializer.Serialize(writer, "override");
                    return;
                case MinecraftAreaAttackCause.Piston:
                    serializer.Serialize(writer, "piston");
                    return;
                case MinecraftAreaAttackCause.Projectile:
                    serializer.Serialize(writer, "projectile");
                    return;
                case MinecraftAreaAttackCause.Starve:
                    serializer.Serialize(writer, "starve");
                    return;
                case MinecraftAreaAttackCause.Suffocation:
                    serializer.Serialize(writer, "suffocation");
                    return;
                case MinecraftAreaAttackCause.Suicide:
                    serializer.Serialize(writer, "suicide");
                    return;
                case MinecraftAreaAttackCause.Thorns:
                    serializer.Serialize(writer, "thorns");
                    return;
                case MinecraftAreaAttackCause.Void:
                    serializer.Serialize(writer, "void");
                    return;
                case MinecraftAreaAttackCause.Wither:
                    serializer.Serialize(writer, "wither");
                    return;
            }
            throw new Exception("Cannot marshal type MinecraftAreaAttackCause");
        }

        public static readonly MinecraftAreaAttackCauseConverter Singleton = new MinecraftAreaAttackCauseConverter();
    }

    internal class Subject1160Converter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Subject1160) || t == typeof(Subject1160?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "block":
                    return Subject1160.Block;
                case "damager":
                    return Subject1160.Damager;
                case "other":
                    return Subject1160.Other;
                case "parent":
                    return Subject1160.Parent;
                case "player":
                    return Subject1160.Player;
                case "self":
                    return Subject1160.Self;
                case "target":
                    return Subject1160.Target;
            }
            throw new Exception("Cannot unmarshal type Subject1160");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Subject1160)untypedValue;
            switch (value)
            {
                case Subject1160.Block:
                    serializer.Serialize(writer, "block");
                    return;
                case Subject1160.Damager:
                    serializer.Serialize(writer, "damager");
                    return;
                case Subject1160.Other:
                    serializer.Serialize(writer, "other");
                    return;
                case Subject1160.Parent:
                    serializer.Serialize(writer, "parent");
                    return;
                case Subject1160.Player:
                    serializer.Serialize(writer, "player");
                    return;
                case Subject1160.Self:
                    serializer.Serialize(writer, "self");
                    return;
                case Subject1160.Target:
                    serializer.Serialize(writer, "target");
                    return;
            }
            throw new Exception("Cannot marshal type Subject1160");
        }

        public static readonly Subject1160Converter Singleton = new Subject1160Converter();
    }

    internal class AttackCooldownTimeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AttackCooldownTime) || t == typeof(AttackCooldownTime?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new AttackCooldownTime { Double = doubleValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<List<double>>(reader);
                    return new AttackCooldownTime { DoubleArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type AttackCooldownTime");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (AttackCooldownTime)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.DoubleArray != null)
            {
                serializer.Serialize(writer, value.DoubleArray);
                return;
            }
            throw new Exception("Cannot marshal type AttackCooldownTime");
        }

        public static readonly AttackCooldownTimeConverter Singleton = new AttackCooldownTimeConverter();
    }

    internal class SoundIntervalUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(SoundIntervalUnion) || t == typeof(SoundIntervalUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new SoundIntervalUnion { Double = doubleValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<Range>(reader);
                    return new SoundIntervalUnion { Range = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<List<double>>(reader);
                    return new SoundIntervalUnion { DoubleArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type SoundIntervalUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (SoundIntervalUnion)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.DoubleArray != null)
            {
                serializer.Serialize(writer, value.DoubleArray);
                return;
            }
            if (value.Range != null)
            {
                serializer.Serialize(writer, value.Range);
                return;
            }
            throw new Exception("Cannot marshal type SoundIntervalUnion");
        }

        public static readonly SoundIntervalUnionConverter Singleton = new SoundIntervalUnionConverter();
    }

    internal class EntityTypes180Converter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(EntityTypes180) || t == typeof(EntityTypes180?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<TheEntityType>(reader);
                    return new EntityTypes180 { TheEntityType = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<List<TheEntityType>>(reader);
                    return new EntityTypes180 { TheEntityTypeArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type EntityTypes180");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (EntityTypes180)untypedValue;
            if (value.TheEntityTypeArray != null)
            {
                serializer.Serialize(writer, value.TheEntityTypeArray);
                return;
            }
            if (value.TheEntityType != null)
            {
                serializer.Serialize(writer, value.TheEntityType);
                return;
            }
            throw new Exception("Cannot marshal type EntityTypes180");
        }

        public static readonly EntityTypes180Converter Singleton = new EntityTypes180Converter();
    }

    internal class PurpleMinMaxValueCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(double) || t == typeof(double?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<double>(reader);
            if (value >= 0 && value <= 1)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type double");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (double)untypedValue;
            if (value >= 0 && value <= 1)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type double");
        }

        public static readonly PurpleMinMaxValueCheckConverter Singleton = new PurpleMinMaxValueCheckConverter();
    }

    internal class DecodeArrayConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(List<double>);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            reader.Read();
            var value = new List<double>();
            while (reader.TokenType != JsonToken.EndArray)
            {
                var converter = PurpleMinMaxValueCheckConverter.Singleton;
                var arrayItem = (double)converter.ReadJson(reader, typeof(double), null, serializer);
                value.Add(arrayItem);
                reader.Read();
            }
            return value;
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (List<double>)untypedValue;
            writer.WriteStartArray();
            foreach (var arrayItem in value)
            {
                var converter = PurpleMinMaxValueCheckConverter.Singleton;
                converter.WriteJson(writer, arrayItem, serializer);
            }
            writer.WriteEndArray();
            return;
        }

        public static readonly DecodeArrayConverter Singleton = new DecodeArrayConverter();
    }

    internal class SuccesChanceConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(SuccesChance) || t == typeof(SuccesChance?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new SuccesChance { Double = doubleValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new SuccesChance { String = stringValue };
            }
            throw new Exception("Cannot unmarshal type SuccesChance");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (SuccesChance)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            throw new Exception("Cannot marshal type SuccesChance");
        }

        public static readonly SuccesChanceConverter Singleton = new SuccesChanceConverter();
    }

    internal class OnHomeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(OnHome) || t == typeof(OnHome?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new OnHome { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<OnHomeClass>(reader);
                    return new OnHome { OnHomeClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<List<OnHomeEvent>>(reader);
                    return new OnHome { OnHomeEventArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type OnHome");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (OnHome)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.OnHomeEventArray != null)
            {
                serializer.Serialize(writer, value.OnHomeEventArray);
                return;
            }
            if (value.OnHomeClass != null)
            {
                serializer.Serialize(writer, value.OnHomeClass);
                return;
            }
            throw new Exception("Cannot marshal type OnHome");
        }

        public static readonly OnHomeConverter Singleton = new OnHomeConverter();
    }

    internal class FluffyMinMaxValueCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(double) || t == typeof(double?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<double>(reader);
            if (value >= 0)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type double");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (double)untypedValue;
            if (value >= 0)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type double");
        }

        public static readonly FluffyMinMaxValueCheckConverter Singleton = new FluffyMinMaxValueCheckConverter();
    }

    internal class MinglePartnerTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(MinglePartnerType) || t == typeof(MinglePartnerType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new MinglePartnerType { String = stringValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<List<string>>(reader);
                    return new MinglePartnerType { StringArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type MinglePartnerType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (MinglePartnerType)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.StringArray != null)
            {
                serializer.Serialize(writer, value.StringArray);
                return;
            }
            throw new Exception("Cannot marshal type MinglePartnerType");
        }

        public static readonly MinglePartnerTypeConverter Singleton = new MinglePartnerTypeConverter();
    }

    internal class ControlFlagsConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ControlFlags) || t == typeof(ControlFlags?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "look":
                    return ControlFlags.Look;
                case "move":
                    return ControlFlags.Move;
            }
            throw new Exception("Cannot unmarshal type ControlFlags");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ControlFlags)untypedValue;
            switch (value)
            {
                case ControlFlags.Look:
                    serializer.Serialize(writer, "look");
                    return;
                case ControlFlags.Move:
                    serializer.Serialize(writer, "move");
                    return;
            }
            throw new Exception("Cannot marshal type ControlFlags");
        }

        public static readonly ControlFlagsConverter Singleton = new ControlFlagsConverter();
    }

    internal class EntityTypesConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(EntityTypes) || t == typeof(EntityTypes?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<EntityType>(reader);
                    return new EntityTypes { EntityType = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<List<EntityType>>(reader);
                    return new EntityTypes { EntityTypeArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type EntityTypes");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (EntityTypes)untypedValue;
            if (value.EntityTypeArray != null)
            {
                serializer.Serialize(writer, value.EntityTypeArray);
                return;
            }
            if (value.EntityType != null)
            {
                serializer.Serialize(writer, value.EntityType);
                return;
            }
            throw new Exception("Cannot marshal type EntityTypes");
        }

        public static readonly EntityTypesConverter Singleton = new EntityTypesConverter();
    }

    internal class EntityDamageNameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(EntityDamageName) || t == typeof(EntityDamageName?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "all":
                    return EntityDamageName.All;
                case "anvil":
                    return EntityDamageName.Anvil;
                case "block_explosion":
                    return EntityDamageName.BlockExplosion;
                case "charging":
                    return EntityDamageName.Charging;
                case "contact":
                    return EntityDamageName.Contact;
                case "drowning":
                    return EntityDamageName.Drowning;
                case "entity_attack":
                    return EntityDamageName.EntityAttack;
                case "entity_explosion":
                    return EntityDamageName.EntityExplosion;
                case "fall":
                    return EntityDamageName.Fall;
                case "falling_block":
                    return EntityDamageName.FallingBlock;
                case "fire":
                    return EntityDamageName.Fire;
                case "fire_tick":
                    return EntityDamageName.FireTick;
                case "fireworks":
                    return EntityDamageName.Fireworks;
                case "fly_into_wall":
                    return EntityDamageName.FlyIntoWall;
                case "lava":
                    return EntityDamageName.Lava;
                case "lightning":
                    return EntityDamageName.Lightning;
                case "magic":
                    return EntityDamageName.Magic;
                case "magma":
                    return EntityDamageName.Magma;
                case "none":
                    return EntityDamageName.None;
                case "override":
                    return EntityDamageName.Override;
                case "piston":
                    return EntityDamageName.Piston;
                case "projectile":
                    return EntityDamageName.Projectile;
                case "starve":
                    return EntityDamageName.Starve;
                case "suffocation":
                    return EntityDamageName.Suffocation;
                case "suicide":
                    return EntityDamageName.Suicide;
                case "temperature":
                    return EntityDamageName.Temperature;
                case "thorns":
                    return EntityDamageName.Thorns;
                case "void":
                    return EntityDamageName.Void;
                case "wither":
                    return EntityDamageName.Wither;
            }
            throw new Exception("Cannot unmarshal type EntityDamageName");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (EntityDamageName)untypedValue;
            switch (value)
            {
                case EntityDamageName.All:
                    serializer.Serialize(writer, "all");
                    return;
                case EntityDamageName.Anvil:
                    serializer.Serialize(writer, "anvil");
                    return;
                case EntityDamageName.BlockExplosion:
                    serializer.Serialize(writer, "block_explosion");
                    return;
                case EntityDamageName.Charging:
                    serializer.Serialize(writer, "charging");
                    return;
                case EntityDamageName.Contact:
                    serializer.Serialize(writer, "contact");
                    return;
                case EntityDamageName.Drowning:
                    serializer.Serialize(writer, "drowning");
                    return;
                case EntityDamageName.EntityAttack:
                    serializer.Serialize(writer, "entity_attack");
                    return;
                case EntityDamageName.EntityExplosion:
                    serializer.Serialize(writer, "entity_explosion");
                    return;
                case EntityDamageName.Fall:
                    serializer.Serialize(writer, "fall");
                    return;
                case EntityDamageName.FallingBlock:
                    serializer.Serialize(writer, "falling_block");
                    return;
                case EntityDamageName.Fire:
                    serializer.Serialize(writer, "fire");
                    return;
                case EntityDamageName.FireTick:
                    serializer.Serialize(writer, "fire_tick");
                    return;
                case EntityDamageName.Fireworks:
                    serializer.Serialize(writer, "fireworks");
                    return;
                case EntityDamageName.FlyIntoWall:
                    serializer.Serialize(writer, "fly_into_wall");
                    return;
                case EntityDamageName.Lava:
                    serializer.Serialize(writer, "lava");
                    return;
                case EntityDamageName.Lightning:
                    serializer.Serialize(writer, "lightning");
                    return;
                case EntityDamageName.Magic:
                    serializer.Serialize(writer, "magic");
                    return;
                case EntityDamageName.Magma:
                    serializer.Serialize(writer, "magma");
                    return;
                case EntityDamageName.None:
                    serializer.Serialize(writer, "none");
                    return;
                case EntityDamageName.Override:
                    serializer.Serialize(writer, "override");
                    return;
                case EntityDamageName.Piston:
                    serializer.Serialize(writer, "piston");
                    return;
                case EntityDamageName.Projectile:
                    serializer.Serialize(writer, "projectile");
                    return;
                case EntityDamageName.Starve:
                    serializer.Serialize(writer, "starve");
                    return;
                case EntityDamageName.Suffocation:
                    serializer.Serialize(writer, "suffocation");
                    return;
                case EntityDamageName.Suicide:
                    serializer.Serialize(writer, "suicide");
                    return;
                case EntityDamageName.Temperature:
                    serializer.Serialize(writer, "temperature");
                    return;
                case EntityDamageName.Thorns:
                    serializer.Serialize(writer, "thorns");
                    return;
                case EntityDamageName.Void:
                    serializer.Serialize(writer, "void");
                    return;
                case EntityDamageName.Wither:
                    serializer.Serialize(writer, "wither");
                    return;
            }
            throw new Exception("Cannot marshal type EntityDamageName");
        }

        public static readonly EntityDamageNameConverter Singleton = new EntityDamageNameConverter();
    }

    internal class ParticleColorConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ParticleColor) || t == typeof(ParticleColor?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                    var integerValue = serializer.Deserialize<long>(reader);
                    return new ParticleColor { Integer = integerValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new ParticleColor { String = stringValue };
            }
            throw new Exception("Cannot unmarshal type ParticleColor");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (ParticleColor)untypedValue;
            if (value.Integer != null)
            {
                serializer.Serialize(writer, value.Integer.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            throw new Exception("Cannot marshal type ParticleColor");
        }

        public static readonly ParticleColorConverter Singleton = new ParticleColorConverter();
    }

    internal class BreedsWithConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(BreedsWith) || t == typeof(BreedsWith?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<PurpleBreedsWithSpec>(reader);
                    return new BreedsWith { PurpleBreedsWithSpec = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<List<BreedsWithElement>>(reader);
                    return new BreedsWith { BreedsWithElementArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type BreedsWith");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (BreedsWith)untypedValue;
            if (value.BreedsWithElementArray != null)
            {
                serializer.Serialize(writer, value.BreedsWithElementArray);
                return;
            }
            if (value.PurpleBreedsWithSpec != null)
            {
                serializer.Serialize(writer, value.PurpleBreedsWithSpec);
                return;
            }
            throw new Exception("Cannot marshal type BreedsWith");
        }

        public static readonly BreedsWithConverter Singleton = new BreedsWithConverter();
    }

    internal class EnvironmentRequirementsConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(EnvironmentRequirements) || t == typeof(EnvironmentRequirements?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<EnvironmentRequirementsClass>(reader);
                    return new EnvironmentRequirements { EnvironmentRequirementsClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<List<EnvironmentRequirementElement>>(reader);
                    return new EnvironmentRequirements { EnvironmentRequirementElementArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type EnvironmentRequirements");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (EnvironmentRequirements)untypedValue;
            if (value.EnvironmentRequirementElementArray != null)
            {
                serializer.Serialize(writer, value.EnvironmentRequirementElementArray);
                return;
            }
            if (value.EnvironmentRequirementsClass != null)
            {
                serializer.Serialize(writer, value.EnvironmentRequirementsClass);
                return;
            }
            throw new Exception("Cannot marshal type EnvironmentRequirements");
        }

        public static readonly EnvironmentRequirementsConverter Singleton = new EnvironmentRequirementsConverter();
    }

    internal class BurnsInDaylight180Converter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(BurnsInDaylight180) || t == typeof(BurnsInDaylight180?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new BurnsInDaylight180 { Bool = boolValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<BurnsInDaylight180_Class>(reader);
                    return new BurnsInDaylight180 { BurnsInDaylight180Class = objectValue };
            }
            throw new Exception("Cannot unmarshal type BurnsInDaylight180");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (BurnsInDaylight180)untypedValue;
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.BurnsInDaylight180Class != null)
            {
                serializer.Serialize(writer, value.BurnsInDaylight180Class);
                return;
            }
            throw new Exception("Cannot marshal type BurnsInDaylight180");
        }

        public static readonly BurnsInDaylight180Converter Singleton = new BurnsInDaylight180Converter();
    }

    internal class DamageTriggersConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DamageTriggers) || t == typeof(DamageTriggers?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<DamageTriggersClass>(reader);
                    return new DamageTriggers { DamageTriggersClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<List<DamageTriggerElement>>(reader);
                    return new DamageTriggers { DamageTriggerElementArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type DamageTriggers");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (DamageTriggers)untypedValue;
            if (value.DamageTriggerElementArray != null)
            {
                serializer.Serialize(writer, value.DamageTriggerElementArray);
                return;
            }
            if (value.DamageTriggersClass != null)
            {
                serializer.Serialize(writer, value.DamageTriggersClass);
                return;
            }
            throw new Exception("Cannot marshal type DamageTriggers");
        }

        public static readonly DamageTriggersConverter Singleton = new DamageTriggersConverter();
    }

    internal class DamageTriggerCauseConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DamageTriggerCause) || t == typeof(DamageTriggerCause?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "all":
                    return DamageTriggerCause.All;
                case "anvil":
                    return DamageTriggerCause.Anvil;
                case "attack":
                    return DamageTriggerCause.Attack;
                case "block_explosion":
                    return DamageTriggerCause.BlockExplosion;
                case "contact":
                    return DamageTriggerCause.Contact;
                case "drowning":
                    return DamageTriggerCause.Drowning;
                case "entity_attack":
                    return DamageTriggerCause.EntityAttack;
                case "entity_explosion":
                    return DamageTriggerCause.EntityExplosion;
                case "fall":
                    return DamageTriggerCause.Fall;
                case "falling_block":
                    return DamageTriggerCause.FallingBlock;
                case "fata":
                    return DamageTriggerCause.Fata;
                case "fire":
                    return DamageTriggerCause.Fire;
                case "fire_tick":
                    return DamageTriggerCause.FireTick;
                case "fly_into_wall":
                    return DamageTriggerCause.FlyIntoWall;
                case "lava":
                    return DamageTriggerCause.Lava;
                case "lightning":
                    return DamageTriggerCause.Lightning;
                case "magic":
                    return DamageTriggerCause.Magic;
                case "none":
                    return DamageTriggerCause.None;
                case "override":
                    return DamageTriggerCause.Override;
                case "piston":
                    return DamageTriggerCause.Piston;
                case "projectile":
                    return DamageTriggerCause.Projectile;
                case "starve":
                    return DamageTriggerCause.Starve;
                case "suffocation":
                    return DamageTriggerCause.Suffocation;
                case "suicide":
                    return DamageTriggerCause.Suicide;
                case "thorns":
                    return DamageTriggerCause.Thorns;
                case "void":
                    return DamageTriggerCause.Void;
                case "wither":
                    return DamageTriggerCause.Wither;
            }
            throw new Exception("Cannot unmarshal type DamageTriggerCause");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DamageTriggerCause)untypedValue;
            switch (value)
            {
                case DamageTriggerCause.All:
                    serializer.Serialize(writer, "all");
                    return;
                case DamageTriggerCause.Anvil:
                    serializer.Serialize(writer, "anvil");
                    return;
                case DamageTriggerCause.Attack:
                    serializer.Serialize(writer, "attack");
                    return;
                case DamageTriggerCause.BlockExplosion:
                    serializer.Serialize(writer, "block_explosion");
                    return;
                case DamageTriggerCause.Contact:
                    serializer.Serialize(writer, "contact");
                    return;
                case DamageTriggerCause.Drowning:
                    serializer.Serialize(writer, "drowning");
                    return;
                case DamageTriggerCause.EntityAttack:
                    serializer.Serialize(writer, "entity_attack");
                    return;
                case DamageTriggerCause.EntityExplosion:
                    serializer.Serialize(writer, "entity_explosion");
                    return;
                case DamageTriggerCause.Fall:
                    serializer.Serialize(writer, "fall");
                    return;
                case DamageTriggerCause.FallingBlock:
                    serializer.Serialize(writer, "falling_block");
                    return;
                case DamageTriggerCause.Fata:
                    serializer.Serialize(writer, "fata");
                    return;
                case DamageTriggerCause.Fire:
                    serializer.Serialize(writer, "fire");
                    return;
                case DamageTriggerCause.FireTick:
                    serializer.Serialize(writer, "fire_tick");
                    return;
                case DamageTriggerCause.FlyIntoWall:
                    serializer.Serialize(writer, "fly_into_wall");
                    return;
                case DamageTriggerCause.Lava:
                    serializer.Serialize(writer, "lava");
                    return;
                case DamageTriggerCause.Lightning:
                    serializer.Serialize(writer, "lightning");
                    return;
                case DamageTriggerCause.Magic:
                    serializer.Serialize(writer, "magic");
                    return;
                case DamageTriggerCause.None:
                    serializer.Serialize(writer, "none");
                    return;
                case DamageTriggerCause.Override:
                    serializer.Serialize(writer, "override");
                    return;
                case DamageTriggerCause.Piston:
                    serializer.Serialize(writer, "piston");
                    return;
                case DamageTriggerCause.Projectile:
                    serializer.Serialize(writer, "projectile");
                    return;
                case DamageTriggerCause.Starve:
                    serializer.Serialize(writer, "starve");
                    return;
                case DamageTriggerCause.Suffocation:
                    serializer.Serialize(writer, "suffocation");
                    return;
                case DamageTriggerCause.Suicide:
                    serializer.Serialize(writer, "suicide");
                    return;
                case DamageTriggerCause.Thorns:
                    serializer.Serialize(writer, "thorns");
                    return;
                case DamageTriggerCause.Void:
                    serializer.Serialize(writer, "void");
                    return;
                case DamageTriggerCause.Wither:
                    serializer.Serialize(writer, "wither");
                    return;
            }
            throw new Exception("Cannot marshal type DamageTriggerCause");
        }

        public static readonly DamageTriggerCauseConverter Singleton = new DamageTriggerCauseConverter();
    }

    internal class TriggersConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Triggers) || t == typeof(Triggers?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<TriggersClass>(reader);
                    return new Triggers { TriggersClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<List<Trigger>>(reader);
                    return new Triggers { TriggerArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type Triggers");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Triggers)untypedValue;
            if (value.TriggerArray != null)
            {
                serializer.Serialize(writer, value.TriggerArray);
                return;
            }
            if (value.TriggersClass != null)
            {
                serializer.Serialize(writer, value.TriggersClass);
                return;
            }
            throw new Exception("Cannot marshal type Triggers");
        }

        public static readonly TriggersConverter Singleton = new TriggersConverter();
    }

    internal class AlleleConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Allele) || t == typeof(Allele?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                    var integerValue = serializer.Deserialize<long>(reader);
                    return new Allele { Integer = integerValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<Range>(reader);
                    return new Allele { Range = objectValue };
            }
            throw new Exception("Cannot unmarshal type Allele");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Allele)untypedValue;
            if (value.Integer != null)
            {
                serializer.Serialize(writer, value.Integer.Value);
                return;
            }
            if (value.Range != null)
            {
                serializer.Serialize(writer, value.Range);
                return;
            }
            throw new Exception("Cannot marshal type Allele");
        }

        public static readonly AlleleConverter Singleton = new AlleleConverter();
    }

    internal class ValueConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Value) || t == typeof(Value?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new Value { Double = doubleValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<Range>(reader);
                    return new Value { Range = objectValue };
            }
            throw new Exception("Cannot unmarshal type Value");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Value)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.Range != null)
            {
                serializer.Serialize(writer, value.Range);
                return;
            }
            throw new Exception("Cannot marshal type Value");
        }

        public static readonly ValueConverter Singleton = new ValueConverter();
    }

    internal class DamageConditionCauseConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DamageConditionCause) || t == typeof(DamageConditionCause?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "anvil":
                    return DamageConditionCause.Anvil;
                case "attack":
                    return DamageConditionCause.Attack;
                case "block_explosion":
                    return DamageConditionCause.BlockExplosion;
                case "contact":
                    return DamageConditionCause.Contact;
                case "drowning":
                    return DamageConditionCause.Drowning;
                case "entity_explosion":
                    return DamageConditionCause.EntityExplosion;
                case "fall":
                    return DamageConditionCause.Fall;
                case "falling_block":
                    return DamageConditionCause.FallingBlock;
                case "fatal":
                    return DamageConditionCause.Fatal;
                case "fire":
                    return DamageConditionCause.Fire;
                case "fire_tick":
                    return DamageConditionCause.FireTick;
                case "fly_into_wall":
                    return DamageConditionCause.FlyIntoWall;
                case "lava":
                    return DamageConditionCause.Lava;
                case "magic":
                    return DamageConditionCause.Magic;
                case "none":
                    return DamageConditionCause.None;
                case "override":
                    return DamageConditionCause.Override;
                case "piston":
                    return DamageConditionCause.Piston;
                case "projectile":
                    return DamageConditionCause.Projectile;
                case "starve":
                    return DamageConditionCause.Starve;
                case "suffocation":
                    return DamageConditionCause.Suffocation;
                case "suicide":
                    return DamageConditionCause.Suicide;
                case "temperature":
                    return DamageConditionCause.Temperature;
                case "thorns":
                    return DamageConditionCause.Thorns;
                case "void":
                    return DamageConditionCause.Void;
                case "wither":
                    return DamageConditionCause.Wither;
            }
            throw new Exception("Cannot unmarshal type DamageConditionCause");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DamageConditionCause)untypedValue;
            switch (value)
            {
                case DamageConditionCause.Anvil:
                    serializer.Serialize(writer, "anvil");
                    return;
                case DamageConditionCause.Attack:
                    serializer.Serialize(writer, "attack");
                    return;
                case DamageConditionCause.BlockExplosion:
                    serializer.Serialize(writer, "block_explosion");
                    return;
                case DamageConditionCause.Contact:
                    serializer.Serialize(writer, "contact");
                    return;
                case DamageConditionCause.Drowning:
                    serializer.Serialize(writer, "drowning");
                    return;
                case DamageConditionCause.EntityExplosion:
                    serializer.Serialize(writer, "entity_explosion");
                    return;
                case DamageConditionCause.Fall:
                    serializer.Serialize(writer, "fall");
                    return;
                case DamageConditionCause.FallingBlock:
                    serializer.Serialize(writer, "falling_block");
                    return;
                case DamageConditionCause.Fatal:
                    serializer.Serialize(writer, "fatal");
                    return;
                case DamageConditionCause.Fire:
                    serializer.Serialize(writer, "fire");
                    return;
                case DamageConditionCause.FireTick:
                    serializer.Serialize(writer, "fire_tick");
                    return;
                case DamageConditionCause.FlyIntoWall:
                    serializer.Serialize(writer, "fly_into_wall");
                    return;
                case DamageConditionCause.Lava:
                    serializer.Serialize(writer, "lava");
                    return;
                case DamageConditionCause.Magic:
                    serializer.Serialize(writer, "magic");
                    return;
                case DamageConditionCause.None:
                    serializer.Serialize(writer, "none");
                    return;
                case DamageConditionCause.Override:
                    serializer.Serialize(writer, "override");
                    return;
                case DamageConditionCause.Piston:
                    serializer.Serialize(writer, "piston");
                    return;
                case DamageConditionCause.Projectile:
                    serializer.Serialize(writer, "projectile");
                    return;
                case DamageConditionCause.Starve:
                    serializer.Serialize(writer, "starve");
                    return;
                case DamageConditionCause.Suffocation:
                    serializer.Serialize(writer, "suffocation");
                    return;
                case DamageConditionCause.Suicide:
                    serializer.Serialize(writer, "suicide");
                    return;
                case DamageConditionCause.Temperature:
                    serializer.Serialize(writer, "temperature");
                    return;
                case DamageConditionCause.Thorns:
                    serializer.Serialize(writer, "thorns");
                    return;
                case DamageConditionCause.Void:
                    serializer.Serialize(writer, "void");
                    return;
                case DamageConditionCause.Wither:
                    serializer.Serialize(writer, "wither");
                    return;
            }
            throw new Exception("Cannot marshal type DamageConditionCause");
        }

        public static readonly DamageConditionCauseConverter Singleton = new DamageConditionCauseConverter();
    }

    internal class StateConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(State) || t == typeof(State?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new State { Double = doubleValue };
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new State { Bool = boolValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new State { String = stringValue };
            }
            throw new Exception("Cannot unmarshal type State");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (State)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            throw new Exception("Cannot marshal type State");
        }

        public static readonly StateConverter Singleton = new StateConverter();
    }

    internal class InteractionsConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Interactions) || t == typeof(Interactions?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<InteractionsClass>(reader);
                    return new Interactions { InteractionsClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<List<InteractionElement>>(reader);
                    return new Interactions { InteractionElementArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type Interactions");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Interactions)untypedValue;
            if (value.InteractionElementArray != null)
            {
                serializer.Serialize(writer, value.InteractionElementArray);
                return;
            }
            if (value.InteractionsClass != null)
            {
                serializer.Serialize(writer, value.InteractionsClass);
                return;
            }
            throw new Exception("Cannot marshal type Interactions");
        }

        public static readonly InteractionsConverter Singleton = new InteractionsConverter();
    }

    internal class ContainerTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ContainerType) || t == typeof(ContainerType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "container":
                    return ContainerType.Container;
                case "hopper":
                    return ContainerType.Hopper;
                case "horse":
                    return ContainerType.Horse;
                case "inventory":
                    return ContainerType.Inventory;
                case "minecart_chest":
                    return ContainerType.MinecartChest;
                case "minecart_hopper":
                    return ContainerType.MinecartHopper;
            }
            throw new Exception("Cannot unmarshal type ContainerType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ContainerType)untypedValue;
            switch (value)
            {
                case ContainerType.Container:
                    serializer.Serialize(writer, "container");
                    return;
                case ContainerType.Hopper:
                    serializer.Serialize(writer, "hopper");
                    return;
                case ContainerType.Horse:
                    serializer.Serialize(writer, "horse");
                    return;
                case ContainerType.Inventory:
                    serializer.Serialize(writer, "inventory");
                    return;
                case ContainerType.MinecartChest:
                    serializer.Serialize(writer, "minecart_chest");
                    return;
                case ContainerType.MinecartHopper:
                    serializer.Serialize(writer, "minecart_hopper");
                    return;
            }
            throw new Exception("Cannot marshal type ContainerType");
        }

        public static readonly ContainerTypeConverter Singleton = new ContainerTypeConverter();
    }

    internal class NameActionsConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(NameActions) || t == typeof(NameActions?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<NameActionsClass>(reader);
                    return new NameActions { NameActionsClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<List<NameActionElement>>(reader);
                    return new NameActions { NameActionElementArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type NameActions");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (NameActions)untypedValue;
            if (value.NameActionElementArray != null)
            {
                serializer.Serialize(writer, value.NameActionElementArray);
                return;
            }
            if (value.NameActionsClass != null)
            {
                serializer.Serialize(writer, value.NameActionsClass);
                return;
            }
            throw new Exception("Cannot marshal type NameActions");
        }

        public static readonly NameActionsConverter Singleton = new NameActionsConverter();
    }

    internal class SeatsConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Seats) || t == typeof(Seats?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<SeatsClass>(reader);
                    return new Seats { SeatsClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<List<SeatElement>>(reader);
                    return new Seats { SeatElementArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type Seats");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Seats)untypedValue;
            if (value.SeatElementArray != null)
            {
                serializer.Serialize(writer, value.SeatElementArray);
                return;
            }
            if (value.SeatsClass != null)
            {
                serializer.Serialize(writer, value.SeatsClass);
                return;
            }
            throw new Exception("Cannot marshal type Seats");
        }

        public static readonly SeatsConverter Singleton = new SeatsConverter();
    }

    internal class MolangNumberConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(MolangNumber) || t == typeof(MolangNumber?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new MolangNumber { Double = doubleValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    if (stringValue.Length >= 0)
                    {
                        return new MolangNumber { String = stringValue };
                    }
                    break;
            }
            throw new Exception("Cannot unmarshal type MolangNumber");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (MolangNumber)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.String != null)
            {
                if (value.String.Length >= 0)
                {
                    serializer.Serialize(writer, value.String);
                    return;
                }
            }
            throw new Exception("Cannot marshal type MolangNumber");
        }

        public static readonly MolangNumberConverter Singleton = new MolangNumberConverter();
    }

    internal class MinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length >= 0)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length >= 0)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly MinMaxLengthCheckConverter Singleton = new MinMaxLengthCheckConverter();
    }

    internal class EntitiesConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Entities) || t == typeof(Entities?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<Entit>(reader);
                    return new Entities { Entit = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<List<EntitySpawn>>(reader);
                    return new Entities { EntitySpawnArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type Entities");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Entities)untypedValue;
            if (value.EntitySpawnArray != null)
            {
                serializer.Serialize(writer, value.EntitySpawnArray);
                return;
            }
            if (value.Entit != null)
            {
                serializer.Serialize(writer, value.Entit);
                return;
            }
            throw new Exception("Cannot marshal type Entities");
        }

        public static readonly EntitiesConverter Singleton = new EntitiesConverter();
    }

    internal class AddEffectElementConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AddEffectElement) || t == typeof(AddEffectElement?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new AddEffectElement { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<AddEffectClass>(reader);
                    return new AddEffectElement { AddEffectClass = objectValue };
            }
            throw new Exception("Cannot unmarshal type AddEffectElement");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (AddEffectElement)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.AddEffectClass != null)
            {
                serializer.Serialize(writer, value.AddEffectClass);
                return;
            }
            throw new Exception("Cannot marshal type AddEffectElement");
        }

        public static readonly AddEffectElementConverter Singleton = new AddEffectElementConverter();
    }

    internal class AutoRejectItemsUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AutoRejectItemsUnion) || t == typeof(AutoRejectItemsUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<AutoRejectItemsClass>(reader);
                    return new AutoRejectItemsUnion { AutoRejectItemsClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<List<AutoRejectItemElement>>(reader);
                    return new AutoRejectItemsUnion { AutoRejectItemElementArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type AutoRejectItemsUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (AutoRejectItemsUnion)untypedValue;
            if (value.AutoRejectItemElementArray != null)
            {
                serializer.Serialize(writer, value.AutoRejectItemElementArray);
                return;
            }
            if (value.AutoRejectItemsClass != null)
            {
                serializer.Serialize(writer, value.AutoRejectItemsClass);
                return;
            }
            throw new Exception("Cannot marshal type AutoRejectItemsUnion");
        }

        public static readonly AutoRejectItemsUnionConverter Singleton = new AutoRejectItemsUnionConverter();
    }

    internal class FeedItemsConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FeedItems) || t == typeof(FeedItems?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FeedItemsClass>(reader);
                    return new FeedItems { FeedItemsClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<List<FeedItemElement>>(reader);
                    return new FeedItems { FeedItemElementArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type FeedItems");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (FeedItems)untypedValue;
            if (value.FeedItemElementArray != null)
            {
                serializer.Serialize(writer, value.FeedItemElementArray);
                return;
            }
            if (value.FeedItemsClass != null)
            {
                serializer.Serialize(writer, value.FeedItemsClass);
                return;
            }
            throw new Exception("Cannot marshal type FeedItems");
        }

        public static readonly FeedItemsConverter Singleton = new FeedItemsConverter();
    }

    internal class TentacledMinMaxValueCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(double) || t == typeof(double?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<double>(reader);
            if (value >= 128)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type double");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (double)untypedValue;
            if (value >= 128)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type double");
        }

        public static readonly TentacledMinMaxValueCheckConverter Singleton = new TentacledMinMaxValueCheckConverter();
    }

    internal class DelayUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DelayUnion) || t == typeof(DelayUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new DelayUnion { Double = doubleValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<DelayClass>(reader);
                    return new DelayUnion { DelayClass = objectValue };
            }
            throw new Exception("Cannot unmarshal type DelayUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (DelayUnion)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.DelayClass != null)
            {
                serializer.Serialize(writer, value.DelayClass);
                return;
            }
            throw new Exception("Cannot marshal type DelayUnion");
        }

        public static readonly DelayUnionConverter Singleton = new DelayUnionConverter();
    }

    internal class AnimationScriptConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AnimationScript) || t == typeof(AnimationScript?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new AnimationScript { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<Dictionary<string, string>>(reader);
                    return new AnimationScript { StringMap = objectValue };
            }
            throw new Exception("Cannot unmarshal type AnimationScript");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (AnimationScript)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.StringMap != null)
            {
                serializer.Serialize(writer, value.StringMap);
                return;
            }
            throw new Exception("Cannot marshal type AnimationScript");
        }

        public static readonly AnimationScriptConverter Singleton = new AnimationScriptConverter();
    }
}
